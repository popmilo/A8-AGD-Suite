ca65 V2.17 - Git d13d068
Main file   : game.asm
Current file: game.asm

000000r 1               ;----------------------------------------------
000000r 1               ; Common AGD engine
000000r 1               ; VIC20 conversion by Kees van Oss 2024
000000r 1               ;----------------------------------------------
000000r 1               
000000r 1               .segment "ZEROPAGE"
000000r 1               	.include "game.cfg"
000000r 2               ; Flags saved by AGD Compiler
000000r 2               
000000r 2               mflag = 0 ;
000000r 2               pflag = 0 ;
000000r 2               sflag = 0 ;
000000r 2               dflag = 0 ;
000000r 2               cflag = 0 ;
000000r 2               oflag = 0 ;
000000r 2               lflag = 0 ;
000000r 2               clwflag = 0 ;
000000r 2               
000000r 1               	.include "z80-zp.inc"
000000r 2               ws	 = $60
000000r 2               
000000r 2               z80_f	 = ws+$00
000000r 2               z80_a	 = ws+$01
000000r 2               z80_af	 = z80_f
000000r 2               
000000r 2               z80_c	 = ws+$02
000000r 2               z80_b	 = ws+$03
000000r 2               z80_bc	 = z80_c
000000r 2               
000000r 2               z80_e	 = ws+$04
000000r 2               z80_d	 = ws+$05
000000r 2               z80_de	 = z80_e
000000r 2               
000000r 2               z80_l	 = ws+$06
000000r 2               z80_h	 = ws+$07
000000r 2               z80_hl	 = z80_l
000000r 2               
000000r 2               z80_x    = ws+$08
000000r 2               z80_i    = ws+$09
000000r 2               z80_ix	 = z80_x
000000r 2               
000000r 2               z80_iy	 = ws+$0a
000000r 2               
000000r 2               z80_fp	 = ws+$0c
000000r 2               z80_ap	 = ws+$0d
000000r 2               
000000r 2               z80_cp	 = ws+$0e
000000r 2               z80_bp	 = ws+$0f
000000r 2               z80_bcp	 = z80_cp
000000r 2               
000000r 2               z80_ep	 = ws+$10
000000r 2               z80_dp	 = ws+$11
000000r 2               z80_dep	 = z80_ep
000000r 2               
000000r 2               z80_lp	 = ws+$12
000000r 2               z80_hp	 = ws+$13
000000r 2               z80_hlp	 = z80_lp
000000r 2               
000000r 2               z80_sp   = ws+$14
000000r 2               
000000r 2               z80_reg0 = ws+$16
000000r 2               z80_reg1 = ws+$17
000000r 2               z80_reg2 = ws+$18
000000r 2               z80_reg3 = ws+$19
000000r 2               
000000r 2               z80_r	 = ws+$1a
000000r 2               
000000r 2               
000000r 1               	.include "engine-zp.inc"
000000r 2               ;----------------------------------------------------------------------
000000r 2               ; AGD 6502 Engine Zero Page Variables
000000r 2               ;----------------------------------------------------------------------
000000r 2               
000000r 2               ; Variables start here.
000000r 2               
000000r 2  xx           scno:	.res 1			; present screen number.
000001r 2  xx           numlif:	.res 1			; number of lives.
000002r 2               
000002r 2  xx           vara:	.res 1			; general-purpose variable.
000003r 2  xx           varb:	.res 1			; general-purpose variable.
000004r 2  xx           varc:	.res 1			; general-purpose variable.
000005r 2  xx           vard:	.res 1			; general-purpose variable.
000006r 2  xx           vare:	.res 1			; general-purpose variable.
000007r 2  xx           varf:	.res 1			; general-purpose variable.
000008r 2  xx           varg:	.res 1			; general-purpose variable.
000009r 2  xx           varh:	.res 1			; general-purpose variable.
00000Ar 2  xx           vari:	.res 1			; general-purpose variable.
00000Br 2  xx           varj:	.res 1			; general-purpose variable.
00000Cr 2  xx           vark:	.res 1			; general-purpose variable.
00000Dr 2  xx           varl:	.res 1			; general-purpose variable.
00000Er 2  xx           varm:	.res 1			; general-purpose variable.
00000Fr 2  xx           varn:	.res 1			; general-purpose variable.
000010r 2  xx           varo:	.res 1			; general-purpose variable.
000011r 2  xx           varp:	.res 1			; general-purpose variable.
000012r 2  xx           varq:	.res 1			; general-purpose variable.
000013r 2  xx           varr:	.res 1			; general-purpose variable.
000014r 2  xx           vars:	.res 1			; general-purpose variable.
000015r 2  xx           vart:	.res 1			; general-purpose variable.
000016r 2  xx           varu:	.res 1			; general-purpose variable.
000017r 2  xx           varv:	.res 1			; general-purpose variable.
000018r 2  xx           varw:	.res 1			; general-purpose variable.
000019r 2  xx           varz:	.res 1			; general-purpose variable.
00001Ar 2               
00001Ar 2  xx           charx:	.res 1			; cursor x position.
00001Br 2  xx           chary:	.res 1			; cursor y position.
00001Cr 2               
00001Cr 2  xx           clock:	.res 1			; last clock reading.
00001Dr 2  xx           varrnd:	.res 1	        	; last random number.
00001Er 2  xx           varobj:	.res 1  	   	; last object number.
00001Fr 2  xx           varopt:	.res 1     		; last option chosen from menu.
000020r 2  xx           varblk:	.res 1  		; block type.
000021r 2  xx           nexlev:	.res 1			; next level flag.
000022r 2  xx           restfl:	.res 1			; restart screen flag.
000023r 2  xx           deadf:	.res 1			; dead flag.
000024r 2  xx           gamwon:	.res 1			; game won flag.
000025r 2               
000025r 2  xx xx        dvar:	.res 2
000027r 2               
000027r 2  xx           dispx:	.res 1			; cursor x position.
000028r 2  xx           dispy:	.res 1			; cursor y position.
000029r 2               
000029r 2  xx           contrl:	.res 1			; control = keyboard, 1 = Kempston, 2 = Sinclair, 3 = Mouse.
00002Ar 2  xx           joyval:	.res 1			; joystick reading.
00002Br 2  xx           frmno:	.res 1			; selected frame.
00002Cr 2               
00002Cr 2               ;----------------------------------------------------
00002Cr 2               ; Missing vars
00002Cr 2               ;----------------------------------------------------
00002Cr 2               
00002Cr 2  xx           loopa:	    .res 1
00002Dr 2  xx           loopb:	    .res 1
00002Er 2  xx           loopc:	    .res 1
00002Fr 2  xx xx        FontPtr:    .res 2
000031r 2               
000031r 2               ; Local vars
000031r 2               
000031r 2  xx xx        scraddr:    .res 2
000033r 2  xx xx        fntaddr:    .res 2
000035r 2  xx xx        tileaddr:   .res 2
000037r 2  xx xx        bufaddr:    .res 2
000039r 2  xx xx        advbuff:    .res 2
00003Br 2               
00003Br 2  xx xx        tmp:        .res 2
00003Dr 2  xx xx        scr_l:      .res 2
00003Fr 2  xx xx        scr_r:      .res 2
000041r 2  xx xx        scr_txt:    .res 2
000043r 2               
000043r 2  xx           xtmp:	    .res 1
000044r 2  xx           ytmp:	    .res 1
000045r 2  xx           spcnt:	    .res 1
000046r 2  xx xx        spptr:	    .res 2		; spawned sprite pointer.
000048r 2  xx           seed:	    .res 1		; seed for random numbers.
000049r 2               
000049r 2  xx           ccnt:       .res 1
00004Ar 2  xx           flag:	    .res 1
00004Br 2               
00004Br 2  xx           rcol:	    .res 1
00004Cr 2  xx           rrow:	    .res 1
00004Dr 2               
00004Dr 2  xx           combyt:	    .res 1		; byte type compressed.
00004Er 2  xx           comcnt:	    .res 1		; compression counter.
00004Fr 2  xx           prtmod:	    .res 1      	; print mode, 0 = standard, 1 = double-height.
000050r 2  xx           qscnt:	    .res 1
000051r 2               
000051r 2  xx           sprptr:	    .res 1      	; not a ptr
000052r 2  xx           sprcnt:	    .res 1
000053r 2               
000053r 2  xx xx        skptr:	    .res 2		; search pointer.
000055r 2  xx           sktptr:	    .res 1      	; not a ptr
000056r 2  xx           tmproom:    .res 1
000057r 2  xx xx        ogptr:	    .res 2		; original sprite pointer.
000059r 2               
000059r 2               ;sndtyp:     .res 1
000059r 2               
000059r 1               
000059r 1               ;----------------------------------------------
000059r 1               ; BASIC header
000059r 1               ;----------------------------------------------
000059r 1               
000059r 1               .segment "BASIC"
000000r 1               
000000r 1  rr rr        	.word load
000002r 1  rr rr        load:   .word @end
000004r 1  02 00        	.word 2
000006r 1  9E           	.byte $9e
000007r 1  rr           	.byte .lobyte(main/1000 .mod 10) + $30
000008r 1  rr           	.byte .lobyte(main/100 .mod 10) + $30
000009r 1  rr           	.byte .lobyte(main/10 .mod 10) + $30
00000Ar 1  rr           	.byte .lobyte(main/1 .mod 10) + $30
00000Br 1  00           	.byte 0
00000Cr 1  00 00        @end:   .word 0
00000Er 1               
00000Er 1               ;----------------------------------------------
00000Er 1               
00000Er 1               .segment "CODE"
000000r 1               main:
000000r 1               	.include "game.inc"
000000r 2               .include "TEST.inc"
000000r 3               ;--------------------------------------------------------------
000000r 3               ; Arcade Game Designer.
000000r 3               ; (C) 2008 Jonathan Cauldwell.
000000r 3               ; ZX Spectrum Engine v0.10
000000r 3               ; VIC20 port by Mauro and K.v.Oss 2024
000000r 3               ;--------------------------------------------------------------
000000r 3               
000000r 3               ;--------------------------------------------------------------
000000r 3               ; Conditional compilation flags
000000r 3               ; Code is installed if flag is set
000000r 3               ; Flags are set in commandline assembly or by the compiler
000000r 3               ;--------------------------------------------------------------
000000r 3               
000000r 3               ; Flags set by AGD compiler
000000r 3               ;	cflag			; collectable blocks
000000r 3               ;	dflag 			; digging mode
000000r 3               ;	lflag			; ladders
000000r 3               ;	mflag  			; MENU + INV
000000r 3               ;	oflag			; objects
000000r 3               ;	pflag 			; particle engine
000000r 3               ;	sflag 			; scrollytext
000000r 3               ;	clwflag			; CLW code
000000r 3               ;	bigflag			; Bigtext code
000000r 3               ;
000000r 3               ; Flags set manually in commandline
000000r 3               ;	aflag			; adventure mode
000000r 3               ;	bflag			; big sprites (16x24)
000000r 3               ;	crflag			; crumbling blocks
000000r 3               ;	fflag			; floppy version (skip #0axx)
000000r 3               ;	gflag			; graphic colour mode
000000r 3               ;	hflag			; hidden sprite mode
000000r 3               ;	iflag			; invert mode
000000r 3               ;	kflag			; color attributes control (Breakanoid)
000000r 3               ;	rflag			; RAM Pre-Shifted Tables
000000r 3               ;	xflag			; metablocks (16x16)
000000r 3               
000000r 3               ;--------------------------------------------------------------
000000r 3               ; Temporary setting of flags
000000r 3               ; Needs to be updated for VIC usage
000000r 3               ;--------------------------------------------------------------
000000r 3               
000000r 3               	aflag 	= 0		; adventure mode
000000r 3               	bflag	= 0		; big sprites (16x24)
000000r 3               	bigflag = 0
000000r 3               	crflag 	= 0		; crumbling blocks
000000r 3               	fflag 	= 0		; floppy version (skip #0axx)
000000r 3               	gflag 	= 0		; graphic colour mode
000000r 3               	hflag 	= 0		; hidden sprite mode
000000r 3               	iflag 	= 0		; invert mode
000000r 3               	kflag 	= 0		; color attributes control (Breakanoid)
000000r 3               	rflag 	= 0			; RAM Pre-Shifted Tables
000000r 3               	xflag 	= 0		; metablocks (16x16)
000000r 3               
000000r 3               .if aflag
000000r 3               	.out "- Adventure mode enabled"
000000r 3               .endif
000000r 3               .if bflag
000000r 3               	.out "- Big Sprites (16x24) enabled"
000000r 3               .endif
000000r 3               .if bigflag
000000r 3               	.out "- Big Text enabled"
000000r 3               .endif
000000r 3               .if cflag
000000r 3               	.out "- Collectable blocks enabled"
000000r 3               .endif
000000r 3               .if crflag
000000r 3               	.out "- Crumbled blockmode enabled"
000000r 3               .endif
000000r 3               .if dflag
000000r 3               	.out "- Digging enabled"
000000r 3               .endif
000000r 3               .if gflag
000000r 3               	.out "- Colourmode enabled"
000000r 3               .endif
000000r 3               .if hflag
000000r 3               	.out "- Hidden sprites/foregroundblocks enabled"
000000r 3               .endif
000000r 3               .if iflag
000000r 3               	.out "- Invert mode enabled"
000000r 3               .endif
000000r 3               ;.if kflag
000000r 3               ;	.out "- Save colour table enabled"
000000r 3               ;.endif
000000r 3               .if lflag
000000r 3               	.out "- Ladders enabled"
000000r 3               .endif
000000r 3               .if mflag
000000r 3               	.out "- MEN/INV enabled"
000000r 3               .endif
000000r 3               .if oflag
000000r 3               	.out "- Objects enabled"
000000r 3               .endif
000000r 3               .if pflag
000000r 3               	.out "- Particles enabled"
000000r 3               .endif
000000r 3               .if rflag
000000r 3               	.out "- RAM saving spritemode enabled"
000000r 3               .endif
000000r 3               .if sflag
000000r 3               	.out "- Scrolling enabled"
000000r 3               .endif
000000r 3               .if xflag
000000r 3               	.out "- Metabclocksmode enabled"
000000r 3               .endif
000000r 3               .out ""
000000r 3               
000000r 3               ;------------------------------------------------------------
000000r 3               ; Constants MPAGD
000000r 3               ;------------------------------------------------------------
000000r 3               
000000r 3               ; Global definitions
000000r 3               
000000r 3               	MAP 		= MapAddr	; properties map buffer (3x256 bytes)
000000r 3               	SCROFF_lb 	= MAP+3*256	; screen address line table lo-byte (24 bytes)
000000r 3               	SCROFF_hb 	= SCROFF_lb+24	; screen address line table hi-byte (24 bytes)
000000r 3               	SHRAPN 		= SCROFF_hb+24	; shrapnel table (55x6 bytes)
000000r 3               
000000r 3               ; Block characteristics.
000000r 3               
000000r 3               	PLATFM		= 1		; platform.
000000r 3               	WALL		= PLATFM + 1	; solid wall.
000000r 3               	LADDER		= WALL + 1	; ladder.
000000r 3               	FODDER		= LADDER + 1	; fodder block.
000000r 3               	DEADLY		= FODDER + 1	; deadly block.
000000r 3               	CUSTOM		= DEADLY + 1	; custom block.
000000r 3               	WATER		= CUSTOM + 1	; water block.
000000r 3                       COLECT		= WATER + 1	; collectable block.
000000r 3               	HIDDEN 		= COLECT + 1	; hide behind block
000000r 3                       NUMTYP		= COLECT + 1	; number of types.
000000r 3               
000000r 3               ; Sprites.
000000r 3               
000000r 3               .if bflag
000000r 3               	SPR_HGT		= 24		; Sprite height
000000r 3               	SPR_WID 	= 16		; Sprite width
000000r 3               	NUMSPR		= 8		; number of sprites.
000000r 3               	COLDISTY 	= 24		; Collision distance
000000r 3               .else					; 16x16 sprites
000000r 3               	SPR_HGT 	= 16		; Sprite height
000000r 3               	SPR_WID 	= 16		; Sprite width
000000r 3               	NUMSPR		= 12		; number of sprites.
000000r 3               	COLDISTY 	= 16		; Collision distance
000000r 3               .endif
000000r 3               
000000r 3               	TABSIZ 		= 17		; size of each entry.
000000r 3               	SPRBUF 		= NUMSPR*TABSIZ	; size of entire table.
000000r 3               	NMESIZ 		= 4		; bytes stored in nmetab for each sprite.
000000r 3               	var_X  		= 8		; new x coordinate of sprite.
000000r 3               	var_Y  		= var_X + 1	; new y coordinate of sprite.
000000r 3               	PAM1ST 		= 5		; first sprite parameter, old x (ix+5).
000000r 3               	COLDISTX 	= 16		; Collision distance
000000r 3               
000000r 3               ; Particle engine.
000000r 3               
000000r 3               	NUMSHR 		= 55		; pieces of shrapnel.
000000r 3               	SHRSIZ 		= 6		; bytes per particle.
000000r 3               
000000r 3               
000000r 3               .if iflag
000000r 3               	TxtInvert   	= $ff		; Invert byte for character printing
000000r 3               	ScrFillByte 	= $ff		; Screen fill byte for CLS
000000r 3               .else
000000r 3               	TxtInvert   	= $00		; Invert byte for character printing
000000r 3               	ScrFillByte 	= $00		; Screen fill byte for CLS
000000r 3               .endif
000000r 3               
000000r 3               .if gflag
000000r 3               	ScrMode    	= $d0		;  $d0 = CLEAR4a colour
000000r 3               .else
000000r 3               	ScrMode     	= $f0		;  $f0 = CLEAR4  mono
000000r 3               .endif
000000r 3               
000000r 3               
000000r 3               ;===============================================================
000000r 3               ; Game starts here
000000r 3               ;===============================================================
000000r 3               
000000r 3  20 rr rr     	jsr Init
000003r 3               
000003r 3               ;-------------------------------------------------------------------
000003r 3               ; Clear ZP variables
000003r 3               ;-------------------------------------------------------------------
000003r 3               
000003r 3  A9 00        	lda #0
000005r 3  AA           	tax
000006r 3               clrloop:
000006r 3  95 00        	sta 0,x
000008r 3  E8           	inx
000009r 3  D0 FB        	bne clrloop
00000Br 3               
00000Br 3               ;------------------------------------------------------------------
00000Br 3               ; Start game
00000Br 3               ;------------------------------------------------------------------
00000Br 3               
00000Br 3  20 rr rr     	jsr cls			; Clear screen
00000Er 3               start:
00000Er 3  20 rr rr     	jsr game	 	; start the game.
000011r 3  4C rr rr     	jmp start
000014r 3               
000014r 3               ;------------------------------------------------------------------
000014r 3               ; Sprite table
000014r 3               ;------------------------------------------------------------------
000014r 3               
000014r 3               ; ix+0  = type.
000014r 3               ; ix+1  = sprite image number.
000014r 3               ; ix+2  = frame.
000014r 3               ; ix+3  = y coord.
000014r 3               ; ix+4  = x coord.
000014r 3               
000014r 3               ; ix+5  = new type.
000014r 3               ; ix+6  = new image number.
000014r 3               ; ix+7  = new frame.
000014r 3               ; ix+8  = new y coord.
000014r 3               ; ix+9  = new x coord.
000014r 3               
000014r 3               ; ix+10 = direction.
000014r 3               ; ix+11 = parameter 1.
000014r 3               ; ix+12 = parameter 2.
000014r 3               ; ix+13 = jump pointer low.
000014r 3               ; ix+14 = jump pointer high.
000014r 3               ; ix+15 = data pointer low.
000014r 3               ; ix+16 = data pointer high.
000014r 3               
000014r 3               ; block NUMSPR * TABSIZ,255
000014r 3               
000014r 3  FF FF FF FF  sprtab:	.res NUMSPR*TABSIZ,255
000018r 3  FF FF FF FF  
00001Cr 3  FF FF FF FF  
0000E0r 3  FF FF FF FF  ssprit:	.byte 255,255,255,255,255,255,255,0,192,120,0,0,0,255,255,255,255
0000E4r 3  FF FF FF 00  
0000E8r 3  C0 78 00 00  
0000F1r 3  07           roomtb:	.byte 7                      ; start room map offset.
0000F2r 3               
0000F2r 3               ;----------------------------------------------
0000F2r 3               ; Copy sprite from list to table.
0000F2r 3               ;
0000F2r 3               ; global:	hl,ix
0000F2r 3               ; local:	y
0000F2r 3               ; calls:	evnt09
0000F2r 3               ;----------------------------------------------
0000F2r 3               
0000F2r 3               cpsp:
0000F2r 3  A0 00        	ldy #0				; fetch byte from table.
0000F4r 3  B1 66        	lda (z80_hl),y
0000F6r 3  91 68        	sta (z80_ix),y			; set up type.
0000F8r 3  A0 05        	ldy #PAM1ST
0000FAr 3  91 68        	sta (z80_ix),y 			; set up type.
0000FCr 3               
0000FCr 3  E6 66        	inc z80_l 			; move to next byte.
0000FEr 3  D0 02        	bne :+
000100r 3  E6 67        	inc z80_h
000102r 3               :
000102r 3  A0 00        	ldy #0 				; fetch byte from table.
000104r 3  B1 66        	lda (z80_hl),y
000106r 3  A0 06        	ldy #6
000108r 3  91 68        	sta (z80_ix),y			; set up image.
00010Ar 3               
00010Ar 3  E6 66        	inc z80_l 			; move to next byte.
00010Cr 3  D0 02        	bne :+
00010Er 3  E6 67        	inc z80_h
000110r 3               :
000110r 3  A0 00        	ldy #0
000112r 3  B1 66        	lda (z80_hl),y 			; fetch byte from table.
000114r 3  A0 08        	ldy #8
000116r 3  91 68        	sta (z80_ix),y 			; set up coordinate.
000118r 3               
000118r 3  A9 C8        	lda #200 			; set initial coordinate off screen.
00011Ar 3  A0 03        	ldy #3
00011Cr 3  91 68        	sta (z80_ix),y
00011Er 3               
00011Er 3  E6 66        	inc z80_l 			; move to next byte.
000120r 3  D0 02        	bne :+
000122r 3  E6 67        	inc z80_h
000124r 3               :
000124r 3  A0 00        	ldy #0 				; fetch byte from table.
000126r 3  B1 66        	lda (z80_hl),y
000128r 3  A0 09        	ldy #9
00012Ar 3  91 68        	sta (z80_ix),y 			; set up coordinate.
00012Cr 3               
00012Cr 3  E6 66        	inc z80_l 			; move to next byte.
00012Er 3  D0 02        	bne :+
000130r 3  E6 67        	inc z80_h
000132r 3               :
000132r 3  A9 00        	lda #0				; zeroes in accumulator.
000134r 3  A0 07        	ldy #7 				; reset frame number.
000136r 3  91 68        	sta (z80_ix),y
000138r 3  A0 0A        	ldy #10 			; reset direction.
00013Ar 3  91 68        	sta (z80_ix),y
00013Cr 3  A0 0D        	ldy #13				; reset jump pointer low.
00013Er 3  91 68        	sta (z80_ix),y
000140r 3  C8           	iny	 			; reset jump pointer high.
000141r 3  91 68        	sta (z80_ix),y
000143r 3               
000143r 3  A9 FF        	lda #255 			; reset data pointer to auto-restore.
000145r 3  A0 10        	ldy #16
000147r 3  91 68        	sta (z80_ix),y
000149r 3               evis0:
000149r 3  A5 69        	lda z80_i
00014Br 3  48           	pha
00014Cr 3  A5 68        	lda z80_x
00014Er 3  48           	pha
00014Fr 3  A5 67        	lda z80_h
000151r 3  48           	pha
000152r 3  A5 66        	lda z80_l
000154r 3  48           	pha
000155r 3               
000155r 3  20 rr rr     	jsr evnt09 			; perform event.
000158r 3               
000158r 3  68           	pla
000159r 3  85 66        	sta z80_l
00015Br 3  68           	pla
00015Cr 3  85 67        	sta z80_h
00015Er 3  68           	pla
00015Fr 3  85 68        	sta z80_x
000161r 3  68           	pla
000162r 3  85 69        	sta z80_i
000164r 3               
000164r 3  18           	clc
000165r 3  A5 68        	lda z80_x 			; distance to next odd/even entry.
000167r 3  69 11        	adc #TABSIZ		 	; next sprite.
000169r 3  85 68        	sta z80_x
00016Br 3  90 02        	bcc :+
00016Dr 3  E6 69        	inc z80_i
00016Fr 3               :
00016Fr 3  60           	rts
000170r 3               
000170r 3               ;-----------------------------------------
000170r 3               ; Jump to new screen.
000170r 3               ;-----------------------------------------
000170r 3               
000170r 3               nwscr:
000170r 3  A2 00        	ldx #0				; start of map data.
000172r 3               nwscr0:
000172r 3  DD rr rr     	cmp mapdat,x
000175r 3  F0 04        	beq nwscr1			; have we found a match for screen?
000177r 3  E8           	inx 				; next room.
000178r 3               ;	cpx #80				; zero room count, 80 to search.
000178r 3  D0 F8        	bne nwscr0			; keep looking.
00017Ar 3  60           	rts
00017Br 3               nwscr1:
00017Br 3  8E rr rr     	stx roomtb			; set the map position.
00017Er 3  4C rr rr     	jmp scrl1			; draw new room.
000181r 3               
000181r 3               
000181r 3               ;----------------------------------------------------------
000181r 3               ; Gravity processing.
000181r 3               ;----------------------------------------------------------
000181r 3               
000181r 3               grav:
000181r 3               grav_skip:
000181r 3  A0 0D        	ldy #13		; grav   ld a,(ix+13)        ; in-air flag.
000183r 3  B1 68        	lda (z80_ix),y
000185r 3               			;        and a               ; are we in the air?
000185r 3  F0 38        	beq gravex
000187r 3  18           	clc		;        inc a               ; increment it.
000188r 3  69 01        	adc #1
00018Ar 3  F0 66        	beq ogrv	;        jp z,ogrv           ; set to 255, use old gravity.
00018Cr 3  91 68        	sta (z80_ix),y	;        ld (ix+13),a        ; write new setting.
00018Er 3  4A           	lsr a		;        rra                 ; every other frame.
00018Fr 3  B0 0C        	bcs grav0	;        jr nc,grav0         ; don't apply gravity this time.
000191r 3  C8           	iny		;        ld a,(ix+14)        ; pixels to move.
000192r 3  B1 68        	lda (z80_ix),y
000194r 3  C9 10        	cmp #16		;        cp 16               ; reached maximum?
000196r 3  F0 05        	beq grav0	;        jr z,grav0          ; yes, continue.
000198r 3  18           	clc		;        inc (ix+14)         ; slow down ascent/speed up fall.
000199r 3  69 01        	adc #1
00019Br 3  91 68        	sta (z80_ix),y
00019Dr 3  A0 0E        grav0:	ldy #14		; grav0  ld a,(ix+14)        ; get distance to move.
00019Fr 3  B1 68        	lda (z80_ix),y
0001A1r 3  48           	pha
0001A2r 3  0A           	asl a
0001A3r 3  68           	pla
0001A4r 3  6A           	ror a		;        sra a               ; divide by 2.
0001A5r 3               			;        and a               ; any movement required?
0001A5r 3  F0 18        grav1:	beq gravex
0001A7r 3  C9 80        	cmp #128	;        cp 128              ; is it up or down?
0001A9r 3  B0 15        	bcs gravu	;        jr nc,gravu         ; it's up.
0001ABr 3  85 63        gravd:	sta z80_b	; gravd  ld b,a              ; set pixels to move.
0001ADr 3  20 rr rr     gravd0:	jsr cangd	; gravd0 call cangd          ; can we go down?
0001B0r 3  D0 2B        	bne gravst	;        jr nz,gravst        ; can't move down, so stop.
0001B2r 3  A0 08        	ldy #8		;        inc (ix+8)          ; adjust new x coord.
0001B4r 3  B1 68        	lda (z80_ix),y
0001B6r 3  18           	clc
0001B7r 3  69 01        	adc #1
0001B9r 3  91 68        	sta (z80_ix),y
0001BBr 3  C6 63        	dec z80_b
0001BDr 3  D0 EE        	bne gravd0	;        djnz gravd0
0001BFr 3  60           gravex:	rts		;        ret
0001C0r 3               
0001C0r 3  49 FF        gravu:	eor #$ff	; gravu  neg                 ; flip the sign so it's positive.
0001C2r 3  18           	clc
0001C3r 3  69 01        	adc #1
0001C5r 3  85 63        	sta z80_b	;        ld b,a              ; set pixels to move.
0001C7r 3  20 rr rr     gravu0:	jsr cangu	; gravu0 call cangu          ; can we go up?
0001CAr 3  F0 03        	beq :+
0001CCr 3  4C rr rr     	jmp ifalls	;        jp nz,ifalls        ; can't move up, go down next.
0001CFr 3               :
0001CFr 3  A0 08        	ldy #8		;        dec (ix+8)          ; adjust new x coord.
0001D1r 3  B1 68        	lda (z80_ix),y
0001D3r 3  38           	sec
0001D4r 3  E9 01        	sbc #1
0001D6r 3  91 68        	sta (z80_ix),y
0001D8r 3  C6 63        	dec z80_b	;        djnz gravu0
0001DAr 3  D0 EB        	bne gravu0
0001DCr 3  60           	rts		;        ret
0001DDr 3  A0 0E        gravst:	ldy #14		; gravst ld a,(ix+14)        ; jump pointer high.
0001DFr 3  B1 68        	lda (z80_ix),y
0001E1r 3  48           	pha
0001E2r 3  A9 00        	lda #0
0001E4r 3  91 68        	sta (z80_ix),y	;        ld (ix+14),0        ; store new speed.
0001E6r 3  88           	dey
0001E7r 3  91 68        	sta (z80_ix),y	;        ld (ix+13),0        ; reset falling flag.
0001E9r 3  68           	pla
0001EAr 3  C9 08        	cmp #8		;        cp 8                ; was speed the maximum?
0001ECr 3  D0 03        evftf:	bne :+
0001EEr 3  4C rr rr     	jmp evnt15	; evftf  jp z,evnt15         ; yes, fallen too far.
0001F1r 3               :
0001F1r 3  60           	rts		;        ret
0001F2r 3               
0001F2r 3               ; Old gravity processing for compatibility with 4.6 and 4.7.
0001F2r 3               
0001F2r 3               ogrv:
0001F2r 3  A0 0E        	ldy #14		; ogrv   ld e,(ix+14)        ; get index to table.
0001F4r 3  B1 68        	lda (z80_ix),y
0001F6r 3  AA           	tax
0001F7r 3               			;        ld d,0              ; no high byte.
0001F7r 3               			;        ld hl,jtab          ; jump table.
0001F7r 3               			;        add hl,de           ; hl points to jump value.
0001F7r 3  BD rr rr     	lda jtab,x	;        ld a,(hl)           ; pixels to move.
0001FAr 3  C9 63        	cmp #99		;        cp 99               ; reached the end?
0001FCr 3  D0 07        	bne ogrv0	;        jr nz,ogrv0         ; no, continue.
0001FEr 3  CA           	dex		;        dec hl              ; go back to previous value.
0001FFr 3  BD rr rr     	lda jtab,x	;        ld a,(hl)           ; fetch that from table.
000202r 3  4C rr rr     	jmp ogrv1	;        jr ogrv1
000205r 3               ogrv0:
000205r 3  48           	pha
000206r 3  A0 0E        	ldy #14		; ogrv0  inc (ix+14)         ; point to next table entry.
000208r 3  B1 68        	lda (z80_ix),y
00020Ar 3  18           	clc
00020Br 3  69 01        	adc #1
00020Dr 3  91 68        	sta (z80_ix),y
00020Fr 3  68           	pla
000210r 3               ogrv1:			; ogrv1  and a               ; any movement required?
000210r 3  F0 32        	beq ogrvex      ;	 ret z               ; no, not this time.
000212r 3  C9 80        	cmp #128	;        cp 128              ; is it up or down?
000214r 3  B0 15        	bcs ogrvu	;        jr nc,ogrvu         ; it's up.
000216r 3  85 63        ogrvd:	sta z80_b	; ogrvd  ld b,a              ; set pixels to move.
000218r 3  20 rr rr     ogrvd0:	jsr cangd	; ogrvd0 call cangd          ; can we go down?
00021Br 3  D0 28        	bne ogrvst	;        jr nz,ogrvst        ; can't move down, so stop.
00021Dr 3  A0 08        	ldy #8		;        inc (ix+8)          ; adjust new x coord.
00021Fr 3  B1 68        	lda (z80_ix),y
000221r 3  18           	clc
000222r 3  69 01        	adc #1
000224r 3  91 68        	sta (z80_ix),y
000226r 3  C6 63        	dec z80_b
000228r 3  D0 EE        	bne ogrvd0	;        djnz ogrvd0
00022Ar 3  60           	rts		;        ret
00022Br 3               
00022Br 3  49 FF        ogrvu:	eor #$ff	; ogrvu  neg                 ; flip the sign so it's positive.
00022Dr 3  18           	clc
00022Er 3  69 01        	adc #1
000230r 3  85 63        	sta z80_b	;        ld b,a              ; set pixels to move.
000232r 3  20 rr rr     ogrvu0:	jsr cangu	; ogrvu0 call cangu          ; can we go up?
000235r 3  D0 25        	bne ogrv2	;        jr nz,ogrv2         ; can't move up, go down next.
000237r 3  A0 08        	ldy #8		;        dec (ix+8)          ; adjust new x coord.
000239r 3  B1 68        	lda (z80_ix),y
00023Br 3  38           	sec
00023Cr 3  E9 01        	sbc #1
00023Er 3  91 68        	sta (z80_ix),y
000240r 3  C6 63        	dec z80_b	;        djnz ogrvu0
000242r 3  D0 EE        	bne ogrvu0
000244r 3  60           ogrvex:	rts		;        ret
000245r 3               
000245r 3  A0 0E        ogrvst:	ldy #14		; ogrvst ld e,(ix+14)        ; get index to table.
000247r 3  B1 68        	lda (z80_ix),y
000249r 3  AA           	tax
00024Ar 3               			;        ld d,0              ; no high byte.
00024Ar 3               			;        ld hl,jtab          ; jump table.
00024Ar 3               			;        add hl,de           ; hl points to jump value.
00024Ar 3               
00024Ar 3  A9 00        	lda #0		;        ld (ix+13),0        ; reset jump flag.
00024Cr 3  91 68        	sta (z80_ix),y
00024Er 3  88           	dey
00024Fr 3  91 68        	sta (z80_ix),y	;        ld (ix+14),0        ; reset pointer.
000251r 3  BD rr rr     	lda jtab,x	;        ld a,(hl)           ; fetch byte from table.
000254r 3  C9 63        	cmp #99		;        cp 99               ; is it the end marker?
000256r 3  D0 03        	bne :+
000258r 3  4C rr rr     	jmp evnt15	; evftf  jp z,evnt15         ; yes, fallen too far.
00025Br 3               :
00025Br 3  60           	rts		;        ret
00025Cr 3               
00025Cr 3  A2 00        ogrv2:	ldx #0		; ogrv2  ld hl,jtab          ; jump table.
00025Er 3  A9 00        	lda #0		;        ld b,0              ; offset into table.
000260r 3  85 63        	sta z80_b
000262r 3  BD rr rr     ogrv4:	lda jtab,x	; ogrv4  ld a,(hl)           ; fetch table byte.
000265r 3  C9 64        	cmp #100	;        cp 100              ; hit end or downward move?
000267r 3  90 06        	bcc ogrv3	;        jr c,ogrv3          ; yes.
000269r 3  E8           	inx		;        inc hl              ; next byte of table.
00026Ar 3  E6 63        	inc z80_b	;        inc b               ; next offset.
00026Cr 3  4C rr rr     	jmp ogrv4	;        jr ogrv4            ; keep going until we find crest/end of table.
00026Fr 3  A0 0E        ogrv3:	ldy #14		; ogrv3  ld (ix+14),b        ; set next table offset.
000271r 3  A5 63        	lda z80_b
000273r 3  91 68        	sta (z80_ix),y
000275r 3  60           	rts		;        ret
000276r 3               
000276r 3               ; Initiate fall check.
000276r 3               
000276r 3  A0 0D        ifall:	ldy #13		; ifall  ld a,(ix+13)        ; jump pointer flag.
000278r 3  B1 68        	lda (z80_ix),y
00027Ar 3               			;        and a               ; are we in the air?
00027Ar 3  F0 01        	beq :+		;        ret nz              ; if set, we're already in the air.
00027Cr 3  60           	rts
00027Dr 3               :
00027Dr 3  A0 09        	ldy #9		;        ld h,(ix+9)         ; y coordinate.
00027Fr 3  B1 68        	lda (z80_ix),y
000281r 3  85 rr        	sta dispx
000283r 3  A0 08        	ldy #8		;        add a,(ix+8)        ; add x coordinate.
000285r 3  B1 68        	lda (z80_ix),y
000287r 3  18           	clc
000288r 3  69 10        	adc #SPR_HGT	;        ld a,16             ; look down 16 pixels.
00028Ar 3  85 rr        	sta dispy	;        ld l,a              ; coords in hl.
00028Cr 3               			;        ld (dispx),hl       ; set up test coordinates.
00028Cr 3  20 rr rr     	jsr tstbl	;        call tstbl          ; get map address.
00028Fr 3  20 rr rr     	jsr plchk	;        call plchk          ; block, platform check.
000292r 3  F0 01        	beq :+		;        ret nz              ; it's solid, don't fall.
000294r 3  60           	rts
000295r 3               :
000295r 3  E6 rr        	inc bufaddr	;        inc hl              ; look right one cell.
000297r 3  20 rr rr     	jsr plchk	;        call plchk          ; block, platform check.
00029Ar 3  F0 01        	beq :+
00029Cr 3  60           	rts		;        ret nz              ; it's solid, don't fall.
00029Dr 3               :
00029Dr 3  A5 rr        	lda dispx	;        ld a,(dispy)        ; y coordinate.
00029Fr 3  29 07        	and #7		;        and 7               ; position straddling block cells.
0002A1r 3  F0 08        	beq ifalls	;        jr z,ifalls         ; no more checks needed.
0002A3r 3  E6 rr        	inc bufaddr	;        inc hl              ; look to third cell.
0002A5r 3  20 rr rr     	jsr plchk	;        call plchk          ; block, platform check.
0002A8r 3  F0 01        	beq ifalls
0002AAr 3  60           	rts		;        ret nz              ; it's solid, don't fall.
0002ABr 3               
0002ABr 3  A0 0D        ifalls:	ldy #13		; ifalls inc (ix+13)         ; set in air flag.
0002ADr 3  B1 68        	lda (z80_ix),y
0002AFr 3  18           	clc
0002B0r 3  69 01        	adc #1
0002B2r 3  91 68        	sta (z80_ix),y
0002B4r 3  A9 00        	lda #0		;        ld (ix+14),0        ; initial speed = 0
0002B6r 3  C8           	iny
0002B7r 3  91 68        	sta (z80_ix),y
0002B9r 3  60           	rts		;        ret
0002BAr 3               
0002BAr 3  A0 0D        tfall:	ldy #13		; tfall  ld a,(ix+13)        ; jump pointer flag.
0002BCr 3  B1 68        	lda (z80_ix),y
0002BEr 3               			;        and a               ; are we in the air?
0002BEr 3  F0 01        	beq :+
0002C0r 3  60           	rts		;        ret nz              ; if set, we're already in the air.
0002C1r 3  20 rr rr     :	jsr ifall	;        call ifall          ; do fall test.
0002C4r 3  A0 0D        	ldy #13		;        ld a,(ix+13)        ; get falling flag.
0002C6r 3  B1 68        	lda (z80_ix),y
0002C8r 3               			;        and a               ; is it set?
0002C8r 3  D0 01        	bne :+
0002CAr 3  60           	rts		;        ret z               ; no.
0002CBr 3  A9 FF        :	lda #255
0002CDr 3  91 68        	sta (z80_ix),y	;        ld (ix+13),255      ; we're using the table.
0002CFr 3  4C rr rr     	jmp ogrv2	;        jr ogrv2            ; find position in table.
0002D2r 3               
0002D2r 3               
0002D2r 3               ;----------------------------------------------------
0002D2r 3               ; Get frame data for a particular sprite.
0002D2r 3               ; Input:
0002D2r 3               ;  a		= framenumer
0002D2r 3               ; Output:
0002D2r 3               ;  hl		= frame address
0002D2r 3               ;
0002D2r 3               ; global:	hl,frmptr
0002D2r 3               ; local:	-
0002D2r 3               ; calls:	-
0002D2r 3               ;----------------------------------------------------
0002D2r 3               
0002D2r 3               gfrm:
0002D2r 3  0A           	asl a	 		 	; multiple of 2.
0002D3r 3  18           	clc
0002D4r 3  69 rr        	adc #<frmlst 			; frames used by game.
0002D6r 3  85 66        	sta z80_l
0002D8r 3  A9 rr        	lda #>frmlst
0002DAr 3  69 00        	adc #0
0002DCr 3  85 67        	sta z80_h 			; point to frame start.
0002DEr 3  60           	rts
0002DFr 3               
0002DFr 3               ;----------------------------------------------------
0002DFr 3               ; Find sprite list for current room.
0002DFr 3               ;
0002DFr 3               ; global:	hl
0002DFr 3               ; local:	x,y
0002DFr 3               ; calls:	-
0002DFr 3               ;----------------------------------------------------
0002DFr 3               
0002DFr 3               sprlst:
0002DFr 3  A9 rr        	lda #<nmedat 			; list of enemy sprites.
0002E1r 3  85 66        	sta z80_l
0002E3r 3  A9 rr        	lda #>nmedat
0002E5r 3  85 67        	sta z80_h
0002E7r 3  A6 rr        	ldx scno 			; screen number.
0002E9r 3  D0 01        	bne sprls2 			; is it the first screen?
0002EBr 3  60           	rts 				; yes, don't need to search data.
0002ECr 3               sprls2:
0002ECr 3  A0 00        	ldy #0
0002EEr 3               sprls1:
0002EEr 3  B1 66        	lda (z80_hl),y 			; fetch type of sprite.
0002F0r 3  C9 FF        	cmp #255			; is it an end marker?
0002F2r 3  F0 0E        	beq sprls0 			; yes, end of this room.
0002F4r 3               
0002F4r 3  18           	clc 				; point to next sprite in list.
0002F5r 3  A5 66        	lda z80_l
0002F7r 3  69 04        	adc #NMESIZ
0002F9r 3  85 66        	sta z80_l
0002FBr 3  90 02        	bcc :+
0002FDr 3  E6 67        	inc z80_h
0002FFr 3               :
0002FFr 3  4C rr rr     	jmp sprls1 			; continue until end of room.
000302r 3               sprls0:
000302r 3  E6 66        	inc z80_l 			; point to start of next screen.s
000304r 3  D0 02        	bne :+
000306r 3  E6 67        	inc z80_h
000308r 3               :
000308r 3  CA           	dex
000309r 3  D0 E3        	bne sprls1 			; continue until room found.
00030Br 3  60           	rts
00030Cr 3               
00030Cr 3               
00030Cr 3               ;----------------------------------------------------
00030Cr 3               ; Clear all but a single player sprite.
00030Cr 3               ;
00030Cr 3               ; global:	-
00030Cr 3               ; local:	x,y,ix
00030Cr 3               ; calls:	-
00030Cr 3               ;----------------------------------------------------
00030Cr 3               
00030Cr 3               nspr:
00030Cr 3  A9 0C        	lda #NUMSPR			; sprite slots in table.
00030Er 3  85 rr        	sta sprcnt
000310r 3  A9 rr        	lda #<sprtab 			; sprite table.
000312r 3  85 68        	sta z80_x
000314r 3  A9 rr        	lda #>sprtab
000316r 3  85 69        	sta z80_i
000318r 3               nspr0:
000318r 3  A0 00        	ldy #0 				; fetch sprite type.
00031Ar 3  B1 68        	lda (z80_ix),y 			; is it a player?
00031Cr 3  F0 1A        	beq nspr1 			; yes, keep this one.
00031Er 3               
00031Er 3  A9 FF        	lda #255
000320r 3  A0 00        	ldy #0 				; fetch sprite type.
000322r 3  91 68        	sta (z80_ix),y 			; delete sprite.
000324r 3  A0 05        	ldy #5
000326r 3  91 68        	sta (z80_ix),y 			; remove next type.
000328r 3               
000328r 3  18           	clc	 			; next sprite.
000329r 3  A5 68        	lda z80_x
00032Br 3  69 11        	adc #TABSIZ 			; distance to next odd/even entry.
00032Dr 3  85 68        	sta z80_x
00032Fr 3  90 02        	bcc :+
000331r 3  E6 69        	inc z80_i
000333r 3               :
000333r 3  C6 rr        	dec sprcnt	 			; one less space in the table.
000335r 3  D0 E1        	bne nspr0
000337r 3  60           	rts
000338r 3               nspr1:
000338r 3  A9 FF        	lda #255
00033Ar 3  A0 00        	ldy #0
00033Cr 3  91 68        	sta (z80_ix),y 			; delete sprite.
00033Er 3               
00033Er 3  18           	clc	 			; point to next sprite.
00033Fr 3  A5 68        	lda z80_x
000341r 3  69 11        	adc #TABSIZ 			; distance to next odd/even entry.
000343r 3  85 68        	sta z80_x
000345r 3  90 02        	bcc :+
000347r 3  E6 69        	inc z80_i
000349r 3               :
000349r 3  C6 rr        	dec sprcnt	 			; one less to do.
00034Br 3  D0 01        	bne nspr2
00034Dr 3  60           	rts
00034Er 3               nspr2:
00034Er 3  A9 FF        	lda #255
000350r 3  A0 00        	ldy #0
000352r 3  91 68        	sta (z80_ix),y 			; delete sprite.
000354r 3  A0 05        	ldy #5
000356r 3  91 68        	sta (z80_ix),y 			; remove next type.
000358r 3               
000358r 3  18           	clc	 			; next sprite.
000359r 3  A5 68        	lda z80_x
00035Br 3  69 11        	adc #TABSIZ 			; distance to next odd/even entry.
00035Dr 3  85 68        	sta z80_x
00035Fr 3  90 02        	bcc :+
000361r 3  E6 69        	inc z80_i
000363r 3               :
000363r 3  C6 rr        	dec sprcnt	 			; one less space in table.
000365r 3  D0 E7        	bne nspr2
000367r 3  60           	rts
000368r 3               
000368r 3               ;----------------------------------------------------------
000368r 3               ; Two initialisation routines.
000368r 3               ; Initialise sprites - copy everything from list to table.
000368r 3               ;
000368r 3               ; global:	-
000368r 3               ; local:	x,y,ix
000368r 3               ; calls:	cpsp
000368r 3               ;----------------------------------------------------------
000368r 3               
000368r 3               ispr:
000368r 3  A9 0C        	lda #NUMSPR			; sprite slots in table.
00036Ar 3  85 rr        	sta sprcnt
00036Cr 3  A9 rr        	lda #<sprtab			; sprite table.
00036Er 3  85 68        	sta z80_x
000370r 3  A9 rr        	lda #>sprtab
000372r 3  85 69        	sta z80_i
000374r 3               ispr2:
000374r 3  A0 00        	ldy #0
000376r 3  B1 66        	lda (z80_hl),y 			; fetch byte.
000378r 3  C9 FF        	cmp #255 			; is it an end marker?
00037Ar 3  D0 01        	bne :+
00037Cr 3  60           	rts 				; yes, no more to do.
00037Dr 3               :
00037Dr 3               ispr1:
00037Dr 3  A0 00        	ldy #0
00037Fr 3  B1 68        	lda (z80_ix),y 			; fetch sprite type.
000381r 3  C9 FF        	cmp #255 			; is it enabled yet?
000383r 3  D0 08        	bne ispr4			; yes, try another slot.
000385r 3               
000385r 3  A0 05        	ldy #5
000387r 3  B1 68        	lda (z80_ix),y		 	; next type.
000389r 3  C9 FF        	cmp #255 			; is it enabled yet?
00038Br 3  F0 10        	beq ispr3 			; no, process this one.
00038Dr 3               ispr4:
00038Dr 3  18           	clc 				; next sprite.
00038Er 3  A5 68        	lda z80_x
000390r 3  69 11        	adc #TABSIZ		 	; distance to next odd/even entry.
000392r 3  85 68        	sta z80_x
000394r 3  90 02        	bcc :+
000396r 3  E6 69        	inc z80_i
000398r 3               :
000398r 3  C6 rr        	dec sprcnt
00039Ar 3  D0 E1        	bne ispr1 			; repeat for remaining sprites.
00039Cr 3  60           	rts  				; no more room in table.
00039Dr 3               ispr3:
00039Dr 3  20 rr rr     	jsr cpsp			; initialise a sprite.
0003A0r 3  C6 rr        	dec sprcnt			; one less space in the table.
0003A2r 3  D0 D0        	bne ispr2
0003A4r 3  60           	rts
0003A5r 3               
0003A5r 3               
0003A5r 3               ;-----------------------------------------------------------------------
0003A5r 3               ; Initialise sprites - but not player, we're keeping the old one.
0003A5r 3               ;
0003A5r 3               ; global:	-
0003A5r 3               ; local:	x,y,ix
0003A5r 3               ; calls:	cpsp
0003A5r 3               ;-----------------------------------------------------------------------
0003A5r 3               
0003A5r 3               kspr:
0003A5r 3  A2 0C        	ldx #NUMSPR			; sprite slots in table.
0003A7r 3  A9 rr        	lda #<sprtab 			; sprite table.
0003A9r 3  85 68        	sta z80_x
0003ABr 3  A9 rr        	lda #>sprtab
0003ADr 3  85 69        	sta z80_i
0003AFr 3               kspr2:
0003AFr 3  A0 00        	ldy #0
0003B1r 3  B1 66        	lda (z80_hl),y 			; fetch byte.
0003B3r 3  C9 FF        	cmp #255 			; is it an end marker?
0003B5r 3  D0 01        	bne :+
0003B7r 3  60           	rts 				; yes, no more to do.
0003B8r 3               :
0003B8r 3  C9 00        	cmp #0
0003BAr 3  D0 0E        	bne kspr1 			; no, add to table as normal.
0003BCr 3               
0003BCr 3  18           	clc 				; next sprite.
0003BDr 3  A5 66        	lda z80_l
0003BFr 3  69 04        	adc #NMESIZ		 	; distance to next odd/even entry.
0003C1r 3  85 66        	sta z80_l
0003C3r 3  90 02        	bcc :+
0003C5r 3  E6 67        	inc z80_h
0003C7r 3               :
0003C7r 3  4C rr rr     	jmp kspr2
0003CAr 3               kspr1:
0003CAr 3  A0 00        	ldy #0 				; fetch sprite type.
0003CCr 3  B1 68        	lda (z80_ix),y
0003CEr 3  C9 FF        	cmp #255 			; is it enabled yet?
0003D0r 3  D0 08        	bne kspr4 			; yes, try another slot.
0003D2r 3               
0003D2r 3  A0 05        	ldy #5 				; next type.
0003D4r 3  B1 68        	lda (z80_ix),y
0003D6r 3  C9 FF        	cmp #255 			; is it enabled yet?
0003D8r 3  F0 0F        	beq kspr3 			; no, process this one.
0003DAr 3               kspr4:
0003DAr 3  18           	clc 				; next sprite.
0003DBr 3  A5 68        	lda z80_x
0003DDr 3  69 11        	adc #TABSIZ		 	; distance to next odd/even entry.
0003DFr 3  85 68        	sta z80_x
0003E1r 3  90 02        	bcc :+
0003E3r 3  E6 69        	inc z80_i
0003E5r 3               :
0003E5r 3  CA           	dex	 			; repeat for remaining sprites.
0003E6r 3  D0 E2        	bne kspr1
0003E8r 3  60           	rts  				; no more room in table.
0003E9r 3               kspr3:
0003E9r 3  20 rr rr     	jsr cpsp 			; copy sprite to table.
0003ECr 3  CA           	dex	 			; one less space in the table.
0003EDr 3  D0 C0        	bne kspr2
0003EFr 3  60           	rts
0003F0r 3               
0003F0r 3               ;-------------------------------------------------------------
0003F0r 3               ; Line drawn, now work out next target address.
0003F0r 3               ;
0003F0r 3               ; Input:
0003F0r 3               ;  BP  = right mask
0003F0r 3               ;  CP  = left mask
0003F0r 3               ;  DEP = spriteaddress
0003F0r 3               ;  z80_hlp = screen address
0003F0r 3               ;-------------------------------------------------------------
0003F0r 3               
0003F0r 3               
0003F0r 3               ;-----------------------------------------------------------
0003F0r 3               ; Animates a sprite.
0003F0r 3               ;
0003F0r 3               ; Input:
0003F0r 3               ;  IX = sprite address
0003F0r 3               ;  HL = last sprite address
0003F0r 3               ;-----------------------------------------------------------
0003F0r 3               
0003F0r 3               animsp:
0003F0r 3  25 rr        	and frmno
0003F2r 3  F0 01        	beq :+
0003F4r 3  60           	rts
0003F5r 3               :
0003F5r 3  A0 06        	ldy #6
0003F7r 3  B1 68        	lda (z80_ix),y		; sprite image
0003F9r 3  20 rr rr     	jsr gfrm		; get frame data.
0003FCr 3               
0003FCr 3  E6 66        	inc z80_l		; point to frames.
0003FEr 3  D0 02        	bne :+
000400r 3  E6 67        	inc z80_h
000402r 3               :
000402r 3  A0 07        	ldy #7
000404r 3  B1 68        	lda (z80_ix),y		; sprite frame.
000406r 3  18           	clc
000407r 3  69 01        	adc #1			; next one along.
000409r 3  A0 00        	ldy #0
00040Br 3  D1 66        	cmp (z80_hl),y		; reached the last frame?
00040Dr 3  90 02        	bcc anims0		; no, not yet.
00040Fr 3  A9 00        	lda #0			; start at first frame.
000411r 3               anims0:
000411r 3  A0 07        	ldy #7
000413r 3  91 68        	sta (z80_ix),y		; new frame.
000415r 3  60           	rts
000416r 3               
000416r 3               ;--------------------------------------------------------------
000416r 3               ; Animate back
000416r 3               ;
000416r 3               ; Input:
000416r 3               ;  IX = sprite address
000416r 3               ;  HL = last sprite address
000416r 3               ;--------------------------------------------------------------
000416r 3               
000416r 3               animbk:
000416r 3  25 rr        	and frmno
000418r 3  F0 01        	beq :+
00041Ar 3  60           	rts
00041Br 3               :
00041Br 3  A0 06        	ldy #6
00041Dr 3  B1 68        	lda (z80_ix),y		; sprite image.
00041Fr 3  20 rr rr     	jsr gfrm		; get frame data.
000422r 3               
000422r 3  E6 66        	inc z80_l 		; point to frames.
000424r 3  D0 02        	bne :+
000426r 3  E6 67        	inc z80_h
000428r 3               :
000428r 3  A0 07        	ldy #7
00042Ar 3  B1 68        	lda (z80_ix),y 		; sprite frame.
00042Cr 3  F0 03        	beq :+
00042Er 3  4C rr rr     	jmp rtanb0 		; yes, start at end.
000431r 3               :
000431r 3  A0 00        	ldy #0
000433r 3  B1 66        	lda (z80_hl),y 		; last sprite.
000435r 3               rtanb0:
000435r 3  38           	sec
000436r 3  E9 01        	sbc #1			; next one along.
000438r 3  4C rr rr     	jmp anims0		; set new frame.
00043Br 3               
00043Br 3               ;--------------------------------------------------------------
00043Br 3               ; Check for collision with other sprite, strict enforcement.
00043Br 3               ;
00043Br 3               ; Input:
00043Br 3               ;  b		= sprite to test for
00043Br 3               ;  ix		= current sprite pointer
00043Br 3               ;
00043Br 3               ; global:	b
00043Br 3               ; local:	x,y,hl,de,skptr
00043Br 3               ; calls:	-
00043Br 3               ;--------------------------------------------------------------
00043Br 3               
00043Br 3               sktyp:
00043Br 3  A9 rr        	lda #<sprtab				; sprite table.
00043Dr 3  85 66        	sta z80_l
00043Fr 3  A9 rr        	lda #>sprtab
000441r 3  85 67        	sta z80_h
000443r 3               numsp2:
000443r 3  A9 0C        	lda #NUMSPR				; number of sprites.
000445r 3  85 rr        	sta sktptr
000447r 3               sktyp0:
000447r 3  A5 66        	lda z80_l 				; store pointer to sprite.
000449r 3  85 rr        	sta skptr
00044Br 3  A5 67        	lda z80_h
00044Dr 3  85 rr        	sta skptr+1
00044Fr 3               
00044Fr 3  A0 00        	ldy #0
000451r 3  B1 66        	lda (z80_hl),y 				; get sprite type.
000453r 3  C5 63        	cmp z80_b				; is it the type we seek?
000455r 3  F0 1D        	beq coltyp				; yes, we can use this one.
000457r 3               sktyp1:
000457r 3  18           	clc
000458r 3  A5 rr        	lda skptr				; retrieve sprite pointer.
00045Ar 3  69 11        	adc #TABSIZ				; size of each entry.
00045Cr 3  85 66        	sta z80_l
00045Er 3  A5 rr        	lda skptr+1
000460r 3  69 00        	adc #0
000462r 3  85 67        	sta z80_h
000464r 3  C6 rr        	dec sktptr				; one less iteration.
000466r 3  D0 DF        	bne sktyp0				; keep going until we find a slot.
000468r 3  A9 00        	lda #0					; default to ROM address - no sprite.
00046Ar 3  85 66        	sta z80_l
00046Cr 3  85 67        	sta z80_h
00046Er 3  85 rr        	sta skptr				; store pointer to sprite.
000470r 3  85 rr        	sta skptr+1
000472r 3               
000472r 3  18           	clc					; don't return with zero flag set.
000473r 3  60           	rts 					; didn't find one.
000474r 3               
000474r 3               ;skptr:	.word 0					; search pointer.
000474r 3               ;sktptr:	.byte 0
000474r 3               
000474r 3               coltyp:
000474r 3  A0 00        	ldy #0
000476r 3  B1 68        	lda (z80_ix),y				; current sprite type.
000478r 3  C5 63        	cmp z80_b				; seeking sprite of same type?
00047Ar 3  F0 3D        	beq colty1				; yes, need to check we're not detecting ourselves.
00047Cr 3               colty0:
00047Cr 3  A0 09        	ldy #9					; distance to x position in table.
00047Er 3  B1 66        	lda (z80_hl),y				; fetch x coordinate.
000480r 3  85 64        	sta z80_e
000482r 3  88           	dey
000483r 3  B1 66        	lda (z80_hl),y				; fetch y coordinate.
000485r 3  85 65        	sta z80_d
000487r 3               
000487r 3               ; Drop into collision detection.
000487r 3               
000487r 3               colc16:
000487r 3  A0 09        	ldy #9
000489r 3  B1 68        	lda (z80_ix),y			 	; x coord.
00048Br 3  38           	sec					; subtract x.
00048Cr 3  E5 64        	sbc z80_e
00048Er 3  B0 05        	bcs  colc1a 				; result is positive.
000490r 3  49 FF        	eor #$ff				; make negative positive.
000492r 3  18           	clc
000493r 3  69 01        	adc #1
000495r 3               colc1a:
000495r 3  C9 10        	cmp #COLDISTX				; within x range?
000497r 3  B0 BE        	bcs sktyp1				; no - they"ve missed.
000499r 3  85 62        	sta z80_c				; store difference.
00049Br 3               
00049Br 3  A0 08        	ldy #8
00049Dr 3  B1 68        	lda (z80_ix),y				; y coord.
00049Fr 3  38           	sec
0004A0r 3  E5 65        	sbc z80_d				; subtract y.
0004A2r 3  B0 05        	bcs colc1b				; result is positive.
0004A4r 3  49 FF        	eor #$ff				; make negative positive.
0004A6r 3  18           	clc
0004A7r 3  69 01        	adc #1
0004A9r 3               colc1b:
0004A9r 3  C9 10        	cmp #COLDISTY					; within y range?
0004ABr 3  B0 AA        	bcs sktyp1 				; no - they've missed.
0004ADr 3  18           	clc					; add x difference.
0004AEr 3  65 62        	adc z80_c
0004B0r 3  C9 1B        	cmp #COLDISTX+COLDISTY-5			; only 5 corner pixels touching?
0004B2r 3  B0 02        	bcs :+
0004B4r 3  38           	sec
0004B5r 3  60           	rts 					; carry set if there's a collision.
0004B6r 3               :
0004B6r 3  4C rr rr     	jmp sktyp1				; try next sprite in table.
0004B9r 3               colty1:
0004B9r 3  A5 68        	lda z80_x  				; compare the two.
0004BBr 3  C5 66        	cmp z80_l
0004BDr 3  D0 09        	bne end_col
0004BFr 3  A5 69        	lda z80_i
0004C1r 3  C5 67        	cmp z80_h
0004C3r 3  D0 03        	bne end_col
0004C5r 3  4C rr rr     	jmp sktyp1 				; addresses are identical.
0004C8r 3               end_col:
0004C8r 3  4C rr rr     	jmp colty0
0004CBr 3               
0004CBr 3               ;-----------------------------------------------------------
0004CBr 3               ; Display number, left aligned
0004CBr 3               ;
0004CBr 3               ; Input:
0004CBr 3               ;  a		= number
0004CBr 3               ;
0004CBr 3               ; global:	-
0004CBr 3               ; local:	a,y,bc,hl,displ0
0004CBr 3               ; calls:	num2ch,dmsg3
0004CBr 3               ;-----------------------------------------------------------
0004CBr 3               
0004CBr 3               disply:
0004CBr 3  85 61        	sta z80_a
0004CDr 3  A9 rr        	lda #<displ0				; display workspace.
0004CFr 3  85 62        	sta z80_c
0004D1r 3  A9 rr        	lda #>displ0
0004D3r 3  85 63        	sta z80_b
0004D5r 3  A5 61        	lda z80_a
0004D7r 3  20 rr rr     	jsr num2ch				; convert accumulator to string.
0004DAr 3               displ1:
0004DAr 3  C6 62        	dec z80_c				; back one character.
0004DCr 3  D0 02        	bne :+
0004DEr 3  C6 63        	dec z80_b
0004E0r 3               :
0004E0r 3  A0 00        	ldy #0
0004E2r 3  B1 62        	lda (z80_bc),y				; fetch digit.
0004E4r 3  09 80        	ora #128				; insert end marker.
0004E6r 3  91 62        	sta (z80_bc),y				; new value.
0004E8r 3               
0004E8r 3  A9 rr        	lda #<displ0				; display space.
0004EAr 3  85 66        	sta z80_l
0004ECr 3  A9 rr        	lda #>displ0
0004EEr 3  85 67        	sta z80_h
0004F0r 3  4C rr rr     	jmp dmsg3				; display the string.
0004F3r 3               
0004F3r 3  00 00 00 8D  displ0:	.byte 0,0,0,13+128
0004F7r 3               
0004F7r 3               ;----------------------------------------------------------------
0004F7r 3               ; Initialise screen.
0004F7r 3               ;
0004F7r 3               ; global:	roomtb,scno
0004F7r 3               ; local:	-
0004F7r 3               ; calls:	tstcs
0004F7r 3               ;----------------------------------------------------------------
0004F7r 3               
0004F7r 3               initsc:
0004F7r 3  AD rr rr     	lda roomtb 			; whereabouts in the map are we?
0004FAr 3  20 rr rr     	jsr tstsc 			; find displacement.
0004FDr 3  C9 FF        	cmp #255 			; is it valid?
0004FFr 3  F0 02        	beq init_end 			; no, it's rubbish.
000501r 3  85 rr        	sta scno			; store new room number.
000503r 3               init_end:
000503r 3  60           	rts
000504r 3               
000504r 3               ;----------------------------------------------------------------
000504r 3               ; Test screen.
000504r 3               ;
000504r 3               ; global:	-
000504r 3               ; local:	x
000504r 3               ; calls:	-
000504r 3               ;----------------------------------------------------------------
000504r 3               
000504r 3               tstsc:
000504r 3  85 rr        	sta tmproom
000506r 3  18           	clc
000507r 3  69 03        	adc #MAPWID 			; add width in case we"re negative.
000509r 3  AA           	tax 				; add displacement to map data.
00050Ar 3  BD rr rr     	lda mapdat-MAPWID,x 		; find room number there.
00050Dr 3  60           	rts
00050Er 3               
00050Er 3               ;tmproom:	.byte 0
00050Er 3               
00050Er 3               ;--------------------------
00050Er 3               ; Screen left.
00050Er 3               ;--------------------------
00050Er 3               
00050Er 3               scrl:
00050Er 3  AD rr rr     	lda roomtb 			; present room table pointer.
000511r 3  38           	sec
000512r 3  E9 01        	sbc #1				; room left.
000514r 3               scrl0:
000514r 3  20 rr rr     	jsr tstsc			; test screen.
000517r 3  C9 FF        	cmp #255			; is there a screen this way?
000519r 3  D0 01        	bne :+
00051Br 3  60           	rts				; no, return to loop.
00051Cr 3               :
00051Cr 3  A5 rr        	lda tmproom			; restore room displacement.
00051Er 3  8D rr rr     	sta roomtb			; new room table position.
000521r 3               scrl1:
000521r 3  20 rr rr     	jsr initsc 			; set new screen.
000524r 3  A9 02        	lda #2
000526r 3  85 rr        	sta restfl 			; set it.
000528r 3  60           	rts
000529r 3               scrr:
000529r 3  AD rr rr     	lda roomtb 			; room table pointer.
00052Cr 3  18           	clc
00052Dr 3  69 01        	adc #1				; room right.
00052Fr 3  4C rr rr     	jmp scrl0
000532r 3               scru:
000532r 3  AD rr rr     	lda roomtb 			; room table pointer.
000535r 3  38           	sec
000536r 3  E9 03        	sbc #MAPWID 			; room up.
000538r 3  4C rr rr     	jmp scrl0
00053Br 3               scrd:
00053Br 3  AD rr rr     	lda roomtb 			; room table pointer.
00053Er 3  18           	clc
00053Fr 3  69 03        	adc #MAPWID 			; room down.
000541r 3  4C rr rr     	jmp scrl0
000544r 3               
000544r 3               ;----------------------------------------------------------------------
000544r 3               ; Line drawn, now work out next target address.
000544r 3               ;----------------------------------------------------------------------
000544r 3               
000544r 3               nline:
000544r 3  18           	clc
000545r 3  A5 rr        	lda scraddr 		; get low byte of address.
000547r 3  69 18        	adc #24
000549r 3  85 rr        	sta scraddr 		; new low byte of address.
00054Br 3  90 02        	bcc :+
00054Dr 3  E6 rr        	inc scraddr+1 		; new high byte of address.
00054Fr 3               :
00054Fr 3  60           	rts
000550r 3               
000550r 3               ;-----------------------------------------
000550r 3               ; Get sprite address calculations.
000550r 3               ; gspran = new sprite, gsprad = old sprite.
000550r 3               ;
000550r 3               ; Input:
000550r 3               ;  IX = sprite address
000550r 3               ;-----------------------------------------
000550r 3               
000550r 3               gspran:
000550r 3  A0 08        	ldy #8
000552r 3  B1 68        	lda (z80_ix),y 		; new y coordinate.
000554r 3  85 rr        	sta dispy
000556r 3  A0 09        	ldy #9
000558r 3  B1 68        	lda (z80_ix),y 		; new x coordinate.
00055Ar 3  85 rr        	sta dispx
00055Cr 3  A0 06        	ldy #6
00055Er 3  B1 68        	lda (z80_ix),y 		; new sprite image.
000560r 3  20 rr rr     	jsr gfrm		; fetch start frame for this sprite.
000563r 3               
000563r 3  A0 00        	ldy #0
000565r 3  B1 66        	lda (z80_hl),y 		; frame in accumulator.
000567r 3  A0 07        	ldy #7
000569r 3  18           	clc
00056Ar 3  71 68        	adc (z80_ix),y 		; new add frame number.
00056Cr 3  4C rr rr     	jmp gspra0
00056Fr 3               
00056Fr 3               ; Address of each sprite type's routine.
00056Fr 3               
00056Fr 3  rr rr        evtyp0:	.word evnt00
000571r 3  rr rr        evtyp1:	.word evnt01
000573r 3  rr rr        evtyp2:	.word evnt02
000575r 3  rr rr        evtyp3:	.word evnt03
000577r 3  rr rr        evtyp4:	.word evnt04
000579r 3  rr rr        evtyp5:	.word evnt05
00057Br 3  rr rr        evtyp6:	.word evnt06
00057Dr 3  rr rr        evtyp7:	.word evnt07
00057Fr 3  rr rr        evtyp8:	.word evnt08
000581r 3               
000581r 3               ;--------------------------------------------------------------
000581r 3               ; Display sprites.
000581r 3               ;
000581r 3               ; Input:
000581r 3               ;  IX = sprite table
000581r 3               ;--------------------------------------------------------------
000581r 3               
000581r 3               dspr:
000581r 3  A9 06        	lda #(NUMSPR/2)		; number of sprites to display.
000583r 3  85 rr        	sta sprcnt
000585r 3               dspr0:
000585r 3  A0 00        	ldy #0
000587r 3  B1 68        	lda (z80_ix),y 		; get sprite type.
000589r 3  C9 FF        	cmp #255 		; is it enabled?
00058Br 3  D0 42        	bne dspr1 		; yes, it needs deleting.
00058Dr 3               dspr5:
00058Dr 3  A0 05        	ldy #5
00058Fr 3  B1 68        	lda (z80_ix),y 		; new type.
000591r 3  C9 FF        	cmp #255		; is it enabled?
000593r 3  D0 77        	bne dspr3 		; yes, it needs drawing.
000595r 3               dspr2:
000595r 3  A0 05        	ldy #5
000597r 3  B1 68        	lda (z80_ix),y 		; copy new type.
000599r 3  A0 00        	ldy #0
00059Br 3  91 68        	sta (z80_ix),y
00059Dr 3  A0 06        	ldy #6
00059Fr 3  B1 68        	lda (z80_ix),y 		; copy new image number.
0005A1r 3  A0 01        	ldy #1
0005A3r 3  91 68        	sta (z80_ix),y
0005A5r 3  A0 07        	ldy #7
0005A7r 3  B1 68        	lda (z80_ix),y 		; copy new frame.
0005A9r 3  A0 02        	ldy #2
0005ABr 3  91 68        	sta (z80_ix),y
0005ADr 3  A0 08        	ldy #8
0005AFr 3  B1 68        	lda (z80_ix),y 		; copy new y.
0005B1r 3  A0 03        	ldy #3
0005B3r 3  91 68        	sta (z80_ix),y
0005B5r 3  A0 09        	ldy #9
0005B7r 3  B1 68        	lda (z80_ix),y 		; copy new x.
0005B9r 3  A0 04        	ldy #4
0005BBr 3  91 68        	sta (z80_ix),y
0005BDr 3               
0005BDr 3  18           	clc
0005BEr 3  A5 68        	lda z80_x
0005C0r 3  69 22        	adc #(TABSIZ*2)		; distance to next odd/even entry.
0005C2r 3  85 68        	sta z80_x
0005C4r 3  A5 69        	lda z80_i
0005C6r 3  69 00        	adc #0
0005C8r 3  85 69        	sta z80_i 		; next sprite.
0005CAr 3  C6 rr        	dec sprcnt
0005CCr 3  D0 B7        	bne dspr0		; repeat for remaining sprites.
0005CEr 3  60           	rts
0005CFr 3               dspr1:
0005CFr 3  A0 05        	ldy #5
0005D1r 3  B1 68        	lda (z80_ix),y 		; type of new sprite.
0005D3r 3  C9 FF        	cmp #255		; is this enabled?
0005D5r 3  D0 06        	bne dspr4 		; yes, display both.
0005D7r 3               dspr6:
0005D7r 3  20 rr rr     	jsr sspria 		; show single sprite.
0005DAr 3  4C rr rr     	jmp dspr2
0005DDr 3               
0005DDr 3               ; Displaying two sprites.  Don't bother redrawing if nothing has changed.
0005DDr 3               
0005DDr 3               dspr4:
0005DDr 3  A0 04        	ldy #4
0005DFr 3  B1 68        	lda (z80_ix),y		; old x.
0005E1r 3  A0 09        	ldy #9
0005E3r 3  D1 68        	cmp (z80_ix),y 		; compare with new value.
0005E5r 3  D0 1F        	bne dspr7 		; they differ, need to redraw.
0005E7r 3               
0005E7r 3  A0 03        	ldy #3
0005E9r 3  B1 68        	lda (z80_ix),y		; old y.
0005EBr 3  A0 08        	ldy #8
0005EDr 3  D1 68        	cmp (z80_ix),y 		; compare against new value.
0005EFr 3  D0 15        	bne dspr7		; they differ, need to redraw.
0005F1r 3               
0005F1r 3  A0 02        	ldy #2
0005F3r 3  B1 68        	lda (z80_ix),y 		; old frame.
0005F5r 3  A0 07        	ldy #7
0005F7r 3  D1 68        	cmp (z80_ix),y 		; compare against new value.
0005F9r 3  4C rr rr     	jmp dspr7 		; they differ, need to redraw.
0005FCr 3               
0005FCr 3  A0 01        	ldy #1
0005FEr 3  B1 68        	lda (z80_ix),y 		; old image.
000600r 3  A0 06        	ldy #6
000602r 3  D1 68        	cmp (z80_ix),y 		; compare against new value.
000604r 3  F0 8F        	beq dspr2		; everything is the same, don't redraw.
000606r 3               dspr7:
000606r 3  20 rr rr     	jsr sspric 		; delete old sprite, draw new one simultaneously.
000609r 3  4C rr rr     	jmp dspr2
00060Cr 3               dspr3:
00060Cr 3  20 rr rr     	jsr ssprib 		; show single sprite.
00060Fr 3  4C rr rr     	jmp dspr2
000612r 3               
000612r 3               ;sprcnt:	.byte 0
000612r 3               
000612r 3               ;-----------------------------------------------------------
000612r 3               ; Bubble sort.
000612r 3               ;-----------------------------------------------------------
000612r 3               
000612r 3               bsort:
000612r 3  A9 0B        	lda #NUMSPR - 1		; sprites to swap.
000614r 3  85 rr        	sta qscnt
000616r 3               
000616r 3  A9 rr        	lda #<sprtab 		; sprite table.
000618r 3  85 68        	sta z80_x
00061Ar 3  A9 rr        	lda #>sprtab
00061Cr 3  85 69        	sta z80_i
00061Er 3               bsort0:
00061Er 3  A0 00        	ldy #0
000620r 3  B1 68        	lda (z80_ix),y 		; first sprite type.
000622r 3  C9 FF        	cmp #255 		; is it switched off?
000624r 3  F0 30        	beq swemp		; yes, may need to switch another in here.
000626r 3               
000626r 3  A0 11        	ldy #TABSIZ
000628r 3  B1 68        	lda (z80_ix),y 		; check next slot exists.
00062Ar 3  C9 FF        	cmp #255 		; is it enabled?
00062Cr 3  F0 0A        	beq bsort2 		; no, nothing to swap.
00062Er 3               
00062Er 3  A0 14        	ldy #TABSIZ+3
000630r 3  B1 68        	lda (z80_ix),y 		; fetch next sprite's coordinate.
000632r 3  A0 03        	ldy #3
000634r 3  D1 68        	cmp (z80_ix),y 		; compare with this x coordinate.
000636r 3  90 10        	bcc bsort1		; next sprite is higher - may need to switch.
000638r 3               bsort2:
000638r 3  18           	clc
000639r 3  A5 68        	lda z80_x
00063Br 3  69 11        	adc #TABSIZ 		; distance to next odd/even entry.
00063Dr 3  85 68        	sta z80_x
00063Fr 3  90 02        	bcc :+
000641r 3  E6 69        	inc z80_i
000643r 3               :
000643r 3  C6 rr        	dec qscnt
000645r 3  D0 D7        	bne bsort0		; repeat for remaining sprites.
000647r 3  60           	rts
000648r 3               
000648r 3               ;qscnt:	.byte 0
000648r 3               
000648r 3               bsort1:
000648r 3  A0 11        	ldy #TABSIZ
00064Ar 3  B1 68        	lda (z80_ix),y		; sprite on/off flag.
00064Cr 3  C9 FF        	cmp #255		; is it enabled?
00064Er 3  F0 E8        	beq bsort2		; no, nothing to swap.
000650r 3  20 rr rr     	jsr swspr		; swap positions.
000653r 3  4C rr rr     	jmp bsort2
000656r 3               swemp:
000656r 3  A0 11        	ldy #TABSIZ
000658r 3  B1 68        	lda (z80_ix),y		; next table entry.
00065Ar 3  C9 FF        	cmp #255		; is that one on?
00065Cr 3  F0 DA        	beq bsort2		; no, nothing to swap.
00065Er 3  20 rr rr     	jsr swspr		; swap positions.
000661r 3  4C rr rr     	jmp bsort2
000664r 3               
000664r 3               ; Swap sprites.
000664r 3               
000664r 3               swspr:
000664r 3  A5 68        	lda z80_x		; table address
000666r 3  85 64        	sta z80_e		; copy to de pair.
000668r 3  85 66        	sta z80_l		; copy to hl pair.
00066Ar 3  A5 69        	lda z80_i
00066Cr 3  85 67        	sta z80_h
00066Er 3  85 65        	sta z80_d
000670r 3               
000670r 3  18           	clc
000671r 3  A5 66        	lda z80_l
000673r 3  69 11        	adc #TABSIZ		; distance to second entry.
000675r 3  85 66        	sta z80_l
000677r 3  90 02        	bcc :+
000679r 3  E6 67        	inc z80_h
00067Br 3               :
00067Br 3  A9 11        	lda #TABSIZ		; bytes to swap.
00067Dr 3  85 63        	sta z80_b
00067Fr 3  A0 00        	ldy #0
000681r 3               swspr0:
000681r 3  B1 66        	lda (z80_hl),y		; fetch second byte.
000683r 3  48           	pha
000684r 3  B1 64        	lda (z80_de),y 		; fetch first byte.
000686r 3  91 66        	sta (z80_hl),y 		; copy to second.
000688r 3  68           	pla
000689r 3  91 64        	sta (z80_de),y 		; copy to first sprite entry.
00068Br 3               
00068Br 3  E6 64        	inc z80_e 		; next byte.
00068Dr 3  D0 02        	bne :+
00068Fr 3  E6 65        	inc z80_d
000691r 3               :
000691r 3  E6 66        	inc z80_l 		; next byte.
000693r 3  D0 02        	bne :+
000695r 3  E6 67        	inc z80_h
000697r 3               :
000697r 3  C6 63        	dec z80_b
000699r 3  D0 E6        	bne swspr0 		; swap all bytes in table entry.
00069Br 3  60           	rts
00069Cr 3               
00069Cr 3               ;--------------------------------------------------------------
00069Cr 3               ; Get messagenr x in hl
00069Cr 3               ;
00069Cr 3               ; Input:
00069Cr 3               ;  HL = pointer to message list
00069Cr 3               ;  X  = message number.
00069Cr 3               ;--------------------------------------------------------------
00069Cr 3               
00069Cr 3               getwrd:
00069Cr 3  E0 00        	cpx #0
00069Er 3  D0 01        	bne:+ 			; first word in list?
0006A0r 3  60           	rts 			; yep, don't search.
0006A1r 3               :
0006A1r 3  A0 00        	ldy #0
0006A3r 3               getwd0:
0006A3r 3  B1 66        	lda (z80_hl),y
0006A5r 3  48           	pha
0006A6r 3  E6 66        	inc z80_l
0006A8r 3  D0 02        	bne :+
0006AAr 3  E6 67        	inc z80_h
0006ACr 3               :
0006ACr 3  68           	pla
0006ADr 3  C9 80        	cmp #128		; found end?
0006AFr 3  30 F2        	bmi getwd0		; no, carry on.
0006B1r 3  CA           	dex			; until we have right number.
0006B2r 3  D0 EF        	bne getwd0
0006B4r 3  60           	rts
0006B5r 3               
0006B5r 3               ;-------------------------------------------------
0006B5r 3               ; Get next print column position.
0006B5r 3               ;-------------------------------------------------
0006B5r 3               
0006B5r 3               nexpos:
0006B5r 3  E6 rr        	inc dispx		; move along one position.
0006B7r 3  A5 rr        	lda dispx 		; get coordinate.
0006B9r 3               ;	and #31
0006B9r 3  60           	rts 			; return with status in zero flag.
0006BAr 3               
0006BAr 3               ;-------------------------------------------------
0006BAr 3               ; Get next print line position.
0006BAr 3               ;-------------------------------------------------
0006BAr 3               
0006BAr 3               nexlin:
0006BAr 3  E6 rr        	inc dispy 		; newline.
0006BCr 3  A5 rr        	lda dispy		; vertical position.
0006BEr 3  C9 18        	cmp #24			; past screen edge?
0006C0r 3  B0 01        	bcs :+
0006C2r 3  60           	rts			; no, still okay.
0006C3r 3               :
0006C3r 3  A9 00        	lda #0			; restart at top.
0006C5r 3  85 rr        	sta dispy
0006C7r 3  60           	rts
0006C8r 3               
0006C8r 3               ;----------------------------------------------------
0006C8r 3               ; Delay routine 1/50 sec
0006C8r 3               ;
0006C8r 3               ; Wait 1/60 sec = 16666 usec
0006C8r 3               ; Wait 208 x 16 =  3328 usec
0006C8r 3               ;                 19994 usec
0006C8r 3               ; rts           =     6 usec
0006C8r 3               ; Total         = 20000 usec
0006C8r 3               ;----------------------------------------------------
0006C8r 3               
0006C8r 3               delay:
0006C8r 3  85 rr        	sta xtmp
0006CAr 3               del_loop:
0006CAr 3  20 66 FE     	jsr SCRSYNC		; wait for flyback
0006CDr 3               
0006CDr 3  A0 D0        	ldy #208		; wait 208 x 16 = 3328 usec
0006CFr 3               delay1:
0006CFr 3  61 80        	adc ($80,x)		;	 6 usec
0006D1r 3  61 80        	adc ($80,x)		;	 6 usec
0006D3r 3  88           	dey			;	 2 usec
0006D4r 3  D0 F9        	bne delay1		;	 2 usec
0006D6r 3  EA           	nop			; 2 usec
0006D7r 3  EA           	nop			; 2 usec
0006D8r 3               				; tot: 20000 usec
0006D8r 3  C6 rr        	dec xtmp
0006DAr 3  D0 EE        	bne del_loop
0006DCr 3  60           	rts
0006DDr 3               
0006DDr 3               ; Definition of variables
0006DDr 3               ; Make sure pointers are arranged in the same order as the data itself.
0006DDr 3               
0006DDr 3               ;msgptr:		.word msgdat	; messages
0006DDr 3               ;blkptr:		.word chgfx	; block graphics.
0006DDr 3               ;proptr:		.word bprop	; address of char properties.
0006DDr 3               ;sptptr:		.word sprgfx	; sprite graphics
0006DDr 3               ;frmptr:		.word frmlst	; sprite frames.
0006DDr 3               ;scrptr:		.word scdat	; address of screens.
0006DDr 3               ;nmeptr:		.word nmedat	; enemy start positions.
0006DDr 3               ;objptr:		.word objdta	; object graphics
0006DDr 3               
0006DDr 3  00 55 AA FF  txtcol:		.byte green,yellow,blue,red
0006E1r 3               
0006E1r 3               ; Don't change the order of these four.
0006E1r 3               ; Menu routine relies on winlft following wintop.
0006E1r 3               
0006E1r 3  01           wintop:		.byte WINDOWTOP	; top of window.
0006E2r 3  01           winlft:		.byte WINDOWLFT	; left edge.
0006E3r 3  16           winhgt:		.byte WINDOWHGT	; window height.
0006E4r 3  16           winwid:		.byte WINDOWWID	; window width.
0006E5r 3  01           numob:		.byte NUMOBJ	; number of objects in game.
0006E6r 3               
0006E6r 3  00           tmpscr:		.byte 0
0006E7r 3  00           sndtyp:		.byte 0
0006E8r 3  00           colpatt:	.byte 0
0006E9r 3               
0006E9r 3               ;----------------------------------------------------
0006E9r 3               ; Wait for keypress.
0006E9r 3               ;----------------------------------------------------
0006E9r 3               
0006E9r 3               prskey:
0006E9r 3  98           	tya
0006EAr 3  48           	pha
0006EBr 3               prsloop:
0006EBr 3  20 rr rr     	jsr vsync
0006EEr 3  20 rr rr     	jsr READKEY
0006F1r 3  C0 FF        	cpy #255
0006F3r 3  F0 F6        	beq prsloop		; wait until key pressed
0006F5r 3  20 rr rr     	jsr joykey
0006F8r 3  68           	pla
0006F9r 3  A8           	tay
0006FAr 3  60           	rts
0006FBr 3               
0006FBr 3               ;----------------------------------------------------
0006FBr 3               ; Process sprites.
0006FBr 3               ;----------------------------------------------------
0006FBr 3               
0006FBr 3               pspr:
0006FBr 3  60           	rts
0006FCr 3               
0006FCr 3  A9 0C        	lda #NUMSPR		; sprites to process.
0006FEr 3  85 rr        	sta sprptr
000700r 3               
000700r 3  A9 rr        	lda #<sprtab 		; sprite table.
000702r 3  85 68        	sta z80_x
000704r 3  A9 rr        	lda #>sprtab
000706r 3  85 69        	sta z80_i
000708r 3               pspr1:
000708r 3  A0 00        	ldy #0
00070Ar 3  B1 68        	lda (z80_ix),y		; fetch sprite type.
00070Cr 3  C9 09        	cmp #9 			; within range of sprite types?
00070Er 3  B0 03        	bcs :+
000710r 3  20 rr rr     	jsr pspr2 		; yes, process this one.
000713r 3               :
000713r 3  18           	clc
000714r 3  A5 68        	lda z80_x
000716r 3  69 11        	adc #TABSIZ 		; distance to next odd/even entry.
000718r 3  85 68        	sta z80_x
00071Ar 3  90 02        	bcc :+
00071Cr 3  E6 69        	inc z80_i		; next sprite.
00071Er 3               :
00071Er 3  C6 rr        	dec sprptr 		; repeat for remaining sprites.
000720r 3  D0 E6        	bne pspr1
000722r 3  60           	rts
000723r 3               
000723r 3               ;sprptr:	.byte 0
000723r 3               
000723r 3               pspr2:
000723r 3  A5 68        	lda z80_x 		; store original sprite pointer.
000725r 3  85 rr        	sta ogptr
000727r 3  A5 69        	lda z80_i
000729r 3  85 rr        	sta ogptr+1
00072Br 3  20 rr rr     	jsr pspr3		; do the routine.
00072Er 3               rtorg:
00072Er 3  A5 rr        	lda ogptr 		; restore original pointer to sprite.
000730r 3  85 68        	sta z80_x
000732r 3  A5 rr        	lda ogptr+1
000734r 3  85 69        	sta z80_i
000736r 3               rtorg0:
000736r 3  60           	rts
000737r 3               
000737r 3               pspr3:
000737r 3  A9 rr        	lda #<evtyp0		; sprite type events list.
000739r 3  85 66        	sta z80_l
00073Br 3  A9 rr        	lda #>evtyp0
00073Dr 3  85 67        	sta z80_h
00073Fr 3               pspr4:
00073Fr 3  B1 68        	lda (z80_ix),y
000741r 3  0A           	asl a			; double accumulator.
000742r 3  18           	clc
000743r 3  65 66        	adc z80_l
000745r 3  85 66        	sta z80_l
000747r 3  90 02        	bcc :+
000749r 3  E6 67        	inc z80_h
00074Br 3               :
00074Br 3  B1 66        	lda (z80_hl),y
00074Dr 3  85 64        	sta z80_e 		; copy to de.
00074Fr 3  48           	pha
000750r 3               
000750r 3  E6 66        	inc z80_l 		; next byte of address.
000752r 3  D0 02        	bne :+
000754r 3  E6 67        	inc z80_h
000756r 3               :
000756r 3  B1 66        	lda (z80_hl),y 		; address high.
000758r 3  85 65        	sta z80_d
00075Ar 3               
00075Ar 3  48           	pha	 		; swap address into hl.
00075Br 3  A5 67        	lda z80_h
00075Dr 3  85 65        	sta z80_d
00075Fr 3  68           	pla
000760r 3  85 67        	sta z80_h
000762r 3  68           	pla
000763r 3  85 66        	sta z80_l
000765r 3  A5 66        	lda z80_l
000767r 3  85 64        	sta z80_e
000769r 3               
000769r 3  6C 66 00     	jmp (z80_hl) 		; go there.
00076Cr 3               
00076Cr 3               ; Variables start here.
00076Cr 3               ; Pixel versions of wintop, winlft, winhgt, winwid.
00076Cr 3               
00076Cr 3  08           wntopx:		.byte (8 * WINDOWTOP)
00076Dr 3  08           wnlftx:		.byte (8 * WINDOWLFT)
00076Er 3  A8           wnbotx:		.byte ((WINDOWTOP * 8) + (WINDOWHGT * 8) - 16)
00076Fr 3  A6           wnrgtx:		.byte ((WINDOWLFT * 8) + (WINDOWWID * 8) - 16)-2
000770r 3               
000770r 3               ; Assorted game routines which can go in contended memory.
000770r 3               
000770r 3               ;--------------------------------------------------------------
000770r 3               ; Entry for inventory called by the INV command
000770r 3               ;
000770r 3               ; Input:
000770r 3               ;  X   = message nr with objects seperated with ,
000770r 3               ;
000770r 3               ; Output:
000770r 3               ;  OPT = selected objectnr of INV menu
000770r 3               ;--------------------------------------------------------------
000770r 3               
000770r 3               .if mflag
000770r 3               minve:
000770r 3               .if xflag
000770r 3               	lda #WINDOWHGT
000770r 3               	asl a
000770r 3               	sta winhgt
000770r 3               	lda #WINDOWWID
000770r 3               	asl a
000770r 3               	sta winwid
000770r 3               .endif
000770r 3               .if gflag
000770r 3               	lda #$ff		; blue frontcolour
000770r 3               	sta andeor
000770r 3               	lda #$aa		; yellow backcoloour
000770r 3               	sta andeor+1
000770r 3               .endif
000770r 3               	lda #<(invdis)		; routine address.
000770r 3               	sta mod0+1		; set up menu routine.
000770r 3               	sta mod2+1		; set up count routine.
000770r 3               	lda #>(invdis)
000770r 3               	sta mod0+2
000770r 3               	sta mod2+2
000770r 3               	lda #<(fopt)		; find option from available objects.
000770r 3               	sta mod1+1		; set up routine.
000770r 3               	lda #>(fopt)
000770r 3               	sta mod1+1+1
000770r 3               	jmp dbox		; do menu routine.
000770r 3               
000770r 3               ;--------------------------------------------------------------
000770r 3               ; Entry for menu called by the MENU command
000770r 3               ;
000770r 3               ; Input:
000770r 3               ;  X   = message nr with menu items seperated with ,
000770r 3               ;
000770r 3               ; Output:
000770r 3               ;  OPT = selected line nr of MENU menu
000770r 3               ;--------------------------------------------------------------
000770r 3               
000770r 3               mmenu:
000770r 3               	lda #<(always)		; routine address.
000770r 3               	sta mod0+1		; set up routine.
000770r 3               	sta mod2+1		; set up count routine.
000770r 3               	lda #>(always)
000770r 3               	sta mod0+2
000770r 3               	sta mod2+2
000770r 3               
000770r 3               	lda #<(fstd)		; standard option selection.
000770r 3               	sta mod1+1		; set up routine.
000770r 3               	lda #>(fstd)
000770r 3               	sta mod1+2
000770r 3               
000770r 3               ; Drop through into box routine.
000770r 3               
000770r 3               ;--------------------------------------------------------------
000770r 3               ; Work out size of box for message or menu.
000770r 3               ;--------------------------------------------------------------
000770r 3               
000770r 3               dbox:
000770r 3               	lda #<(msgdat)		; pointer to messages.
000770r 3               	sta z80_l
000770r 3               	lda #>(msgdat)
000770r 3               	sta z80_h
000770r 3               
000770r 3               	jsr getwrd		; get message number.
000770r 3               
000770r 3               	lda z80_h		; store pointer to message.
000770r 3               	sta TmpAddr
000770r 3               	lda z80_l
000770r 3               	sta TmpAddr+1
000770r 3               
000770r 3               	lda #1			; height.
000770r 3               	sta z80_d
000770r 3               	lda #0			; start at object zero.
000770r 3               	sta combyt		; store number of object in combyt.
000770r 3               	sta z80_e		; maximum width.
000770r 3               dbox5:
000770r 3               	lda #0			; this line"s width.
000770r 3               	sta z80_b
000770r 3               mod2:
000770r 3               	jsr always		; item in player"s possession?
000770r 3               	cmp #255
000770r 3               	bne dbox6		; not in inventory, skip this line.
000770r 3               	inc z80_d		; add to tally.
000770r 3               dbox6:
000770r 3               	ldy #0			; get character.
000770r 3               	lda (z80_hl),y
000770r 3               	sta z80_a
000770r 3               	inc z80_l		; next character.
000770r 3               	bne :+
000770r 3               	inc z80_h
000770r 3               :
000770r 3               	lda z80_a		; reached end of line?
000770r 3               	cmp #','
000770r 3               	beq dbox3		; yes.
000770r 3               	cmp #13
000770r 3               	beq dbox3		; yes.
000770r 3               	inc z80_b		; add to this line"s width.
000770r 3               	lda z80_a
000770r 3               	bmi dbox4		; end of message? yes, end count.
000770r 3               	jmp dbox6		; repeat until we find the end.
000770r 3               dbox3:
000770r 3               	lda z80_e		; maximum line width.
000770r 3               	cmp z80_b		; have we exceeded longest so far?
000770r 3               	bpl dbox5		; no, carry on looking.
000770r 3               	lda z80_b		; make this the widest so far.
000770r 3               	sta z80_e
000770r 3               	jmp dbox5		; keep looking.
000770r 3               dbox4:
000770r 3               	lda z80_e		; maximum line width.
000770r 3               	cmp z80_b		; have we exceeded longest so far?
000770r 3               	bpl dbox8		; no, carry on looking.
000770r 3               	lda z80_b		; final line is the longest so far.
000770r 3               	sta z80_e
000770r 3               dbox8:
000770r 3               	dec z80_d		; decrement items found.
000770r 3               	bne :+			; total was zero.
000770r 3               	lda #255
000770r 3               	sta varopt
000770r 3               	jmp dbox15
000770r 3               :
000770r 3               	lda z80_e		; longest line.
000770r 3               	bne :+			; was it zero?
000770r 3               	jmp dbox15		; total was zero.
000770r 3               :
000770r 3               	sta bwid		; set up size.
000770r 3               	lda z80_d
000770r 3               	sta blen
000770r 3               
000770r 3               ;--------------------------------------------------------------
000770r 3               ; That's set up our box size.
000770r 3               ;--------------------------------------------------------------
000770r 3               
000770r 3               	lda winhgt		; window height in characters.
000770r 3               	sec
000770r 3               	sbc z80_d		; subtract height of box.
000770r 3               	lsr a			; divide by 2.
000770r 3               	clc
000770r 3               	adc wintop		; add top edge of window.
000770r 3               	sta btop		; set up box top.
000770r 3               
000770r 3               	lda winwid		; window width in characters.
000770r 3               	sec
000770r 3               	sbc z80_e		; subtract box width.
000770r 3               	lsr a			; divide by 2.
000770r 3               	clc
000770r 3               	adc winlft		; add left edge of window.
000770r 3               	sta blft		; box left.
000770r 3               
000770r 3               	lda #<(font-256)		; font.
000770r 3               	sta grbase		; set up for text display.
000770r 3               	lda #>(font-256)
000770r 3               	sta grbase+1
000770r 3               
000770r 3               	lda TmpAddr+1		; restore message pointer.
000770r 3               	sta z80_l
000770r 3               	lda TmpAddr
000770r 3               	sta z80_h
000770r 3               
000770r 3               	lda btop		; box top.
000770r 3               	sta dispy		; set display coordinate.
000770r 3               	lda #0			; start at object zero.
000770r 3               	sta combyt		; store number of object in combyt.
000770r 3               dbox2:
000770r 3               	lda combyt		; get object number.
000770r 3               	sta z80_a
000770r 3               mod0:
000770r 3               	jsr always		; check inventory for display.
000770r 3               	cmp #255
000770r 3               	beq :+
000770r 3               	jmp dbox13		; not in inventory, skip this line.
000770r 3               :
000770r 3               	lda blft		; box left.
000770r 3               	sta dispx		; set left display position.
000770r 3               	lda bwid		; box width.
000770r 3               	sta z80_b		; store width.
000770r 3               dbox0:
000770r 3               	ldy #0
000770r 3               	lda (z80_hl),y		; get character.
000770r 3               	cmp #','		; end of line?
000770r 3               	beq dbox1		; yes, next one.
000770r 3               	cmp #13			; end of line?
000770r 3               	beq dbox1		; yes, next one.
000770r 3               
000770r 3               	cmp #141			; end of line?
000770r 3               	bne :+
000770r 3               	dec bwid
000770r 3               	jmp dbox7		; yes, next one.
000770r 3               :
000770r 3               	dec z80_b		; one less to display.
000770r 3               	and #127		; remove terminator.
000770r 3               
000770r 3               	jsr pchr		; display on screen.
000770r 3               
000770r 3               	ldy #0
000770r 3               	lda (z80_hl),y		; get character.
000770r 3               	sta z80_a
000770r 3               	inc z80_l		; next character.
000770r 3               	bne :+
000770r 3               	inc z80_h
000770r 3               :
000770r 3               	lda z80_a
000770r 3               	cmp #128		; end of message?
000770r 3               	bmi :+
000770r 3               	jmp dbox7		; yes, job done.
000770r 3               :
000770r 3               	lda z80_b		; chars remaining.
000770r 3               	beq :+			; are any left?
000770r 3               	jmp dbox0		; yes, continue.
000770r 3               :
000770r 3               ;---------------------------------------------------
000770r 3               ; Reached limit of characters per line.
000770r 3               ;---------------------------------------------------
000770r 3               
000770r 3               dbox9:
000770r 3               	ldy #0
000770r 3               	lda (z80_hl),y		; get character.
000770r 3               	inc z80_l		; next one.
000770r 3               	bne :+
000770r 3               	inc z80_h
000770r 3               :
000770r 3               	cmp #','		; another line?
000770r 3               	beq dbox10		; yes, do next line.
000770r 3               	cmp #13			; another line?
000770r 3               	beq dbox10		; yes, do next line.
000770r 3               	cmp #128		; end of message?
000770r 3               	bcs :+
000770r 3               	jmp dbox11		; yes, finish message.
000770r 3               :
000770r 3               	jmp dbox9
000770r 3               
000770r 3               ;---------------------------------------------------
000770r 3               ; Fill box to end of line.
000770r 3               ;---------------------------------------------------
000770r 3               
000770r 3               dboxf:
000770r 3               	lda #32			; space character.
000770r 3               	jsr pchr		; display character.
000770r 3               	dec z80_b
000770r 3               	beq :+
000770r 3               	jmp dboxf		; repeat for remaining chars on line.
000770r 3               :
000770r 3               	rts
000770r 3               dbox1:
000770r 3               	inc z80_l		; skip character.
000770r 3               	bne :+
000770r 3               	inc z80_h
000770r 3               :
000770r 3               	jsr dboxf		; fill box out to right side.
000770r 3               dbox10:
000770r 3               	inc dispy		; y coordinate down a line next position.
000770r 3               	jmp dbox2		; next line.
000770r 3               dbox7:
000770r 3               	lda z80_b		; chars remaining.
000770r 3               	bne :+			; are any left?
000770r 3               	jmp dbox11		; no, nothing to draw.
000770r 3               :
000770r 3               	jsr dboxf		; fill message to line.
000770r 3               
000770r 3               ;------------------------------------------------------
000770r 3               ; Drawn the box menu, now select option.
000770r 3               ;------------------------------------------------------
000770r 3               
000770r 3               dbox11:
000770r 3               	lda btop		; box top.
000770r 3               	sta dispy		; set bar position.
000770r 3               dbox14:
000770r 3               	jsr joykey		; get controls.
000770r 3               	cmp #$7f		; anything pressed?
000770r 3               	bne dbox14		; yes, debounce it.
000770r 3               	jsr dbar		; draw bar.
000770r 3               dbox12:
000770r 3               	jsr joykey		; get controls.
000770r 3               	cmp #$7f		; anything pressed?
000770r 3               	beq dbox12		; no, nothing.
000770r 3               	and #16			; fire button pressed?
000770r 3               	bne :+
000770r 3               mod1:
000770r 3               	jmp fstd		; yes, job done.
000770r 3               :
000770r 3               	jsr dbar		; delete bar.
000770r 3               
000770r 3               	lda joyval		; joystick reading.
000770r 3               	and #8			; going up?
000770r 3               	beq dboxu		; yes, go up.
000770r 3               
000770r 3               	ldx dispy		; vertical position of bar.
000770r 3               	inx			; look down.
000770r 3               	txa
000770r 3               	sec
000770r 3               	sbc btop		; find distance from top.
000770r 3               	cmp blen		; top of box.
000770r 3               	bne :+
000770r 3               	jmp dbox14		; yes, go no further.
000770r 3               :
000770r 3               	inc dispy		; move bar.
000770r 3               	jmp dbox14		; continue.
000770r 3               dboxu:
000770r 3               	lda dispy		; vertical position of bar.
000770r 3               	cmp btop		; are we at the top?
000770r 3               	bne :+
000770r 3               	jmp dbox14		; yes, go no further.
000770r 3               :
000770r 3               	dec dispy		; move bar.
000770r 3               	jmp dbox14		; continue.
000770r 3               fstd:
000770r 3               	lda dispy		; bar position.
000770r 3               	sec
000770r 3               	sbc btop		; find selected option.
000770r 3               	sta varopt		; store the option.
000770r 3               	jmp redraw		; redraw the screen.
000770r 3               
000770r 3               ;------------------------------------------------------
000770r 3               ; Option not available.  Skip this line.
000770r 3               ;------------------------------------------------------
000770r 3               
000770r 3               dbox13:
000770r 3               	ldy #0
000770r 3               	lda (z80_hl),y		; get character.
000770r 3               	inc z80_l		; next one.
000770r 3               	bne :+
000770r 3               	inc z80_h
000770r 3               :
000770r 3               	cmp #','		; another line?
000770r 3               	bne :+
000770r 3               	jmp dbox2		; yes, do next line.
000770r 3               :
000770r 3               	cmp #13			; another line?
000770r 3               	bne :+
000770r 3               	jmp dbox2		; yes, do next line.
000770r 3               :
000770r 3               
000770r 3               	bpl :+			; end of message?
000770r 3               	jmp dbox11		; yes, finish message.
000770r 3               :
000770r 3               	jmp dbox13
000770r 3               dbox15:
000770r 3               .if xflag
000770r 3               	lda #WINDOWWID
000770r 3               	sta winwid
000770r 3               	lda #WINDOWHGT
000770r 3               	sta winhgt
000770r 3               .endif
000770r 3               	lda TmpAddr		; pop message pointer from the stack.
000770r 3               	sta z80_h
000770r 3               	lda TmpAddr+1
000770r 3               	sta z80_l
000770r 3               	rts
000770r 3               
000770r 3               ;------------------------------------------------------
000770r 3               ; Invert bar
000770r 3               ;------------------------------------------------------
000770r 3               
000770r 3               dbar:
000770r 3               	lda blft		; box left.
000770r 3               	sta dispx		; set display coordinate.
000770r 3               	jsr gprad		; get printing address.
000770r 3               
000770r 3               	lda bwid		; box width.
000770r 3               	sta z80_c		; loop counter in c.
000770r 3               	lda z80_h
000770r 3               	sta z80_d		; store screen address high byte.
000770r 3               dbar1:
000770r 3               	ldx #7			; pixel height in b.
000770r 3               dbar0:
000770r 3               	ldy scrtab,x
000770r 3               	lda (scraddr),y		; get screen byte.
000770r 3               	eor #255		; reverse all bits.
000770r 3               	sta (scraddr),y		; write back to screen.
000770r 3               	dex			; next line down.
000770r 3               	bpl dbar0		; draw rest of character.
000770r 3               
000770r 3               	inc scraddr		; one char right.
000770r 3               	dec z80_c		; decrement character counter.
000770r 3               	bne dbar1		; repeat for whole line.
000770r 3               	rts
000770r 3               
000770r 3               ;------------------------------------------------------
000770r 3               ; Point to object
000770r 3               ;
000770r 3               ; Input:
000770r 3               ;  combyt
000770r 3               ;
000770r 3               ; Output:
000770r 3               ;  A = object number, A=255 if already in possession
000770r 3               ;------------------------------------------------------
000770r 3               
000770r 3               invdis:
000770r 3               	lda z80_l		; store message text pointer.
000770r 3               	pha
000770r 3               	lda z80_h
000770r 3               	pha
000770r 3               	lda combyt		; object number.
000770r 3               	inc combyt		; ready for next one.
000770r 3               	jsr gotob		; check if we have object.
000770r 3               	tay
000770r 3               	pla
000770r 3               	sta z80_h
000770r 3               	pla
000770r 3               	sta z80_l
000770r 3               	tya
000770r 3               	rts
000770r 3               
000770r 3               ;------------------------------------------------------
000770r 3               ; Find option selected.
000770r 3               ;
000770r 3               ; Input:
000770r 3               ;  -
000770r 3               ;
000770r 3               ; Output:
000770r 3               ;  OPT = selected object
000770r 3               ;------------------------------------------------------
000770r 3               
000770r 3               fopt:
000770r 3               	lda dispy
000770r 3               	sec
000770r 3               	sbc btop		; find selected option.
000770r 3               	sta tmp+2		; option selected in b register.
000770r 3               	inc tmp+2
000770r 3               
000770r 3               	lda #0			; set to first item.
000770r 3               	sta combyt		; object number.
000770r 3               fopt0:
000770r 3               	jsr fobj		; find next object in inventory.
000770r 3               	dec tmp+2
000770r 3               	bne fopt0		; repeat for relevant steps down the list.
000770r 3               
000770r 3               	lda combyt		; get option.
000770r 3               	sta varopt		; store the option.
000770r 3               	dec varopt		; one less, due to where we increment combyt.
000770r 3               	jmp redraw		; redraw the screen.
000770r 3               fobj:
000770r 3               	ldy combyt		; object number.
000770r 3               	inc combyt		; ready for next item.
000770r 3               	tya
000770r 3               	jsr gotob		; do we have this item?
000770r 3               	cmp #255
000770r 3               	bne :+
000770r 3               	rts
000770r 3               :
000770r 3               	jmp fobj		; yes, it's on the list.
000770r 3               
000770r 3               ;bwid:	.byte 0              ; box/menu width.
000770r 3               ;blen:	.byte 0              ; box/menu height.
000770r 3               ;btop:	.byte 0              ; box coordinates.
000770r 3               ;blft:	.byte 0
000770r 3               .endif
000770r 3               
000770r 3               
000770r 3               ;----------------------------------------------------
000770r 3               ; Clear sprite table.
000770r 3               ;
000770r 3               ; sprtab[0] - sprtab[SPRBUF-1] = 255
000770r 3               ;----------------------------------------------------
000770r 3               
000770r 3               xspr:
000770r 3  A9 FF        	lda #255		; clear byte.
000772r 3  A2 00        	ldx #0			; length of table.
000774r 3               xspr0:
000774r 3  9D rr rr     	sta sprtab,x		; sprite table.
000777r 3  E8           	inx			; move to next byte.
000778r 3  E0 CC        	cpx #SPRBUF
00077Ar 3  D0 F8        	bne xspr0		; repeat for rest of table.
00077Cr 3  60           	rts
00077Dr 3               
00077Dr 3               ;-------------------------------------------------------------
00077Dr 3               ; Initialise all objects.
00077Dr 3               ;
00077Dr 3               ; Reset current room,y,x to start room,y,x for all objects
00077Dr 3               ;-------------------------------------------------------------
00077Dr 3               
00077Dr 3               .if oflag
00077Dr 3               iniob:
00077Dr 3               	lda #<objdta 		; objects table.
00077Dr 3               	sta z80_x
00077Dr 3               	lda #>objdta
00077Dr 3               	sta z80_i
00077Dr 3               
00077Dr 3               	ldx numob 		; number of objects in the game.
00077Dr 3               iniob0:
00077Dr 3               	ldy #35
00077Dr 3               	lda (z80_ix),y 		; start screen.
00077Dr 3               	ldy #32
00077Dr 3               	sta (z80_ix),y 		; set start screen.
00077Dr 3               
00077Dr 3               	ldy #36
00077Dr 3               	lda (z80_ix),y 		; find start y.
00077Dr 3               	ldy #33
00077Dr 3               	sta (z80_ix),y 		; set start y.
00077Dr 3               
00077Dr 3               	ldy #37
00077Dr 3               	lda (z80_ix),y 		; get initial x.
00077Dr 3               	ldy #34
00077Dr 3               	sta (z80_ix),y 		; set x coord.
00077Dr 3               
00077Dr 3               	clc 			; point to next object.
00077Dr 3               	lda z80_x
00077Dr 3               	adc #38			; distance between objects.
00077Dr 3               	sta z80_x
00077Dr 3               	bcc :+
00077Dr 3               	inc z80_i
00077Dr 3               :
00077Dr 3               	dex 			; repeat.
00077Dr 3               	bne iniob0
00077Dr 3               
00077Dr 3               	rts
00077Dr 3               .endif
00077Dr 3               
00077Dr 3               ;-----------------------------------------------
00077Dr 3               ; Redraw the screen.
00077Dr 3               ;
00077Dr 3               ; Remove old copy of all sprites for redraw.
00077Dr 3               ;-----------------------------------------------
00077Dr 3               
00077Dr 3               redraw:
00077Dr 3               .if gflag
00077Dr 3               	lda #$ff
00077Dr 3               	sta andeor
00077Dr 3               	lda #$00
00077Dr 3               	sta andeor+1
00077Dr 3               .endif
00077Dr 3               .if xflag
00077Dr 3               	lda #WINDOWWID
00077Dr 3               	sta winwid
00077Dr 3               	lda #WINDOWHGT
00077Dr 3               	sta winhgt
00077Dr 3               .endif
00077Dr 3  A5 69        	lda z80_i 		; place sprite pointer on stack.
00077Fr 3  48           	pha
000780r 3  A5 68        	lda z80_x
000782r 3  48           	pha
000783r 3               
000783r 3  20 rr rr     	jsr droom		; show screen layout.
000786r 3               
000786r 3               
000786r 3               .if oflag
000786r 3               	jsr shwob		; draw objects.
000786r 3               .endif
000786r 3               numsp0:
000786r 3  A9 0C        	lda #NUMSPR		; sprites to draw.
000788r 3  85 rr        	sta tmp
00078Ar 3               
00078Ar 3  A9 rr        	lda #<sprtab		; sprite table.
00078Cr 3  85 68        	sta z80_x
00078Er 3  A9 rr        	lda #>sprtab
000790r 3  85 69        	sta z80_i
000792r 3               redrw0:
000792r 3  A0 00        	ldy #0
000794r 3  B1 68        	lda (z80_ix),y		; old sprite type.
000796r 3  C9 FF        	cmp #255		; is it enabled?
000798r 3  F0 0B        	beq redrw1 		; no, find next one.
00079Ar 3               
00079Ar 3  A0 03        	ldy #3
00079Cr 3  B1 68        	lda (z80_ix),y 		; sprite y.
00079Er 3  C9 B1        	cmp #177		; beyond maximum?
0007A0r 3  B0 03        	bcs redrw1		; yes, nothing to draw.
0007A2r 3               
0007A2r 3  20 rr rr     	jsr sspria		; show single sprite.
0007A5r 3               redrw1:
0007A5r 3  18           	clc			; next sprite.
0007A6r 3  A5 68        	lda z80_x
0007A8r 3  69 11        	adc #TABSIZ		; distance to next odd/even entry.
0007AAr 3  85 68        	sta z80_x
0007ACr 3  90 02        	bcc :+
0007AEr 3  E6 69        	inc z80_i
0007B0r 3               :
0007B0r 3  C6 rr        	dec tmp			; repeat for remaining sprites.
0007B2r 3  D0 DE        	bne redrw0
0007B4r 3               rpblc1:
0007B4r 3               ;	jsr dshrp		; redraw shrapnel.
0007B4r 3               
0007B4r 3               .if aflag
0007B4r 3               	jsr rbloc		; draw blocks for this screen
0007B4r 3               .endif
0007B4r 3  68           	pla			; retrieve sprite pointer.
0007B5r 3  85 68        	sta z80_x
0007B7r 3  68           	pla
0007B8r 3  85 69        	sta z80_i
0007BAr 3               
0007BAr 3  60           	rts
0007BBr 3               
0007BBr 3               ;----------------------------------------------------------------------
0007BBr 3               ; FODDER check
0007BBr 3               ;----------------------------------------------------------------------
0007BBr 3               
0007BBr 3               .if pflag .or dflag
0007BBr 3               fdchk:
0007BBr 3               	cmp #FODDER 		; is it fodder?
0007BBr 3               	beq :+
0007BBr 3               	rts 			; no.
0007BBr 3               :
0007BBr 3               	lda #0			; wipe fodder in MAP
0007BBr 3               	ldy #0
0007BBr 3               	sta (bufaddr),y 	; rewrite block type.
0007BBr 3               
0007BBr 3               	lda dispx		; x=x/8
0007BBr 3               	pha
0007BBr 3               	lsr a
0007BBr 3               	lsr a
0007BBr 3               	lsr a
0007BBr 3               	sta dispx
0007BBr 3               
0007BBr 3               	lda dispy		; y=y/8
0007BBr 3               	pha
0007BBr 3               	lsr a
0007BBr 3               	lsr a
0007BBr 3               	lsr a
0007BBr 3               	sta dispy
0007BBr 3               
0007BBr 3               	lda #0 			; block to write.
0007BBr 3               	jsr pattr 		; write block.
0007BBr 3               
0007BBr 3               	pla
0007BBr 3               	sta dispy
0007BBr 3               	pla
0007BBr 3               	sta dispx
0007BBr 3               	rts
0007BBr 3               .endif
0007BBr 3               
0007BBr 3               ;----------------------------------------------------
0007BBr 3               ; Scrolly text and puzzle variables.
0007BBr 3               ;----------------------------------------------------
0007BBr 3               
0007BBr 3               .if sflag
0007BBr 3               txtbit:	.byte 128		; bit to write.
0007BBr 3               txtwid:	.byte 16		; width of ticker message.
0007BBr 3               txtpos:	.word msgdat
0007BBr 3               txtini:	.word msgdat
0007BBr 3               txtscr:	.word ScreenAddr
0007BBr 3               .endif
0007BBr 3               
0007BBr 3               ;----------------------------------------------------
0007BBr 3               ; Specialist routines.
0007BBr 3               ; Process shrapnel.
0007BBr 3               ;----------------------------------------------------
0007BBr 3               proshr:
0007BBr 3               .if pflag
0007BBr 3               	lda #<SHRAPN		; table.
0007BBr 3               	sta z80_x
0007BBr 3               	lda #>SHRAPN
0007BBr 3               	sta z80_i
0007BBr 3               
0007BBr 3               	lda #NUMSHR		; shrapnel pieces to process.
0007BBr 3               	sta shrctr
0007BBr 3               prosh0:
0007BBr 3               	ldy #0
0007BBr 3               	lda (z80_ix),y		; on/off marker.
0007BBr 3               	asl a
0007BBr 3               proshx:
0007BBr 3               	bcs :+
0007BBr 3               	jsr prosh1 		; on, so process it.
0007BBr 3               :
0007BBr 3               	clc
0007BBr 3               	lda z80_x
0007BBr 3               	adc #SHRSIZ
0007BBr 3               	sta z80_x
0007BBr 3               	bcc :+
0007BBr 3               	inc z80_i
0007BBr 3               :
0007BBr 3               	dec shrctr		; round again.
0007BBr 3               	bne prosh0
0007BBr 3               .endif
0007BBr 3               .if sflag
0007BBr 3               	jsr scrly
0007BBr 3               .endif
0007BBr 3  60           	rts
0007BCr 3               
0007BCr 3               .if pflag
0007BCr 3               ;shrctr:	.byte 0
0007BCr 3               
0007BCr 3               ;----------------------------------------------------
0007BCr 3               ; Proces shrapnel piece
0007BCr 3               ;----------------------------------------------------
0007BCr 3               
0007BCr 3               prosh1:
0007BCr 3               	jsr plot 		; delete the pixel.
0007BCr 3               
0007BCr 3               	lda #<shrptr		; shrapnel routine pointers.
0007BCr 3               	sta z80_l
0007BCr 3               	lda #>shrptr
0007BCr 3               	sta z80_h
0007BCr 3               
0007BCr 3               	ldy #0
0007BCr 3               	lda (z80_ix),y		; restore shrapnel type.
0007BCr 3               	jsr prosh2 		; run the routine.
0007BCr 3               	jsr chkxy		; check x and y are good before we redisplay.
0007BCr 3               
0007BCr 3               	lda #<SHRSIZ 		; distance to next.
0007BCr 3               	sta z80_e
0007BCr 3               	lda #>SHRSIZ
0007BCr 3               	sta z80_d
0007BCr 3               	rts
0007BCr 3               
0007BCr 3               ;----------------------------------------------------
0007BCr 3               ; Run the routine
0007BCr 3               ;----------------------------------------------------
0007BCr 3               
0007BCr 3               prosh2:
0007BCr 3               	asl a 			; 2 bytes per address.
0007BCr 3               	tay
0007BCr 3               	lda shrptr,y
0007BCr 3               	sta z80_l
0007BCr 3               	lda shrptr+1,y 		; fetch high byte from table.
0007BCr 3               	sta z80_h
0007BCr 3               	jmp (z80_hl) 		; jump to routine.
0007BCr 3               
0007BCr 3               ;----------------------------------------------------
0007BCr 3               ; Paricle routine table
0007BCr 3               ;----------------------------------------------------
0007BCr 3               
0007BCr 3               shrptr:	.word laser		; laser.
0007BCr 3               	.word trail		; vapour trail.
0007BCr 3               	.word shrap		; shrapnel from explosion.
0007BCr 3               	.word dotl		; horizontal starfield left.
0007BCr 3               	.word dotr		; horizontal starfield right.
0007BCr 3               	.word dotu		; vertical starfield up.
0007BCr 3               	.word dotd		; vertical starfield down.
0007BCr 3               	.word ptcusr		; user particle.
0007BCr 3               
0007BCr 3               ;----------------------------------------------------
0007BCr 3               ; Explosion shrapnel.
0007BCr 3               ;----------------------------------------------------
0007BCr 3               
0007BCr 3               shrap:
0007BCr 3               	ldy #1
0007BCr 3               	lda (z80_ix),y 		; get the angle.
0007BCr 3               	clc
0007BCr 3               	adc #<shrsin		; shrapnel sine table.
0007BCr 3               	sta z80_l
0007BCr 3               	lda #>shrsin
0007BCr 3               	adc #0
0007BCr 3               	sta z80_h
0007BCr 3               
0007BCr 3               	ldy #0
0007BCr 3               	lda (z80_hl),y 		; fetch value from table.
0007BCr 3               	sta z80_e
0007BCr 3               	inc z80_l 		; next byte of table.
0007BCr 3               	bne :+
0007BCr 3               	inc z80_h
0007BCr 3               :
0007BCr 3               	ldy #0
0007BCr 3               	lda (z80_hl),y		; fetch value from table.
0007BCr 3               	sta z80_d
0007BCr 3               	inc z80_l		; next byte of table.
0007BCr 3               	bne :+
0007BCr 3               	inc z80_h
0007BCr 3               :
0007BCr 3               	ldy #0
0007BCr 3               	lda (z80_hl),y 		; fetch value from table.
0007BCr 3               	sta z80_c
0007BCr 3               	inc z80_l 		; next byte of table.
0007BCr 3               	bne :+
0007BCr 3               	inc z80_h
0007BCr 3               :
0007BCr 3               	ldy #0
0007BCr 3               	lda (z80_hl),y 		; fetch value from table.
0007BCr 3               	sta z80_b
0007BCr 3               
0007BCr 3               	ldy #2
0007BCr 3               	lda (z80_ix),y 		; x coordinate in hl.
0007BCr 3               	clc
0007BCr 3               	adc z80_e		; add sine lb
0007BCr 3               	sta (z80_ix),y		; store new coordinate lb.
0007BCr 3               	ldy #3
0007BCr 3               	lda (z80_ix),y
0007BCr 3               	adc z80_d		; add sine hb
0007BCr 3               	sta (z80_ix),y		; store new coordinate hb.
0007BCr 3               
0007BCr 3               	ldy #4
0007BCr 3               	lda (z80_ix),y	 	; y coordinate in hl.
0007BCr 3               	clc
0007BCr 3               	adc z80_c		; add cosine lb
0007BCr 3               	sta (z80_ix),y		; store new coordinate lb.
0007BCr 3               	ldy #5
0007BCr 3               	lda (z80_ix),y
0007BCr 3               	adc z80_b		; add cosine lb
0007BCr 3               	sta (z80_ix),y		; store new coordinate hb.
0007BCr 3               
0007BCr 3               	rts
0007BCr 3               
0007BCr 3               ;----------------------------------------------------
0007BCr 3               ; Move dots
0007BCr 3               ;----------------------------------------------------
0007BCr 3               
0007BCr 3               dotl:
0007BCr 3               	ldy #5
0007BCr 3               	lda (z80_ix),y
0007BCr 3               	sec
0007BCr 3               	sbc #1		 	; move left.
0007BCr 3               	sta (z80_ix),y
0007BCr 3               	rts
0007BCr 3               dotr:
0007BCr 3               	ldy #5
0007BCr 3               	lda (z80_ix),y
0007BCr 3               	clc
0007BCr 3               	adc #1		 	; move left.
0007BCr 3               	sta (z80_ix),y
0007BCr 3               	rts
0007BCr 3               dotu:
0007BCr 3               	ldy #3
0007BCr 3               	lda (z80_ix),y
0007BCr 3               	sec
0007BCr 3               	sbc #1		 	; move up.
0007BCr 3               	sta (z80_ix),y
0007BCr 3               	rts
0007BCr 3               dotd:
0007BCr 3               	ldy #3
0007BCr 3               	lda (z80_ix),y
0007BCr 3               	clc
0007BCr 3               	adc #1			; move down.
0007BCr 3               	sta (z80_ix),y
0007BCr 3               	rts
0007BCr 3               
0007BCr 3               ;----------------------------------------------------
0007BCr 3               ; Check if coordinates are ok before redrawing at new position.
0007BCr 3               ;
0007BCr 3               ; left:   X>L		X=L	Ok
0007BCr 3               ; right:  R+15>X	X=R	Ok
0007BCr 3               ; top:    Y>T		Y=T	Ok
0007BCr 3               ; bottom: B+15>Y	Y=B	Ok
0007BCr 3               ;----------------------------------------------------
0007BCr 3               
0007BCr 3               chkxy:
0007BCr 3               
0007BCr 3               ; top:    Y>T		Y=T	Ok
0007BCr 3               
0007BCr 3               	ldy #3
0007BCr 3               	lda (z80_ix),y	 	; fetch shrapnel coordinate.
0007BCr 3               	cmp wntopx		; window top.
0007BCr 3               	beq kill
0007BCr 3               	bcs :+			; compare with top window limit.
0007BCr 3               kill:	jmp kilshr		; out of window, kill shrapnel.
0007BCr 3               :
0007BCr 3               ; left:   X>L		X=L	Ok
0007BCr 3               
0007BCr 3               	ldy #5
0007BCr 3               	lda (z80_ix),y	 	; fetch shrapnel coordinate.
0007BCr 3               	cmp wnlftx		; left edge.
0007BCr 3               	beq kill
0007BCr 3               	bcs :+			; compare with left window limit.
0007BCr 3               	jmp kilshr		; out of window, kill shrapnel.
0007BCr 3               :
0007BCr 3               ; bottom: B+15>Y	Y=B	Ok
0007BCr 3               
0007BCr 3               	lda wnbotx		; point to bottom.
0007BCr 3               	clc
0007BCr 3               	adc #15
0007BCr 3               	ldy #3
0007BCr 3               	cmp (z80_ix),y	 	; fetch shrapnel coordinate.
0007BCr 3               	beq kill
0007BCr 3               	bcs :+			; compare with shrapnel x coordinate.
0007BCr 3               	jmp kilshr		; off screen, kill shrapnel..
0007BCr 3               :
0007BCr 3               ; right:  R+15>X	X=R	Ok
0007BCr 3               
0007BCr 3               	lda wnrgtx		; point to right edge.
0007BCr 3               	clc
0007BCr 3               	adc #15
0007BCr 3               	ldy #5
0007BCr 3               	cmp (z80_ix),y	 	; fetch shrapnel coordinate.
0007BCr 3               	beq kill
0007BCr 3               	bcs :+			; compare with window limit.
0007BCr 3               	jmp kilshr		; off screen, kill shrapnel.
0007BCr 3               :
0007BCr 3               
0007BCr 3               ;----------------------------------------------------
0007BCr 3               ; Drop through.
0007BCr 3               ; Display shrapnel.
0007BCr 3               ;----------------------------------------------------
0007BCr 3               
0007BCr 3               plot:
0007BCr 3               	ldy #3
0007BCr 3               	lda (z80_ix),y		; y integer.
0007BCr 3               	sta dispy	 	; workspace coordinates.
0007BCr 3               	ldy #5
0007BCr 3               	lda (z80_ix),y	 	; x integer.
0007BCr 3               	sta dispx 		; workspace coordinates.
0007BCr 3               
0007BCr 3               	ldy #0
0007BCr 3               	lda (z80_ix),y 		; type.
0007BCr 3               	bne :+			; is it a laser?
0007BCr 3               	jmp plot1 		; yes, draw laser instead.
0007BCr 3               :
0007BCr 3               plot0:
0007BCr 3               	lda dispx		; which pixel within byte do we
0007BCr 3               	and #7			; want to set first?
0007BCr 3               	tay
0007BCr 3               	lda dots,y 		; table of small pixel positions.
0007BCr 3               	sta z80_e 		; get value.
0007BCr 3               
0007BCr 3               	jsr scadd 		; screen address.
0007BCr 3               	ldy #0
0007BCr 3               	lda (scraddr),y		; see what's already there.
0007BCr 3               	eor z80_e
0007BCr 3               	sta (scraddr),y 	; put back on screen.
0007BCr 3               	rts
0007BCr 3               
0007BCr 3               plot1:
0007BCr 3               	jsr scadd 		; screen address.
0007BCr 3               	ldy #0
0007BCr 3               	lda (scraddr),y 	; fetch byte there.
0007BCr 3               	eor #255 		; toggle all bits.
0007BCr 3               	sta (scraddr),y 	; new byte.
0007BCr 3               	rts
0007BCr 3               
0007BCr 3               ;----------------------------------------------------
0007BCr 3               ; Switch off shrapnel
0007BCr 3               ;----------------------------------------------------
0007BCr 3               
0007BCr 3               kilshr:
0007BCr 3               	lda #128
0007BCr 3               	ldy #0
0007BCr 3               	sta (z80_ix),y	; switch off shrapnel.
0007BCr 3               	rts
0007BCr 3               
0007BCr 3               ;----------------------------------------------------
0007BCr 3               ; Sine/cosine table
0007BCr 3               ;----------------------------------------------------
0007BCr 3               
0007BCr 3               shrsin:	.word 0,1024,391,946,724,724,946,391
0007BCr 3               	.word 1024,0,946,65144,724,64811,391,64589
0007BCr 3               	.word 0,64512,65144,64589,64811,64811,64589,65144
0007BCr 3               	.word 64512,0,64589,391,64811,724,65144,946
0007BCr 3               
0007BCr 3               ;----------------------------------------------------
0007BCr 3               ; Create trail
0007BCr 3               ;----------------------------------------------------
0007BCr 3               
0007BCr 3               trail:
0007BCr 3               	ldy #1
0007BCr 3               	lda (z80_ix),y 	; time remaining.
0007BCr 3               	sec
0007BCr 3               	sbc #1
0007BCr 3               	sta (z80_ix),y
0007BCr 3               	bne :+
0007BCr 3               	jmp trailk		; time to switch it off.
0007BCr 3               :
0007BCr 3               	jsr qrand		; get a random number.
0007BCr 3               	lsr a 			; x or y axis?
0007BCr 3               	bcc :+
0007BCr 3               	jmp trailv		; use y.
0007BCr 3               :
0007BCr 3               ; Trail horizontal
0007BCr 3               
0007BCr 3               	lsr a 			; which direction?
0007BCr 3               	bcc :+
0007BCr 3               	jmp traill		; go left.
0007BCr 3               :
0007BCr 3               ; Trail right
0007BCr 3               
0007BCr 3               	ldy #5
0007BCr 3               	lda (z80_ix),y
0007BCr 3               	clc
0007BCr 3               	adc #1	 		; go right.
0007BCr 3               	sta (z80_ix),y
0007BCr 3               	rts
0007BCr 3               
0007BCr 3               ; Trail left
0007BCr 3               
0007BCr 3               traill:
0007BCr 3               	ldy #5
0007BCr 3               	lda (z80_ix),y
0007BCr 3               	sec
0007BCr 3               	sbc #1 			; go left.
0007BCr 3               	sta (z80_ix),y
0007BCr 3               	rts
0007BCr 3               
0007BCr 3               ; Trail vertical
0007BCr 3               
0007BCr 3               trailv:
0007BCr 3               	lsr a		 	; which direction?
0007BCr 3               	bcc :+
0007BCr 3               	jmp trailu		; go up.
0007BCr 3               :
0007BCr 3               ; Trail down
0007BCr 3               
0007BCr 3               	ldy #3
0007BCr 3               	lda (z80_ix),y
0007BCr 3               	clc
0007BCr 3               	adc #1 			; go down.
0007BCr 3               	sta (z80_ix),y
0007BCr 3               	rts
0007BCr 3               
0007BCr 3               ; Trail up
0007BCr 3               
0007BCr 3               trailu:
0007BCr 3               	ldy #3
0007BCr 3               	lda (z80_ix),y
0007BCr 3               	sec
0007BCr 3               	sbc #1 			; go up.
0007BCr 3               	sta (z80_ix),y
0007BCr 3               	rts
0007BCr 3               
0007BCr 3               ; Kill trail
0007BCr 3               
0007BCr 3               trailk:
0007BCr 3               	lda #200		; set off-screen to kill vapour trail.
0007BCr 3               	ldy #3
0007BCr 3               	sta (z80_ix),y
0007BCr 3               	rts
0007BCr 3               
0007BCr 3               ;----------------------------------------------------
0007BCr 3               ; Create laser beam
0007BCr 3               ;----------------------------------------------------
0007BCr 3               
0007BCr 3               laser:
0007BCr 3               	ldy #1
0007BCr 3               	lda (z80_ix),y 		; direction.
0007BCr 3               	ror a 			; left or right?
0007BCr 3               	bcc :+
0007BCr 3               	jmp laserl		; move left.
0007BCr 3               :
0007BCr 3               ; Laser right
0007BCr 3               
0007BCr 3               	lda #8			; distance to travel.
0007BCr 3               	sta z80_b
0007BCr 3               	jmp laserm		; move laser.
0007BCr 3               
0007BCr 3               ; Laser left
0007BCr 3               
0007BCr 3               laserl:
0007BCr 3               	lda #248		; distance to travel.
0007BCr 3               	sta z80_b
0007BCr 3               laserm:
0007BCr 3               	ldy #5
0007BCr 3               	lda (z80_ix),y		; x position.
0007BCr 3               	clc
0007BCr 3               	adc z80_b		; add distance.
0007BCr 3               	sta (z80_ix),y		; set new x coordinate.
0007BCr 3               
0007BCr 3               ; Test new block.
0007BCr 3               
0007BCr 3               	sta dispx 		; set x for block collision detection purposes.
0007BCr 3               	ldy #3
0007BCr 3               	lda (z80_ix),y 		; get y.
0007BCr 3               	sta dispy		; set coordinate for collision test.
0007BCr 3               	jsr tstbl 		; get block type there.
0007BCr 3               	cmp #WALL		; is it solid?
0007BCr 3               	bne :+
0007BCr 3               	jmp trailk		; yes, it cannot pass.
0007BCr 3               :
0007BCr 3               .if pflag .or dflag
0007BCr 3                       cmp #FODDER             ; is it fodder?
0007BCr 3                       bne :+
0007BCr 3                       jsr fdchk               ; remove fodder block.
0007BCr 3                       jmp trailk              ; destroy laser.
0007BCr 3               :
0007BCr 3               .endif
0007BCr 3                       rts                     ; no, ignore it.
0007BCr 3               
0007BCr 3               ;----------------------------------------------------
0007BCr 3               ; Dots mask
0007BCr 3               ;----------------------------------------------------
0007BCr 3               
0007BCr 3               dots:	.byte 128,64,32,16,8,4,2,1
0007BCr 3               
0007BCr 3               
0007BCr 3               ;----------------------------------------------------
0007BCr 3               ; Plot, preserving de.
0007BCr 3               ;----------------------------------------------------
0007BCr 3               
0007BCr 3               plotde:
0007BCr 3               	lda z80_d 		; put de on stack.
0007BCr 3               	pha
0007BCr 3               	lda z80_e
0007BCr 3               	pha
0007BCr 3               
0007BCr 3               	jsr plot 		; plot pixel.
0007BCr 3               
0007BCr 3               	pla			; restore de from stack.
0007BCr 3               	sta z80_e
0007BCr 3               	pla
0007BCr 3               	sta z80_d
0007BCr 3               
0007BCr 3               	rts
0007BCr 3               
0007BCr 3               ;----------------------------------------------------
0007BCr 3               ; Shoot a laser.
0007BCr 3               ;----------------------------------------------------
0007BCr 3               
0007BCr 3               shoot:
0007BCr 3               	sta z80_c		; store direction in c register.
0007BCr 3               	ldy #8
0007BCr 3               	lda (z80_ix),y 		; y coordinate.
0007BCr 3               	clc
0007BCr 3               shoot1:
0007BCr 3               	adc #(SPR_HGT/2-1)	; down 7 pixels.
0007BCr 3               	sta z80_l 		; put y coordinate in l.
0007BCr 3               
0007BCr 3               	ldy #9
0007BCr 3               	lda (z80_ix),y 		; x coordinate in h.
0007BCr 3               	sta z80_h
0007BCr 3               
0007BCr 3               	lda z80_i		; store pointer to sprite.
0007BCr 3               	pha
0007BCr 3               	lda z80_x
0007BCr 3               	pha
0007BCr 3               
0007BCr 3               	jsr fpslot 		; find particle slot.
0007BCr 3               	bcs :+
0007BCr 3               	jmp vapou2		; failed, restore ix.
0007BCr 3               :
0007BCr 3               	lda #0
0007BCr 3               	ldy #0
0007BCr 3               	sta (z80_ix),y 		; set up a laser.
0007BCr 3               
0007BCr 3               	lda z80_c
0007BCr 3               	ldy #1
0007BCr 3               	sta (z80_ix),y 		; set the direction.
0007BCr 3               
0007BCr 3               	lda z80_l
0007BCr 3               	ldy #3
0007BCr 3               	sta (z80_ix),y		; set y coordinate.
0007BCr 3               
0007BCr 3               	ror z80_c		; check direction we want.
0007BCr 3               	bcc :+
0007BCr 3               	jmp shootr		; shoot right.
0007BCr 3               :
0007BCr 3               	lda z80_h		; X position.
0007BCr 3               shoot0:
0007BCr 3               	and #248		; align on character boundary.
0007BCr 3               	ldy #5
0007BCr 3               	sta (z80_ix),y		; set x coordinate.
0007BCr 3               	jmp vapou0 		; draw first image.
0007BCr 3               shootr:
0007BCr 3               	lda z80_h		; x position.
0007BCr 3               	clc
0007BCr 3               	adc #15			; look right.
0007BCr 3               	jmp shoot0		; align and continue.
0007BCr 3               
0007BCr 3               ;----------------------------------------------------
0007BCr 3               ; Create a bit of vapour trail.
0007BCr 3               ;----------------------------------------------------
0007BCr 3               
0007BCr 3               vapour:
0007BCr 3               	lda z80_i		; store pointer to sprite.
0007BCr 3               	pha
0007BCr 3               	lda z80_x
0007BCr 3               	pha
0007BCr 3               
0007BCr 3               	ldy #8
0007BCr 3               	lda (z80_ix),y 		; y coordinate.
0007BCr 3               	clc
0007BCr 3               vapou3:
0007BCr 3               	adc #(SPR_HGT/2-1)	; mid-point of sprite.
0007BCr 3               	sta z80_l
0007BCr 3               
0007BCr 3               	ldy #9
0007BCr 3               	lda (z80_ix),y 		; x coordinate.
0007BCr 3               	adc #7
0007BCr 3               	sta z80_h
0007BCr 3               
0007BCr 3               	jsr fpslot 		; find particle slot.
0007BCr 3               	bcc :+
0007BCr 3               	jmp vapou1		; no, we can use it.
0007BCr 3               :
0007BCr 3               vapou2:
0007BCr 3               	pla
0007BCr 3               	sta z80_x
0007BCr 3               	pla
0007BCr 3               	sta z80_i
0007BCr 3               	rts
0007BCr 3               vapou1:
0007BCr 3               	lda z80_l
0007BCr 3               	ldy #3
0007BCr 3               	sta (z80_ix),y		; set up y.
0007BCr 3               
0007BCr 3               	lda z80_h
0007BCr 3               	ldy #5
0007BCr 3               	sta (z80_ix),y 		; set up x coordinate.
0007BCr 3               
0007BCr 3               	jsr qrand		; get quick random number.
0007BCr 3               	and #15			; random time.
0007BCr 3               	clc
0007BCr 3               	adc #15			; minimum time on screen.
0007BCr 3               	ldy #1
0007BCr 3               	sta (z80_ix),y		; set time on screen.
0007BCr 3               
0007BCr 3               	lda #1
0007BCr 3               	ldy #0
0007BCr 3               	sta (z80_ix),y		; define particle as vapour trail.
0007BCr 3               vapou0:
0007BCr 3               	jsr chkxy		; plot first position.
0007BCr 3               	jmp vapou2
0007BCr 3               
0007BCr 3               ;----------------------------------------------------
0007BCr 3               ; Create a user particle.
0007BCr 3               ;----------------------------------------------------
0007BCr 3               
0007BCr 3               ptusr:
0007BCr 3               	sta z80_f		; store timer.
0007BCr 3               
0007BCr 3               	ldy #8
0007BCr 3               	lda (z80_ix),y 		; y coordinate.
0007BCr 3               	clc
0007BCr 3               	adc #7			; mid-point of sprite.
0007BCr 3               	sta z80_l
0007BCr 3               
0007BCr 3               	ldy #9
0007BCr 3               	lda (z80_ix),y 		; x coordinate.
0007BCr 3               	clc
0007BCr 3               	adc #7			; mid-point of sprite.
0007BCr 3               	sta z80_h
0007BCr 3               
0007BCr 3               	jsr fpslot 		; find particle slot.
0007BCr 3               	bcs ptusr1
0007BCr 3               	rts 			; out of slots, can't generate anything.
0007BCr 3               ptusr1:
0007BCr 3               	lda z80_l
0007BCr 3               	ldy #3
0007BCr 3               	sta (z80_ix),y 		; set up y.
0007BCr 3               
0007BCr 3               	lda z80_h
0007BCr 3               	ldy #5
0007BCr 3               	sta (z80_ix),y		; set up x coordinate.
0007BCr 3               
0007BCr 3               	lda z80_f 		; restore timer.
0007BCr 3               	ldy #1
0007BCr 3               	sta (z80_ix),y		; set time on screen.
0007BCr 3               
0007BCr 3               	lda #7
0007BCr 3               	ldy #0
0007BCr 3               	sta (z80_ix),y		; define particle as user particle.
0007BCr 3               
0007BCr 3               	jmp chkxy		; plot first position.
0007BCr 3               
0007BCr 3               ;----------------------------------------------------
0007BCr 3               ; Create a vertical or horizontal star.
0007BCr 3               ;----------------------------------------------------
0007BCr 3               
0007BCr 3               star:
0007BCr 3               	lda z80_i		; store pointer to sprite.
0007BCr 3               	pha
0007BCr 3               	lda z80_x
0007BCr 3               	pha
0007BCr 3               
0007BCr 3               	jsr fpslot 		; find particle slot.
0007BCr 3               	bcs star7		; found one we can use.
0007BCr 3               star0:
0007BCr 3               	pla 			; restore sprite pointer.
0007BCr 3               	sta z80_x
0007BCr 3               	pla
0007BCr 3               	sta z80_i
0007BCr 3               	rts 			; out of slots, can't generate anything.
0007BCr 3               star7:
0007BCr 3               	lda z80_c		; direction.
0007BCr 3               	and #3 			; is it left?
0007BCr 3               	bne :+
0007BCr 3               	jmp star1 		; yes, it's left.
0007BCr 3               :
0007BCr 3               	cmp #1 			; is it right?
0007BCr 3               	bne :+
0007BCr 3               	jmp star2 		; yes, it's right.
0007BCr 3               :
0007BCr 3               	cmp #2 			; is it up?
0007BCr 3               	bne :+
0007BCr 3               	jmp star3 		; yes, it's up.
0007BCr 3               :
0007BCr 3               	ldy wntopx 		; get edge of screen.
0007BCr 3               	iny			; down one pixel.
0007BCr 3               	tya
0007BCr 3               star8:
0007BCr 3               	ldy #3
0007BCr 3               	sta (z80_ix),y 		; set y coord.
0007BCr 3               	jsr qrand 		; get quick random number.
0007BCr 3               star9:
0007BCr 3               	ldy #5
0007BCr 3               	sta (z80_ix),y		; set x position.
0007BCr 3               
0007BCr 3               	lda z80_c		; direction.
0007BCr 3               	and #3			; zero to three.
0007BCr 3               	clc
0007BCr 3               	adc #3			; 3 to 6 for starfield.
0007BCr 3               	ldy #0
0007BCr 3               	sta (z80_ix),y		; define particle as star.
0007BCr 3               	jsr chkxy		; plot first position.
0007BCr 3               	jmp star0
0007BCr 3               star1:
0007BCr 3               	jsr qrand		; get quick random number.
0007BCr 3               	ldy #3
0007BCr 3               	sta (z80_ix),y 		; set y coord.
0007BCr 3               
0007BCr 3               	lda wnrgtx 		; get edge of screen.
0007BCr 3               	clc
0007BCr 3               	adc #15			; add width of sprite minus 1.
0007BCr 3               	jmp star9
0007BCr 3               star2:
0007BCr 3               	jsr qrand 		; get quick random number.
0007BCr 3               	ldy #3
0007BCr 3               	sta (z80_ix),y		; set y coord.
0007BCr 3               
0007BCr 3               	lda wnlftx		; get edge of screen.
0007BCr 3               	jmp star9
0007BCr 3               star3:
0007BCr 3               	lda wnbotx 		; get edge of screen.
0007BCr 3               	clc
0007BCr 3               	adc #15 		; height of sprite minus one pixel.
0007BCr 3               	jmp star8
0007BCr 3               
0007BCr 3               ;----------------------------------------------------
0007BCr 3               ; Find particle slot for lasers or vapour trail.
0007BCr 3               ; can't use alternate accumulator.
0007BCr 3               ;----------------------------------------------------
0007BCr 3               
0007BCr 3               fpslot:
0007BCr 3               	lda #<SHRAPN 		; shrapnel table.
0007BCr 3               	sta z80_x
0007BCr 3               	lda #>SHRAPN
0007BCr 3               	sta z80_i
0007BCr 3               
0007BCr 3               	lda #NUMSHR		; number of pieces in table.
0007BCr 3               	sta z80_b
0007BCr 3               fpslt0:
0007BCr 3               	ldy #0
0007BCr 3               	lda (z80_ix),y		; get type.
0007BCr 3               	asl a  			; is this slot in use?
0007BCr 3               	bcc :+
0007BCr 3               	rts			; no, we can use it.
0007BCr 3               :
0007BCr 3               	clc			; point to more shrapnel.
0007BCr 3               	lda z80_x
0007BCr 3               	adc #SHRSIZ
0007BCr 3               	sta z80_x
0007BCr 3               	bcc :+
0007BCr 3               	inc z80_i
0007BCr 3               :
0007BCr 3               	dec z80_b		; repeat for all shrapnel.
0007BCr 3               	bne fpslt0
0007BCr 3               
0007BCr 3               	clc
0007BCr 3               	rts 			; out of slots, can't generate anything.
0007BCr 3               
0007BCr 3               ;----------------------------------------------------
0007BCr 3               ; Create an explosion at sprite position.
0007BCr 3               ;----------------------------------------------------
0007BCr 3               
0007BCr 3               explod:
0007BCr 3               	sta z80_c 		; particles to create.
0007BCr 3               
0007BCr 3               	lda z80_i 		; store pointer to sprite.
0007BCr 3               	pha
0007BCr 3               	lda z80_x
0007BCr 3               	pha
0007BCr 3               
0007BCr 3               	ldy #8
0007BCr 3               	lda (z80_ix),y 		; y coordinate.
0007BCr 3               	sta z80_l
0007BCr 3               	ldy #9
0007BCr 3               	lda (z80_ix),y		; x coordinate.
0007BCr 3               	sta z80_h
0007BCr 3               
0007BCr 3               	lda #<SHRAPN		; shrapnel table.
0007BCr 3               	sta z80_x
0007BCr 3               	lda #>SHRAPN
0007BCr 3               	sta z80_i
0007BCr 3               
0007BCr 3               	lda #NUMSHR		; number of pieces in table.
0007BCr 3               	sta explcnt
0007BCr 3               expld0:
0007BCr 3               	ldy #0
0007BCr 3               	lda (z80_ix),y		; get type.
0007BCr 3               	asl a 			; is this slot in use?
0007BCr 3               	bcs expld1		; no, we can use it.
0007BCr 3               expld2:
0007BCr 3               	clc
0007BCr 3               	lda z80_x
0007BCr 3               	adc #SHRSIZ
0007BCr 3               	sta z80_x
0007BCr 3               	bcc :+
0007BCr 3               	inc z80_i
0007BCr 3               :
0007BCr 3               	dec explcnt		; repeat for all shrapnel.
0007BCr 3               	bne expld0
0007BCr 3               expld3:
0007BCr 3               	pla			; restore sprite pointer.
0007BCr 3               	sta z80_x
0007BCr 3               	pla
0007BCr 3               	sta z80_i
0007BCr 3               	rts 			; out of slots, can't generate any more.
0007BCr 3               
0007BCr 3               expld1:
0007BCr 3               	lda z80_c		; shrapnel counter.
0007BCr 3               	and #15			; 0 to 15.
0007BCr 3               	clc			; add to x.
0007BCr 3               	adc z80_l
0007BCr 3               	ldy #3
0007BCr 3               	sta (z80_ix),y		; y coord.
0007BCr 3               
0007BCr 3               	lda seed3 		; crap random number.
0007BCr 3               	and #15			; 0 to 15.
0007BCr 3               	clc 			; add to y.
0007BCr 3               	adc z80_h
0007BCr 3               	ldy #5
0007BCr 3               	sta (z80_ix),y		; x coord.
0007BCr 3               
0007BCr 3               	lda #2
0007BCr 3               	ldy #0
0007BCr 3               	sta (z80_ix),y		; switch it on.
0007BCr 3               
0007BCr 3               	jsr chkxy		; plot first position.
0007BCr 3               	jsr qrand		; quick random angle.
0007BCr 3               	and #60 		; keep within range.
0007BCr 3               	ldy #1
0007BCr 3               	sta (z80_ix),y		; angle.
0007BCr 3               
0007BCr 3               	dec z80_c		; one less piece of shrapnel to generate.
0007BCr 3               	bne expld2 		; back to main explosion loop.
0007BCr 3               	jmp expld3 		; restore sprite pointer and exit.
0007BCr 3               
0007BCr 3               ;explcnt:	.byte 0
0007BCr 3               
0007BCr 3               ;----------------------------------------------------
0007BCr 3               ; Quick random
0007BCr 3               ;----------------------------------------------------
0007BCr 3               
0007BCr 3               qrand:
0007BCr 3               	jsr random		; r register.
0007BCr 3               	eor seed3		; combine with seed.
0007BCr 3               	sta seed3 		; new seed.
0007BCr 3               	rts
0007BCr 3               
0007BCr 3               ;seed3:	.byte 0
0007BCr 3               
0007BCr 3               ;----------------------------------------------------
0007BCr 3               ; Display all shrapnel.
0007BCr 3               ;----------------------------------------------------
0007BCr 3               
0007BCr 3               dshrp:
0007BCr 3               	lda #<plotde		; display routine.
0007BCr 3               	sta proshx+1
0007BCr 3               	lda #>plotde
0007BCr 3               	sta proshx+2
0007BCr 3               	jsr proshr		; process shrapnel.
0007BCr 3               
0007BCr 3               	lda #<prosh1		; processing routine.
0007BCr 3               	sta proshx+1
0007BCr 3               	lda #>prosh1
0007BCr 3               	sta proshx+2
0007BCr 3               	rts
0007BCr 3               
0007BCr 3               ;------------------------------------------------------
0007BCr 3               ; Particle engine.
0007BCr 3               ;
0007BCr 3               ; Init particle data for 55 particles in SHRAPN table.
0007BCr 3               ; Every particle has 6 bytes.
0007BCr 3               ;
0007BCr 3               ; global:	-
0007BCr 3               ; local:	x,y,hl
0007BCr 3               ; calls:	-
0007BCr 3               ;------------------------------------------------------
0007BCr 3               
0007BCr 3               inishr:
0007BCr 3               	lda #<SHRAPN 		; table.
0007BCr 3               	sta z80_l
0007BCr 3               	lda #>SHRAPN
0007BCr 3               	sta z80_h
0007BCr 3               
0007BCr 3               	ldy #0
0007BCr 3               	ldx #NUMSHR		; shrapnel pieces to process.
0007BCr 3               inish0:
0007BCr 3               	lda #255 		; kill the shrapnel.
0007BCr 3               	sta (z80_hl),y
0007BCr 3               
0007BCr 3               	clc 			; point there.
0007BCr 3               	lda z80_l
0007BCr 3               	adc #SHRSIZ		; distance to next.
0007BCr 3               	sta z80_l
0007BCr 3               	bcc :+
0007BCr 3               	inc z80_h
0007BCr 3               :
0007BCr 3               	dex
0007BCr 3               	bne inish0 		; round again.
0007BCr 3               	rts
0007BCr 3               
0007BCr 3               ;------------------------------------------------------
0007BCr 3               ; Check for collision between laser and sprite.
0007BCr 3               ;------------------------------------------------------
0007BCr 3               
0007BCr 3               lcol:
0007BCr 3               	lda #<SHRAPN		; shrapnel table.
0007BCr 3               	sta z80_l
0007BCr 3               	lda #>SHRAPN
0007BCr 3               	sta z80_h
0007BCr 3               
0007BCr 3               	lda #NUMSHR		; number of pieces in table.
0007BCr 3               	sta z80_b
0007BCr 3               lcol0:
0007BCr 3               	ldy #0
0007BCr 3               	lda (z80_hl),y 		; get type.
0007BCr 3               	beq lcol1		; yes, check collision.
0007BCr 3               lcol3:
0007BCr 3               	clc			; point to more shrapnel.
0007BCr 3               	lda z80_l
0007BCr 3               	adc #SHRSIZ
0007BCr 3               	sta z80_l
0007BCr 3               	bcc :+
0007BCr 3               	inc z80_h
0007BCr 3               :
0007BCr 3               	dec z80_b		; repeat for all shrapnel.
0007BCr 3               	bne lcol0
0007BCr 3               	rts 			; no collision, carry not set.
0007BCr 3               lcol1:
0007BCr 3               	ldy #3
0007BCr 3               	lda (z80_hl),y		; get y.
0007BCr 3               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0007BCr 3               ;	sta dispy		; store y
0007BCr 3               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0007BCr 3               	sec
0007BCr 3               	ldy #8
0007BCr 3               	sbc (z80_ix),y		; subtract sprite y.
0007BCr 3               lcolh:
0007BCr 3               	cmp #SPR_HGT 		; within range?
0007BCr 3               	bcc :+
0007BCr 3               	jmp lcol2		; no, missed.
0007BCr 3               :
0007BCr 3               	ldy #5
0007BCr 3               	lda (z80_hl),y 		; get x.
0007BCr 3               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0007BCr 3               ;	sta dispx		; store x
0007BCr 3               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0007BCr 3               	sec
0007BCr 3               	ldy #9
0007BCr 3               	sbc (z80_ix),y 		; subtract sprite y.
0007BCr 3               	cmp #16			; within range?
0007BCr 3               	bcs :+
0007BCr 3               	jmp lcol4 		; yes, collision occurred.
0007BCr 3               :
0007BCr 3               lcol2:
0007BCr 3               	jmp lcol3
0007BCr 3               lcol4:
0007BCr 3               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0007BCr 3               ;	lda #200		; set off-screen to kill vapour trail.
0007BCr 3               ;	ldy #3
0007BCr 3               ;	sta (z80_hl),y		; set laser off screen
0007BCr 3               ;	jsr scadd		; calculate screenaddress
0007BCr 3               ;	ldy #0
0007BCr 3               ;	lda (scraddr),y		; get screen byte
0007BCr 3               ;	eor #255		; remove laser
0007BCr 3               ;	sta (scraddr),y		; store screen byte
0007BCr 3               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0007BCr 3               
0007BCr 3               	sec
0007BCr 3               	rts 			; return with carry set for collision.
0007BCr 3               .endif
0007BCr 3               
0007BCr 3               ;------------------------------------------------------
0007BCr 3               ; Main game engine code starts here.
0007BCr 3               ; After initialisation, mloop is the main loop
0007BCr 3               ;------------------------------------------------------
0007BCr 3               
0007BCr 3               game:
0007BCr 3  20 rr rr     	jsr setpal 		; set up colour palette.
0007BFr 3               
0007BFr 3               rpblc2:
0007BFr 3               .if pflag
0007BFr 3               	jsr inishr 		; initialise particle engine.
0007BFr 3               .endif
0007BFr 3               
0007BFr 3               evintr:
0007BFr 3  20 rr rr     	jsr evnt12 		; call intro/menu event.
0007C2r 3               
0007C2r 3  A9 02        	lda #WALL 		; write default property.
0007C4r 3  A2 00        	ldx #0
0007C6r 3               clrmap:
0007C6r 3  9D 00 04     	sta MAP,x 		; block properties.
0007C9r 3  9D 00 05     	sta MAP+256,x
0007CCr 3  9D 00 06     	sta MAP+512,x
0007CFr 3  E8           	inx			; next byte.
0007D0r 3  D0 F4        	bne clrmap
0007D2r 3               
0007D2r 3               .if oflag
0007D2r 3               	jsr iniob 		; initialise objects.
0007D2r 3               .endif
0007D2r 3  A9 00        	lda #0			; put zero in accumulator.
0007D4r 3  85 rr        	sta gamwon		; reset game won flag.
0007D6r 3               
0007D6r 3  20 rr rr     	jsr inisc 		; init the score.
0007D9r 3               mapst:
0007D9r 3  AD rr rr     	lda stmap 		; start position on map.
0007DCr 3  8D rr rr     	sta roomtb		; set up position in table, if there is one.
0007DFr 3               
0007DFr 3               inipbl:
0007DFr 3               .if aflag
0007DFr 3               	lda #<eop		; reset blockpointer
0007DFr 3               	sta pbptr
0007DFr 3               	lda #>eop
0007DFr 3               	sta pbptr+1
0007DFr 3               .endif
0007DFr 3               
0007DFr 3  20 rr rr     	jsr initsc 		; set up first screen.
0007E2r 3               
0007E2r 3  A9 rr        	lda #<ssprit 		; default to spare sprite in table.
0007E4r 3  85 68        	sta z80_x
0007E6r 3  A9 rr        	lda #>ssprit
0007E8r 3  85 69        	sta z80_i
0007EAr 3               evini:
0007EAr 3  20 rr rr     	jsr evnt13 		; initialisation.
0007EDr 3               
0007EDr 3               ; Two restarts.
0007EDr 3               ; First restart - clear all sprites and initialise everything.
0007EDr 3               
0007EDr 3               rstrt:
0007EDr 3  20 rr rr     	jsr rsevt 		; restart events.
0007F0r 3  20 rr rr     	jsr xspr 		; clear sprite table.
0007F3r 3  20 rr rr     	jsr sprlst 		; fetch pointer to screen sprites.
0007F6r 3  20 rr rr     	jsr ispr 		; initialise sprite table.
0007F9r 3               
0007F9r 3  4C rr rr     	jmp rstrt0
0007FCr 3               
0007FCr 3               ; Second restart - clear all but player, and don't initialise him.
0007FCr 3               
0007FCr 3               rstrtn:
0007FCr 3  20 rr rr     	jsr rsevt		; restart events.
0007FFr 3  20 rr rr     	jsr nspr 		; clear all non-player sprites.
000802r 3  20 rr rr     	jsr sprlst 		; fetch pointer to screen sprites.
000805r 3  20 rr rr     	jsr kspr 		; initialise sprite table, no more players.
000808r 3               
000808r 3               ; Set up the player and/or enemy sprites.
000808r 3               
000808r 3               rstrt0:
000808r 3  A9 00        	lda #0 			; zero in accumulator.
00080Ar 3  85 rr        	sta nexlev 		; reset next level flag.
00080Cr 3  85 rr        	sta restfl 		; reset restart flag.
00080Er 3  85 rr        	sta deadf 		; reset dead flag.
000810r 3               
000810r 3  20 rr rr     	jsr droom 		; show screen layout.
000813r 3               
000813r 3               rpblc0:
000813r 3               .if pflag
000813r 3               	jsr inishr 		; initialise particle engine.
000813r 3               .endif
000813r 3               .if aflag
000813r 3               	jsr rbloc		; draw blocks for this screen
000813r 3               .endif
000813r 3               .if oflag
000813r 3               	jsr shwob		; draw objects.
000813r 3               .endif
000813r 3               
000813r 3  A9 rr        	lda #<sprtab 		; address of sprite table, even sprites.
000815r 3  85 68        	sta z80_x
000817r 3  A9 rr        	lda #>sprtab
000819r 3  85 69        	sta z80_i
00081Br 3  20 rr rr     	jsr dspr 		; display sprites.
00081Er 3               
00081Er 3  A9 rr        	lda #<(sprtab+TABSIZ) 	; address of first odd sprite.
000820r 3  85 68        	sta z80_x
000822r 3  A9 rr        	lda #>(sprtab+TABSIZ)
000824r 3  85 69        	sta z80_i
000826r 3  20 rr rr     	jsr dspr 		; display sprites.
000829r 3               mloop:
000829r 3  20 rr rr     	jsr vsync 		; synchronise with display.
00082Cr 3  A9 rr        	lda #<sprtab 		; address of sprite table, even sprites.
00082Er 3  85 68        	sta z80_x
000830r 3  A9 rr        	lda #>sprtab
000832r 3  85 69        	sta z80_i
000834r 3  20 rr rr     	jsr dspr 		; display even sprites.
000837r 3               
000837r 3               ;	jsr plsnd 		; play sounds.
000837r 3  20 rr rr     	jsr proshr
00083Ar 3               
00083Ar 3  A9 rr        	lda #<(sprtab+TABSIZ) 	; address of first odd sprite.
00083Cr 3  85 68        	sta z80_x
00083Er 3  A9 rr        	lda #>(sprtab+TABSIZ)
000840r 3  85 69        	sta z80_i
000842r 3  20 rr rr     	jsr dspr 		; display odd sprites.
000845r 3               
000845r 3  A9 rr        	lda #<(ssprit) 		; point to spare sprite for spawning purposes.
000847r 3  85 68        	sta z80_x
000849r 3  A9 rr        	lda #>(ssprit)
00084Br 3  85 69        	sta z80_i
00084Dr 3               evlp1:
00084Dr 3  20 rr rr     	jsr evnt10 		; called once per main loop.
000850r 3  20 rr rr     	jsr pspr 		; process sprites.
000853r 3               
000853r 3               ; Main loop events.
000853r 3               
000853r 3  A9 rr        	lda #<ssprit 		; point to spare sprite for spawning purposes.
000855r 3  85 68        	sta z80_x
000857r 3  A9 rr        	lda #>ssprit
000859r 3  85 69        	sta z80_i
00085Br 3               evlp2:
00085Br 3  20 rr rr     	jsr evnt11 		; called once per main loop.
00085Er 3               bsortx:
00085Er 3               ;	jsr bsort 		; sort sprites.
00085Er 3               
00085Er 3  A5 rr        	lda nexlev		; finished level flag.
000860r 3  F0 03        	beq :+
000862r 3  4C rr rr     	jmp newlev		; is set, go to next level.
000865r 3               :
000865r 3  A5 rr        	lda gamwon		; finished game flag.
000867r 3  F0 03        	beq :+
000869r 3  4C rr rr     	jmp evwon		; is set, finish the game.
00086Cr 3               :
00086Cr 3  A5 rr        	lda restfl 		; finished level flag.
00086Er 3  C9 01        	cmp #1			; has it been set?
000870r 3  D0 03        	bne :+
000872r 3  4C rr rr     	jmp rstrt		; yes, go to next level.
000875r 3               :
000875r 3  C9 02        	cmp #2			; has it been set?
000877r 3  D0 03        	bne :+
000879r 3  4C rr rr     	jmp rstrtn		; yes, go to next level.
00087Cr 3               :
00087Cr 3  A5 rr        	lda deadf 		; dead flag.
00087Er 3  F0 03        	beq :+
000880r 3  4C rr rr     	jmp pdead		; yes, player dead.
000883r 3               :
000883r 3               ; back to start of main loop.
000883r 3               
000883r 3  E6 rr        	inc frmno
000885r 3  E6 rr        	inc clock
000887r 3  4C rr rr     	jmp mloop		; switched to a jmp mloop during test mode.
00088Ar 3               
00088Ar 3               ;----------------------------------------------------------
00088Ar 3               ; Read blocks from list and update screen accordingly.
00088Ar 3               ;----------------------------------------------------------
00088Ar 3               
00088Ar 3               .if aflag
00088Ar 3               rbloc:
00088Ar 3               	lda #<eop		; reset temp blockpointer
00088Ar 3               	sta pbbuf
00088Ar 3               	lda #>eop
00088Ar 3               	sta pbbuf+1
00088Ar 3               
00088Ar 3               rbloc2:
00088Ar 3               	lda pbbuf			; check for last block
00088Ar 3               	cmp pbptr
00088Ar 3               	bne rbloc1
00088Ar 3               	lda pbbuf+1
00088Ar 3               	cmp pbptr+1
00088Ar 3               	bne rbloc1
00088Ar 3               	rts
00088Ar 3               rbloc1:
00088Ar 3               	ldy #0
00088Ar 3               	lda (pbbuf),y		; check if block for this scno
00088Ar 3               	cmp scno
00088Ar 3               	bne rbloc0		; if not, skip
00088Ar 3               	iny
00088Ar 3               	lda (pbbuf),y		; get y
00088Ar 3               	sta dispy
00088Ar 3               	iny
00088Ar 3               	lda (pbbuf),y		; get x
00088Ar 3               	sta dispx
00088Ar 3               	iny
00088Ar 3               	lda (pbbuf),y		; get blocknr
00088Ar 3               	jsr pattr2		; draw block
00088Ar 3               rbloc0:
00088Ar 3               	clc			; point to next block
00088Ar 3               	lda pbbuf
00088Ar 3               	adc #4
00088Ar 3               	sta pbbuf
00088Ar 3               	bcc rbloc2
00088Ar 3               	inc pbbuf+1
00088Ar 3               	jmp rbloc2
00088Ar 3               .endif
00088Ar 3               
00088Ar 3               ;----------------------------------------------------------
00088Ar 3               ; New level
00088Ar 3               ;----------------------------------------------------------
00088Ar 3               
00088Ar 3               newlev:
00088Ar 3  A5 rr        	lda scno 			; current screen.
00088Cr 3  18           	clc
00088Dr 3  69 01        	adc #1				; next screen.
00088Fr 3  CD rr rr     	cmp numsc			; total number of screens.
000892r 3  B0 05        	bcs evwon			; yes, game finished.
000894r 3  85 rr        	sta scno			; set new level number.
000896r 3  4C rr rr     	jmp rstrt			; restart, clearing all aliens.
000899r 3               
000899r 3               evwon:
000899r 3  20 rr rr     	jsr evnt18		 	; game completed.
00089Cr 3  4C rr rr     	jmp tidyup			; tidy up and return to BASIC/calling routine.
00089Fr 3               
00089Fr 3               ;----------------------------------------------------------
00089Fr 3               ; Player dead.
00089Fr 3               ;----------------------------------------------------------
00089Fr 3               
00089Fr 3               pdead:
00089Fr 3  A9 00        	lda #0				; zeroise accumulator.
0008A1r 3  85 rr        	sta deadf			; reset dead flag.
0008A3r 3  85 rr        	sta clock
0008A5r 3               evdie:
0008A5r 3  20 rr rr     	jsr evnt16 			; death subroutine.
0008A8r 3  A5 rr        	lda numlif			; number of lives.
0008AAr 3  F0 03        	beq :+
0008ACr 3  4C rr rr     	jmp rstrt 			; restart game.
0008AFr 3               :
0008AFr 3               evfail:
0008AFr 3  20 rr rr     	jsr evnt17 			; failure event.
0008B2r 3               
0008B2r 3               ;----------------------------------------------------------
0008B2r 3               ; Tidy things up
0008B2r 3               ;----------------------------------------------------------
0008B2r 3               
0008B2r 3               tidyup:
0008B2r 3  A0 00        	ldy #0				; digits to check.
0008B4r 3               tidyu2:
0008B4r 3  B9 rr rr     	lda score,y 			; get score digit.
0008B7r 3  CD rr rr     	cmp hiscor 			; are we larger than high score digit?
0008BAr 3  90 07        	bcc tidyu0			; high score is bigger.
0008BCr 3  D0 10        	bne tidyu1			; score is greater, record new high score.
0008BEr 3  C8           	iny				; next digit of high score.
0008BFr 3  C0 06        	cpy #6
0008C1r 3  D0 F1        	bne tidyu2			; repeat for all digits
0008C3r 3               tidyu0:
0008C3r 3  A9 rr        	lda #<score			; return pointing to score.
0008C5r 3  85 62        	sta z80_c
0008C7r 3  A9 rr        	lda #>score
0008C9r 3  85 63        	sta z80_b
0008CBr 3  4C rr rr     	jmp game			; restart game
0008CEr 3               tidyu1:
0008CEr 3  A0 05        	ldy #5
0008D0r 3               tidyu3:
0008D0r 3  B9 rr rr     	lda score,y			; score.
0008D3r 3  99 rr rr     	sta hiscor,y			; high score.
0008D6r 3  88           	dey
0008D7r 3  10 F7        	bpl tidyu3 			; copy score to high score.
0008D9r 3               evnewh:
0008D9r 3  20 rr rr     	jsr evnt19			; new high score event.
0008DCr 3  4C rr rr     	jmp tidyu0			; tidy up.
0008DFr 3               
0008DFr 3               ;--------------------------------------------------
0008DFr 3               ; Restart event.
0008DFr 3               ;--------------------------------------------------
0008DFr 3               
0008DFr 3               rsevt:
0008DFr 3  A9 rr        	lda #<ssprit 			; default to spare element in table.
0008E1r 3  85 68        	sta z80_x
0008E3r 3  A9 rr        	lda #>ssprit
0008E5r 3  85 69        	sta z80_i
0008E7r 3               evrs:
0008E7r 3  4C rr rr     	jmp evnt14	 		; call restart event.
0008EAr 3               
0008EAr 3               ;------------------------------------------------------------------
0008EAr 3               ; Copy number passed in a to string position bc, right-justified.
0008EAr 3               ;
0008EAr 3               ; Input:
0008EAr 3               ;  A  = number
0008EAr 3               ;  BC = string address
0008EAr 3               ;
0008EAr 3               ; Output:
0008EAr 3               ;  BC = string with number
0008EAr 3               ;-----------------------------------------------------------------
0008EAr 3               
0008EAr 3               num2ch:
0008EAr 3  85 65        	sta z80_d		; Save number
0008ECr 3               
0008ECr 3  A9 00        	lda #0
0008EEr 3  85 rr        	sta flag
0008F0r 3               numdg3:
0008F0r 3  A2 64        	ldx #100		; hundreds column.
0008F2r 3  86 64        	stx z80_e
0008F4r 3  20 rr rr     	jsr numdg		; show digit.
0008F7r 3               numdg2:
0008F7r 3  A2 0A        	ldx #10			; tens column.
0008F9r 3  86 64        	stx z80_e
0008FBr 3  20 rr rr     	jsr numdg		; show digit.
0008FEr 3               
0008FEr 3  E6 rr        	inc flag
000900r 3  A2 01        	ldx #1			; units column.
000902r 3  86 64        	stx z80_e
000904r 3               numdg:
000904r 3  A9 30        	lda #48 			; clear digit.
000906r 3  85 61        	sta z80_a
000908r 3               numdg1:
000908r 3  A5 65        	lda z80_d
00090Ar 3  C5 64        	cmp z80_e
00090Cr 3  90 0E        	bcc numdg0		; nothing to show.
00090Er 3  38           	sec
00090Fr 3  A5 65        	lda z80_d
000911r 3  E5 64        	sbc z80_e		; subtract from column.
000913r 3  85 65        	sta z80_d
000915r 3  E6 61        	inc z80_a		; increment digit.
000917r 3  E6 rr        	inc flag
000919r 3  4C rr rr     	jmp numdg1		; repeat until column is zero.
00091Cr 3               numdg0:
00091Cr 3  A0 00        	ldy #0
00091Er 3  A5 61        	lda z80_a
000920r 3  91 62        	sta (z80_bc),y		; write digit to buffer.
000922r 3  A5 rr        	lda flag
000924r 3  F0 06        	beq :+
000926r 3  E6 62        	inc z80_c		; next buffer position.
000928r 3  D0 02        	bne :+
00092Ar 3  E6 63        	inc z80_b
00092Cr 3               :
00092Cr 3  60           	rts
00092Dr 3               num2dd:
00092Dr 3  85 65        	sta z80_d		; Save number
00092Fr 3               
00092Fr 3  A9 01        	lda #1
000931r 3  85 rr        	sta flag
000933r 3               
000933r 3  4C rr rr     	jmp numdg2
000936r 3               num2td:
000936r 3  85 65        	sta z80_d		; Save number
000938r 3               
000938r 3  A9 01        	lda #1
00093Ar 3  85 rr        	sta flag
00093Cr 3  4C rr rr     	jmp numdg3
00093Fr 3               
00093Fr 3               ;flag:	.byte 0
00093Fr 3               
00093Fr 3               ;---------------------------------------------------------
00093Fr 3               ; Reset score to "000000"
00093Fr 3               ;---------------------------------------------------------
00093Fr 3               
00093Fr 3               inisc:
00093Fr 3  A9 30        	lda #'0'
000941r 3  A2 05        	ldx #5			; digits to initialise.
000943r 3               inisc0:
000943r 3  9D rr rr     	sta score,x 		; write zero digit.
000946r 3  CA           	dex			; next column.
000947r 3  10 FA        	bpl inisc0		; repeat for all digits.
000949r 3               
000949r 3  60           	rts
00094Ar 3               
00094Ar 3               ;-----------------------------------------------------
00094Ar 3               ; Multiply h by d and return in hl.
00094Ar 3               ;
00094Ar 3               ; Input:
00094Ar 3               ;  H = first number
00094Ar 3               ;  D = second number
00094Ar 3               ;
00094Ar 3               ; Output:
00094Ar 3               ;  HL = result H x D
00094Ar 3               ;-----------------------------------------------------
00094Ar 3               
00094Ar 3               imul:
00094Ar 3  A5 65        	lda z80_d		; HL = H * D
00094Cr 3  85 64        	sta z80_e
00094Er 3  A5 67        	lda z80_h
000950r 3  85 62        	sta z80_c		; make c first multiplier.
000952r 3               imul0:
000952r 3  A9 00        	lda #0			; zeroise total.
000954r 3  85 66        	sta z80_l
000956r 3  85 67        	sta z80_h
000958r 3               
000958r 3  A5 67        	lda z80_h
00095Ar 3  85 65        	sta z80_d		; zeroise high byte.
00095Cr 3               
00095Cr 3  A9 08        	lda #8			; repeat 8 times.
00095Er 3  85 63        	sta z80_b
000960r 3               imul1:
000960r 3  46 62        	lsr z80_c		; rotate rightmost bit into carry.
000962r 3  90 0E        	bcc imul2		; wasn't set.
000964r 3  18           	clc			; bit was set, so add de.
000965r 3  A5 66        	lda z80_l
000967r 3  65 64        	adc z80_e
000969r 3  85 66        	sta z80_l
00096Br 3  A5 67        	lda z80_h
00096Dr 3  65 65        	adc z80_d
00096Fr 3  85 67        	sta z80_h
000971r 3  18           	clc 			; reset carry.
000972r 3               imul2:
000972r 3  06 64        	asl z80_e 		; shift de 1 bit left.
000974r 3  26 65        	rol z80_d
000976r 3  C6 63        	dec z80_b
000978r 3  D0 E6        	bne imul1		; repeat 8 times.
00097Ar 3               
00097Ar 3  60           	rts
00097Br 3               
00097Br 3               ;-----------------------------------------------
00097Br 3               ; Divide d by e and return in d, remainder in a.
00097Br 3               ;
00097Br 3               ; Input:
00097Br 3               ;  D = first number
00097Br 3               ;  E = second number
00097Br 3               ;
00097Br 3               ; Output:
00097Br 3               ;  D = result D/E
00097Br 3               ;  A = remainder
00097Br 3               ;-----------------------------------------------
00097Br 3               
00097Br 3               idiv:
00097Br 3  A9 00        	lda #0
00097Dr 3  A0 08        	ldy #8		 	; bits to shift.
00097Fr 3  06 65        	asl z80_d
000981r 3               idiv0:
000981r 3  2A           	rol a 			; multiply d by 2.
000982r 3  C5 64        	cmp z80_e 		; test if e is smaller.
000984r 3  90 02        	bcc idiv1		; e is greater, no division this time.
000986r 3  E5 64        	sbc z80_e		; subtract it.
000988r 3               idiv1:
000988r 3  26 65        	rol z80_d		; rotate into d.
00098Ar 3  88           	dey
00098Br 3  D0 F4        	bne idiv0		; repeat
00098Dr 3  60           	rts
00098Er 3               
00098Er 3               ;---------------------------------------------------
00098Er 3               ; Play AY sound effect
00098Er 3               ;---------------------------------------------------
00098Er 3               
00098Er 3               plsnd:
00098Er 3  60           	rts
00098Fr 3               
00098Fr 3               ;---------------------------------------------------
00098Fr 3               ; Objects handling.
00098Fr 3               ; 32 bytes for image
00098Fr 3               ; 3 for room, y and x
00098Fr 3               ; 3 for starting room, y and x.
00098Fr 3               ; 254 = disabled.
00098Fr 3               ; 255 = object in player"s pockets.
00098Fr 3               ;---------------------------------------------------
00098Fr 3               
00098Fr 3               ;---------------------------------------------------
00098Fr 3               ; Show items present.
00098Fr 3               ;---------------------------------------------------
00098Fr 3               
00098Fr 3               .if oflag
00098Fr 3               shwob:
00098Fr 3               	lda #<objdta 			; objects table.
00098Fr 3               	sta z80_l
00098Fr 3               	lda #>objdta
00098Fr 3               	sta z80_h
00098Fr 3               
00098Fr 3               	lda numob 			; number of objects in the game.
00098Fr 3               	sta sprcnt
00098Fr 3               shwob0:
00098Fr 3               	ldy #32 			; distance to room number.
00098Fr 3               	lda (z80_hl),y 			; same as an item?
00098Fr 3               	cmp scno 			; current location.
00098Fr 3               	bne :+
00098Fr 3               	jsr dobj 			; yes, display object.
00098Fr 3               :
00098Fr 3               	clc
00098Fr 3               	lda z80_l
00098Fr 3               	adc #38 			; distance to next item.
00098Fr 3               	sta z80_l
00098Fr 3               	lda z80_h
00098Fr 3               	adc #0
00098Fr 3               	sta z80_h	 		; point to it.
00098Fr 3               	dec sprcnt
00098Fr 3               	bne shwob0 			; repeat for others.
00098Fr 3               	rts
00098Fr 3               
00098Fr 3               ;---------------------------------------------------
00098Fr 3               ; Display object.
00098Fr 3               ; hl must point to object's start address.
00098Fr 3               ;
00098Fr 3               ; Input:
00098Fr 3               ;  HL = object address
00098Fr 3               ;---------------------------------------------------
00098Fr 3               
00098Fr 3               dobj:
00098Fr 3               	ldy #33
00098Fr 3               	lda (z80_hl),y 			; point to y.
00098Fr 3               	sta dispy
00098Fr 3               	iny
00098Fr 3               	lda (z80_hl),y 			; point to x.
00098Fr 3               	sta dispx
00098Fr 3               dobj1:
00098Fr 3               	jmp sprite 			; draw this sprite.
00098Fr 3               
00098Fr 3               ;--------------------------------------
00098Fr 3               ; Remove an object.
00098Fr 3               ;
00098Fr 3               ; Input:
00098Fr 3               ;  A = object number
00098Fr 3               ;--------------------------------------
00098Fr 3               
00098Fr 3               remob:
00098Fr 3               	cmp numob			; number of objects in game.
00098Fr 3               	bcc :+				; are we checking past the end?
00098Fr 3               	rts				; yes, can't get non-existent item.
00098Fr 3               :
00098Fr 3               	pha				; remember object.
00098Fr 3               	jsr getob			; pick it up if we haven't already got it.
00098Fr 3               	pla				; retrieve object number.
00098Fr 3               	jsr gotob			; get its address.
00098Fr 3               	lda #254
00098Fr 3               	ldy #32
00098Fr 3               	sta (z80_hl),y			; remove it.
00098Fr 3               	rts
00098Fr 3               
00098Fr 3               ;---------------------------------------------------
00098Fr 3               ; Pick up object number held in the accumulator.
00098Fr 3               ;
00098Fr 3               ; Input:
00098Fr 3               ;  A = object number
00098Fr 3               ;---------------------------------------------------
00098Fr 3               
00098Fr 3               getob:
00098Fr 3               	cmp numob 		; number of objects in game.
00098Fr 3               	bcc :+			; are we checking past the end?
00098Fr 3               	rts			; yes, can't get non-existent item.
00098Fr 3               :
00098Fr 3               	jsr gotob 		; check if we already have it.
00098Fr 3               	cmp #255
00098Fr 3               	bne :+
00098Fr 3               	rts			; we already do.
00098Fr 3               :
00098Fr 3               	ldy #32
00098Fr 3               	lda (z80_hl),y		; is it on this screen?
00098Fr 3               	cmp scno 		; current screen.
00098Fr 3               	bne getob0		; not on screen, so nothing to delete.
00098Fr 3               
00098Fr 3               	lda #255
00098Fr 3               	sta (z80_hl),y		; pick it up.
00098Fr 3               	iny 			; point to y coord.
00098Fr 3               getob1:
00098Fr 3               	ldy #33
00098Fr 3               	lda (z80_hl),y		; y coord.
00098Fr 3               	sta dispy
00098Fr 3               	ldy #34
00098Fr 3               	lda (z80_hl),y 		; x coord.
00098Fr 3               	sta dispx
00098Fr 3               	jmp dobj1 		; delete object sprite.
00098Fr 3               getob0:
00098Fr 3               	lda #255
00098Fr 3               	sta (z80_hl),y 		; pick it up.
00098Fr 3               	rts
00098Fr 3               .endif
00098Fr 3               
00098Fr 3               ;-----------------------------------------------------------------
00098Fr 3               ; Got object check.
00098Fr 3               ; Call with object in accumulator, returns zero set if in pockets.
00098Fr 3               ;
00098Fr 3               ; Input:
00098Fr 3               ;  A = object number
00098Fr 3               ;-----------------------------------------------------------------
00098Fr 3               .if oflag .or mflag
00098Fr 3               gotob:
00098Fr 3               	cmp numob 		; number of objects in game.
00098Fr 3               	bcc :+ 			; are we checking past the end?
00098Fr 3               	jmp gotob0 		; yes, we can't have a non-existent object.
00098Fr 3               :
00098Fr 3               	jsr findob		; find the object.
00098Fr 3               gotob1:
00098Fr 3               	rts
00098Fr 3               
00098Fr 3               gotob0:
00098Fr 3               	lda #254 		; missing.
00098Fr 3               	jmp gotob1
00098Fr 3               
00098Fr 3               findob:
00098Fr 3               	pha			; save object number
00098Fr 3               	lda #<objdta 		; objects.
00098Fr 3               	sta z80_l
00098Fr 3               	lda #>objdta
00098Fr 3               	sta z80_h
00098Fr 3               	pla			; retreive object number
00098Fr 3               	beq fndob1 		; is it zero? yes, skip loop.
00098Fr 3               	tax 			; loop counter
00098Fr 3               fndob2:
00098Fr 3               	clc
00098Fr 3               	lda z80_l
00098Fr 3               	adc #38 		; size of each object.
00098Fr 3               	sta z80_l
00098Fr 3               	bcc :+
00098Fr 3               	inc z80_h
00098Fr 3               :
00098Fr 3               	dex 			; repeat until we find address.
00098Fr 3               	bne fndob2
00098Fr 3               fndob1:
00098Fr 3               	ldy #32			; distance to room it's in.
00098Fr 3               	lda (z80_hl),y		; fetch status.
00098Fr 3               	rts
00098Fr 3               .endif
00098Fr 3               
00098Fr 3               ;---------------------------------------------
00098Fr 3               ; Drop object number at (dispx, dispy).
00098Fr 3               ;
00098Fr 3               ; Input:
00098Fr 3               ;  A = object number
00098Fr 3               ;---------------------------------------------
00098Fr 3               
00098Fr 3               .if oflag
00098Fr 3               drpob:
00098Fr 3               	cmp numob 		; are we checking past the end?
00098Fr 3               	bcc :+
00098Fr 3               	rts			; yes, can't drop non-existent item.
00098Fr 3               :
00098Fr 3               	jsr gotob		; make sure object is in inventory.
00098Fr 3               	cmp scno		; already on this screen?
00098Fr 3               	bne :+
00098Fr 3               	rts			; yes, nothing to do.
00098Fr 3               :
00098Fr 3               	ldy #32
00098Fr 3               	lda scno
00098Fr 3               	sta (z80_hl),y		; bring onto screen.
00098Fr 3               	lda dispy		; sprite y coordinate.
00098Fr 3               	iny
00098Fr 3               	sta (z80_hl),y		; point to object y.
00098Fr 3               	lda dispx 		; sprite x coordinate.
00098Fr 3               	iny
00098Fr 3               	sta (z80_hl),y 		; point to object x
00098Fr 3               	jmp dobj		; draw the object sprite.
00098Fr 3               
00098Fr 3               ;-----------------------------------------------
00098Fr 3               ; Seek objects at sprite position.
00098Fr 3               ;
00098Fr 3               ; Output:
00098Fr 3               ;  A = object number, if not found A=255
00098Fr 3               ;-----------------------------------------------
00098Fr 3               
00098Fr 3               skobj:
00098Fr 3               	lda #<objdta 		; pointer to objects.
00098Fr 3               	sta z80_l
00098Fr 3               	lda #>objdta
00098Fr 3               	sta z80_h
00098Fr 3               
00098Fr 3               	lda numob 		; number of objects in game.
00098Fr 3               	sta z80_b 		; set up the loop counter.
00098Fr 3               skobj0:
00098Fr 3               	lda scno		; current room number.
00098Fr 3               	ldy #32
00098Fr 3               	cmp (z80_hl),y		; is object in here?
00098Fr 3               	bne :+
00098Fr 3               	jsr skobj1		; yes, check coordinates.
00098Fr 3               :
00098Fr 3               	clc			; point to next object in table.
00098Fr 3               	lda z80_l
00098Fr 3               	adc #38			; size of each object.
00098Fr 3               	sta z80_l
00098Fr 3               	bcc :+
00098Fr 3               	inc z80_h
00098Fr 3               :
00098Fr 3               	dec z80_b
00098Fr 3               	bne skobj0		; repeat for all objects.
00098Fr 3               
00098Fr 3               	lda #255		; end of list and nothing found, return 255.
00098Fr 3               	rts
00098Fr 3               
00098Fr 3               skobj1:
00098Fr 3               	ldy #33			; point to y coordinate.
00098Fr 3               	lda (z80_hl),y		; point to y coordinate.
00098Fr 3               	sec
00098Fr 3               	ldy #8
00098Fr 3               	sbc (z80_ix),y 		; subtract sprite y.
00098Fr 3               	clc
00098Fr 3               	adc #15			; add object height minus one.
00098Fr 3               	cmp #16+COLDISTY-1	; within range?
00098Fr 3               	bcs skobj2		; no, ignore object.
00098Fr 3               
00098Fr 3               	ldy #34			; point to x coordinate now.
00098Fr 3               	lda (z80_hl),y 		; get coordinate.
00098Fr 3               	sec
00098Fr 3               	ldy #9
00098Fr 3               	sbc (z80_ix),y 		; subtract the sprite x.
00098Fr 3               	clc			; add sprite width minus one.
00098Fr 3               	adc #15
00098Fr 3               	cmp #31			; within range?
00098Fr 3               	bcs skobj2		; no, ignore object.
00098Fr 3               
00098Fr 3               	pla			; remove return address from stack.
00098Fr 3               	pla
00098Fr 3               
00098Fr 3               	lda numob 		; objects in game.
00098Fr 3               	sec
00098Fr 3               	sbc z80_b		; subtract loop counter.
00098Fr 3               skobj2:
00098Fr 3               	rts			; accumulator now points to object.
00098Fr 3               .endif
00098Fr 3               
00098Fr 3               ;---------------------------------------------------------------------
00098Fr 3               ; Spawn a new sprite.
00098Fr 3               ;---------------------------------------------------------------------
00098Fr 3               
00098Fr 3               .if gflag
00098Fr 3                 offset = 0
00098Fr 3               .else
00098Fr 3                 offset = 20
00098Fr 3               .endif
00098Fr 3               
00098Fr 3               spawn:
00098Fr 3  A9 rr        	lda #<sprtab		; sprite table.
000991r 3  85 66        	sta z80_l
000993r 3  A9 rr        	lda #>sprtab
000995r 3  85 67        	sta z80_h
000997r 3               numsp1:
000997r 3  A9 0C        	lda #NUMSPR		; number of sprites.
000999r 3  85 rr        	sta spcnt
00099Br 3               spaw0:
00099Br 3  A0 00        	ldy #0
00099Dr 3  B1 66        	lda (z80_hl),y		; get sprite type.
00099Fr 3  C9 FF        	cmp #255		; is it an unused slot?
0009A1r 3  F0 0F        	beq spaw1
0009A3r 3  18           	clc 			; point to next sprite in table.
0009A4r 3  A5 66        	lda z80_l
0009A6r 3  69 11        	adc #TABSIZ		; size of each entry.
0009A8r 3  85 66        	sta z80_l
0009AAr 3  90 02        	bcc :+
0009ACr 3  E6 67        	inc z80_h
0009AEr 3               :
0009AEr 3  C6 rr        	dec spcnt		; one less iteration.
0009B0r 3  D0 E9        	bne spaw0		; keep going until we find a slot.
0009B2r 3               
0009B2r 3               ; Didn't find one but drop through and set up a dummy sprite instead.
0009B2r 3               
0009B2r 3               spaw1:
0009B2r 3  A5 69        	lda z80_i		; address of original sprite.
0009B4r 3  48           	pha
0009B5r 3  A5 68        	lda z80_x
0009B7r 3  48           	pha
0009B8r 3               
0009B8r 3  A5 66        	lda z80_l		; store spawned sprite address.
0009BAr 3  85 rr        	sta spptr
0009BCr 3  A5 67        	lda z80_h
0009BEr 3  85 rr        	sta spptr+1
0009C0r 3               
0009C0r 3  A5 62        	lda z80_c
0009C2r 3  A0 00        	ldy #0
0009C4r 3  91 66        	sta (z80_hl),y 		; set the type.
0009C6r 3  A0 05        	ldy #5
0009C8r 3  91 66        	sta (z80_hl),y		; copy
0009CAr 3               
0009CAr 3  A5 63        	lda z80_b
0009CCr 3  A0 01        	ldy #1
0009CEr 3  91 66        	sta (z80_hl),y		; set the image.
0009D0r 3  A0 06        	ldy #6
0009D2r 3  91 66        	sta (z80_hl),y		; copy
0009D4r 3               
0009D4r 3  A9 00        	lda #0 			; frame zero.
0009D6r 3  A0 02        	ldy #2
0009D8r 3  91 66        	sta (z80_hl),y		; set frame.
0009DAr 3  A0 07        	ldy #7
0009DCr 3  91 66        	sta (z80_hl),y		; copy
0009DEr 3               
0009DEr 3  A0 08        	ldy #8
0009E0r 3  B1 68        	lda (z80_ix),y 		; x coordinate.
0009E2r 3  A0 03        	ldy #3
0009E4r 3  91 66        	sta (z80_hl),y		; set sprite coordinate.
0009E6r 3  A0 08        	ldy #8
0009E8r 3  91 66        	sta (z80_hl),y		; copy
0009EAr 3               
0009EAr 3  A0 09        	ldy #9
0009ECr 3  B1 68        	lda (z80_ix),y 		; y coordinate.
0009EEr 3  A0 04        	ldy #4
0009F0r 3  91 66        	sta (z80_hl),y		; set sprite coordinate.
0009F2r 3  A0 09        	ldy #9
0009F4r 3  91 66        	sta (z80_hl),y		; copy
0009F6r 3               
0009F6r 3  A0 0A        	ldy #10			; direction of original.
0009F8r 3  B1 68        	lda (z80_ix),y
0009FAr 3  91 66        	sta (z80_hl),y		; direction
0009FCr 3               
0009FCr 3  A9 00        	lda #0
0009FEr 3  A0 0B        	ldy #11
000A00r 3  91 66        	sta (z80_hl),y		; reset parameter.
000A02r 3  C8           	iny
000A03r 3  91 66        	sta (z80_hl),y		; reset parameter.
000A05r 3  C8           	iny
000A06r 3  91 66        	sta (z80_hl),y		; reset parameter.
000A08r 3  C8           	iny
000A09r 3  91 66        	sta (z80_hl),y		; reset parameter.
000A0Br 3               rtssp:
000A0Br 3  A5 rr        	lda spptr		; address of new sprite.
000A0Dr 3  85 68        	sta z80_x
000A0Fr 3  A5 rr        	lda spptr+1
000A11r 3  85 69        	sta z80_i
000A13r 3               evis1:
000A13r 3  20 rr rr     	jsr evnt09 		; call sprite initialisation event.
000A16r 3               
000A16r 3  A5 rr        	lda spptr 		; address of new sprite.
000A18r 3  85 68        	sta z80_x
000A1Ar 3  A5 rr        	lda spptr+1
000A1Cr 3  85 69        	sta z80_i
000A1Er 3  20 rr rr     	jsr sspria 		; display the new sprite.
000A21r 3               
000A21r 3  68           	pla			; address of original sprite.
000A22r 3  85 68        	sta z80_x
000A24r 3  68           	pla
000A25r 3  85 69        	sta z80_i
000A27r 3               
000A27r 3  60           	rts
000A28r 3               
000A28r 3               ;spcnt:	.byte 0
000A28r 3               ;spptr:	.word 0			; spawned sprite pointer.
000A28r 3               ;seed:	.byte 0			; seed for random numbers.
000A28r 3  30 30 30 30  score:	.byte "000000"		; player"s score.
000A2Cr 3  30 30        
000A2Er 3  30 30 30 30  hiscor:	.byte "000000"		; high score.
000A32r 3  30 30        
000A34r 3  30 30 30 30  bonus:	.byte "000000"		; bonus.
000A38r 3  30 30        
000A3Ar 3  00 10        grbase:	.word ScreenAddr	; graphics base address.
000A3Cr 3               
000A3Cr 3               ;----------------------------------------------------
000A3Cr 3               ; Check y-pos
000A3Cr 3               ;----------------------------------------------------
000A3Cr 3               
000A3Cr 3               checkx:
000A3Cr 3  A5 rr        	lda dispy		; y position.
000A3Er 3  C9 18        	cmp #24			; off screen?
000A40r 3  B0 01        	bcs :+
000A42r 3  60           	rts			; no, it's okay.
000A43r 3               :
000A43r 3  68           	pla			; remove return address from stack.
000A44r 3  85 66        	sta z80_l
000A46r 3  68           	pla
000A47r 3  85 67        	sta z80_h
000A49r 3  60           	rts
000A4Ar 3               
000A4Ar 3               ;-----------------------------------------------
000A4Ar 3               ; Displays the current high score.
000A4Ar 3               ;-----------------------------------------------
000A4Ar 3               
000A4Ar 3               dhisc:
000A4Ar 3  A9 rr        	lda #<hiscor 		; high score text.
000A4Cr 3  8D rr rr     	sta dscor3+1
000A4Fr 3               .if bigflag
000A4Fr 3               	sta bscor3+1
000A4Fr 3               .endif
000A4Fr 3  A9 rr        	lda #>hiscor
000A51r 3  8D rr rr     	sta dscor3+2
000A54r 3               .if bigflag
000A54r 3               	sta bscor3+2
000A54r 3               .endif
000A54r 3  4C rr rr     	jmp dscor1		; check in printable range then show 6 digits.
000A57r 3               
000A57r 3               ;------------------------------------------------------
000A57r 3               ; Displays the current score.
000A57r 3               ;------------------------------------------------------
000A57r 3               
000A57r 3               dscor:
000A57r 3  A9 rr        	lda #<score		; score text.
000A59r 3  8D rr rr     	sta dscor3+1
000A5Cr 3               .if bigflag
000A5Cr 3               	sta bscor3+1
000A5Cr 3               .endif
000A5Cr 3  A9 rr        	lda #>score
000A5Er 3  8D rr rr     	sta dscor3+2
000A61r 3               .if bigflag
000A61r 3               	sta bscor3+2
000A61r 3               .endif
000A61r 3               dscor1:
000A61r 3  8C rr rr     	sty tmpscr
000A64r 3  20 rr rr     	jsr preprt		; set up font and print position.
000A67r 3  20 rr rr     	jsr checkx		; make sure we're in a printable range.
000A6Ar 3               
000A6Ar 3               .if bigflag
000A6Ar 3               	lda prtmod		; get print mode.
000A6Ar 3               	beq :+			; standard size text?
000A6Ar 3               	jmp bscor0		; no, show double-height.
000A6Ar 3               :
000A6Ar 3               .endif
000A6Ar 3               dscor0:
000A6Ar 3  AC rr rr     	ldy tmpscr
000A6Dr 3               dscor3:
000A6Dr 3  B9 rr rr     	lda score,y
000A70r 3  20 rr rr     	jsr pchar 		; display character.
000A73r 3  E6 rr        	inc dispx		; move along x coordinate
000A75r 3               
000A75r 3  EE rr rr     	inc tmpscr
000A78r 3  C6 63        	dec z80_b
000A7Ar 3  D0 EE        	bne dscor0 		; repeat for all digits.
000A7Cr 3               dscor2:
000A7Cr 3  A5 rr        	lda dispx 		; set up display coordinates.
000A7Er 3  85 rr        	sta charx
000A80r 3  A5 rr        	lda dispy
000A82r 3  85 rr        	sta chary
000A84r 3  60           	rts
000A85r 3               
000A85r 3               ;------------------------------------------------------
000A85r 3               ; Displays the current score in double-height characters.
000A85r 3               ;
000A85r 3               ; Input:
000A85r 3               ;  B  = digit number
000A85r 3               ;  HL = score string
000A85r 3               ;------------------------------------------------------
000A85r 3               
000A85r 3               .if bigflag
000A85r 3               bscor0:
000A85r 3               	ldy tmpscr
000A85r 3               bscor3:
000A85r 3               	lda score,y
000A85r 3               	jsr bchar 		; display big char.
000A85r 3               
000A85r 3               	inc tmpscr
000A85r 3               	dec z80_b
000A85r 3               	beq :+
000A85r 3               	jmp bscor0 		; repeat for all digits.
000A85r 3               :
000A85r 3               	jmp dscor2 		; tidy up line and column variables.
000A85r 3               .endif
000A85r 3               
000A85r 3               ;-----------------------------------------------------
000A85r 3               ; Adds number in the hl pair to the score.
000A85r 3               ;-----------------------------------------------------
000A85r 3               
000A85r 3               addsc:
000A85r 3  A9 rr        	lda #<(score+1) 	; ten thousands column.
000A87r 3  85 64        	sta z80_e
000A89r 3  A9 rr        	lda #>(score+1)
000A8Br 3  85 65        	sta z80_d
000A8Dr 3  A9 10        	lda #<10000		; amount to add each time.
000A8Fr 3  85 62        	sta z80_c
000A91r 3  A9 27        	lda #>10000
000A93r 3  85 63        	sta z80_b
000A95r 3  20 rr rr     	jsr incsc		; add to score.
000A98r 3               
000A98r 3  E6 64        	inc z80_e		; thousands column.
000A9Ar 3  D0 02        	bne :+
000A9Cr 3  E6 65        	inc z80_d
000A9Er 3               :
000A9Er 3  A9 E8        	lda #<1000		; amount to add each time.
000AA0r 3  85 62        	sta z80_c
000AA2r 3  A9 03        	lda #>1000
000AA4r 3  85 63        	sta z80_b
000AA6r 3  20 rr rr     	jsr incsc 		; add to score.
000AA9r 3               
000AA9r 3  E6 64        	inc z80_e		; hundreds column.
000AABr 3  D0 02        	bne :+
000AADr 3  E6 65        	inc z80_d
000AAFr 3               :
000AAFr 3  A9 64        	lda #<100		; amount to add each time.
000AB1r 3  85 62        	sta z80_c
000AB3r 3  A9 00        	lda #>100
000AB5r 3  85 63        	sta z80_b
000AB7r 3  20 rr rr     	jsr incsc		; add to score.
000ABAr 3               
000ABAr 3  E6 64        	inc z80_e 		; tens column.
000ABCr 3  D0 02        	bne :+
000ABEr 3  E6 65        	inc z80_d
000AC0r 3               :
000AC0r 3  A9 0A        	lda #<10		; amount to add each time.
000AC2r 3  85 62        	sta z80_c
000AC4r 3  A9 00        	lda #>10
000AC6r 3  85 63        	sta z80_b
000AC8r 3  20 rr rr     	jsr incsc 		; add to score.
000ACBr 3               
000ACBr 3  E6 64        	inc z80_e		; units column.
000ACDr 3  D0 02        	bne :+
000ACFr 3  E6 65        	inc z80_d
000AD1r 3               :
000AD1r 3  A9 01        	lda #<1			; units.
000AD3r 3  85 62        	sta z80_c
000AD5r 3  A9 00        	lda #>1
000AD7r 3  85 63        	sta z80_b
000AD9r 3               incsc:
000AD9r 3  A5 67        	lda z80_h		; store amount to add.
000ADBr 3  48           	pha
000ADCr 3  A5 66        	lda z80_l
000ADEr 3  48           	pha
000ADFr 3               
000ADFr 3  38           	sec			; subtract from amount to add.
000AE0r 3  A5 66        	lda z80_l
000AE2r 3  E5 62        	sbc z80_c
000AE4r 3  85 66        	sta z80_l
000AE6r 3  A5 67        	lda z80_h
000AE8r 3  E5 63        	sbc z80_b
000AEAr 3  85 67        	sta z80_h
000AECr 3  90 14        	bcc incsc0		; too much, restore value.
000AEEr 3               
000AEEr 3  68           	pla			; delete the previous amount from the stack.
000AEFr 3  68           	pla
000AF0r 3               
000AF0r 3  A5 65        	lda z80_d 		; store column position.
000AF2r 3  48           	pha
000AF3r 3  A5 64        	lda z80_e
000AF5r 3  48           	pha
000AF6r 3  20 rr rr     	jsr incsc2		; do the increment.
000AF9r 3               
000AF9r 3  68           	pla			; restore column.
000AFAr 3  85 64        	sta z80_e
000AFCr 3  68           	pla
000AFDr 3  85 65        	sta z80_d
000AFFr 3  4C rr rr     	jmp incsc		; repeat until all added.
000B02r 3               
000B02r 3               incsc0:
000B02r 3  68           	pla			; restore previous value.
000B03r 3  85 66        	sta z80_l
000B05r 3  68           	pla
000B06r 3  85 67        	sta z80_h
000B08r 3  60           	rts
000B09r 3               incsc2:
000B09r 3  A0 00        	ldy #0
000B0Br 3  B1 64        	lda (z80_de),y 		; get amount.
000B0Dr 3  18           	clc
000B0Er 3  69 01        	adc #1			; add one to column.
000B10r 3  91 64        	sta (z80_de),y		; write new column total.
000B12r 3  C9 3A        	cmp #'9'+1		; gone beyond range of digits?
000B14r 3  B0 01        	bcs :+
000B16r 3  60           	rts			; no, carry on.
000B17r 3               :
000B17r 3  A9 30        	lda #'0'		; make it zero.
000B19r 3  91 64        	sta (z80_de),y		; write new column total.
000B1Br 3  C6 64        	dec z80_e		; back one column.
000B1Dr 3  D0 02        	bne :+
000B1Fr 3  C6 65        	dec z80_d
000B21r 3               :
000B21r 3  4C rr rr     	jmp incsc2
000B24r 3               
000B24r 3               ;------------------------------------
000B24r 3               ; Add bonus to score and reset bonus
000B24r 3               ;------------------------------------
000B24r 3               
000B24r 3               addbo:
000B24r 3  A2 05        	ldx #5			; last digit.
000B26r 3  18           	clc
000B27r 3               addbo0:
000B27r 3  BD rr rr     	lda score,x		; get score.
000B2Ar 3  7D rr rr     	adc bonus,x		; add bonus.
000B2Dr 3  38           	sec			; 0 to 18.
000B2Er 3  E9 30        	sbc #48
000B30r 3  48           	pha
000B31r 3  A9 30        	lda #'0'
000B33r 3  9D rr rr     	sta bonus,x
000B36r 3  68           	pla
000B37r 3  C9 3A        	cmp #58
000B39r 3  90 03        	bcc addbo1
000B3Br 3  38           	sec
000B3Cr 3  E9 0A        	sbc #10
000B3Er 3               addbo1:
000B3Er 3  9D rr rr     	sta score,x		; zeroise bonus.
000B41r 3  CA           	dex			; next digit.
000B42r 3  10 E3        	bpl addbo0		; repeat for all 6 digits.
000B44r 3  60           	rts
000B45r 3               
000B45r 3               ;------------------------------------
000B45r 3               ; Swap score and bonus.
000B45r 3               ;------------------------------------
000B45r 3               
000B45r 3               swpsb:
000B45r 3  A2 05        	ldx #5			; digits to add.
000B47r 3               swpsb0:
000B47r 3  BD rr rr     	lda score,x 		; get score digits.
000B4Ar 3  48           	pha			; save digit
000B4Br 3  BD rr rr     	lda bonus,x 		; get bonus digits.
000B4Er 3  9D rr rr     	sta score,x		; switch score-bonus
000B51r 3  68           	pla
000B52r 3  9D rr rr     	sta bonus,x
000B55r 3  CA           	dex 			; repeat for all 6 digits.
000B56r 3  10 EF        	bpl swpsb0
000B58r 3  60           	rts
000B59r 3               
000B59r 3               ;----------------------------------------------------
000B59r 3               ; Get screen address.
000B59r 3               ;----------------------------------------------------
000B59r 3               
000B59r 3               gprad:
000B59r 3  20 rr rr     	jsr getoffset
000B5Cr 3               
000B5Cr 3  A5 rr        	lda bufaddr
000B5Er 3  85 rr        	sta scraddr
000B60r 3  18           	clc
000B61r 3  A5 rr        	lda bufaddr+1
000B63r 3  69 10        	adc #>ScreenAddr
000B65r 3  85 rr        	sta scraddr+1
000B67r 3  60           	rts
000B68r 3               
000B68r 3               ;--------------------------------------------------------------
000B68r 3               ; Get property buffer address of char at (dispx, dispy) in hl.
000B68r 3               ;
000B68r 3               ; Output:
000B68r 3               ;  bufaddr = MAP + dispy*24 + dispx
000B68r 3               ;--------------------------------------------------------------
000B68r 3               
000B68r 3               pradd:
000B68r 3               
000B68r 3  20 rr rr     	jsr getoffset
000B6Br 3               
000B6Br 3  18           	clc
000B6Cr 3  A5 rr        	lda bufaddr+1
000B6Er 3  69 04        	adc #>MapAddr
000B70r 3  85 rr        	sta bufaddr+1
000B72r 3  60           	rts
000B73r 3               
000B73r 3               ;--------------------------------------------------------------
000B73r 3               ; Set colour of char at (dispx, dispy) in hl.
000B73r 3               ;
000B73r 3               ; Output:
000B73r 3               ;  bufaddr = MAP + dispy*24 + dispx
000B73r 3               ;--------------------------------------------------------------
000B73r 3               
000B73r 3               gaadd:
000B73r 3               
000B73r 3  20 rr rr     	jsr getoffset
000B76r 3               
000B76r 3  18           	clc
000B77r 3  A5 rr        	lda bufaddr+1
000B79r 3  69 94        	adc #>ColorAttr
000B7Br 3  85 rr        	sta bufaddr+1
000B7Dr 3  60           	rts
000B7Er 3               
000B7Er 3               ;----------------------------------------------
000B7Er 3               
000B7Er 3               ; Print attributes, properties and pixels.
000B7Er 3               ;
000B7Er 3               ; Input:
000B7Er 3               ;  A	= tile number
000B7Er 3               ;----------------------------------------------
000B7Er 3               
000B7Er 3               pbpattr:			; entry PUTBLOCK command
000B7Er 3  A4 rr        	ldy charx
000B80r 3  84 rr        	sty dispx
000B82r 3  A4 rr        	ldy chary
000B84r 3  84 rr        	sty dispy
000B86r 3               pattr:
000B86r 3               .if aflag
000B86r 3               	pha
000B86r 3               	jsr wbloc		; save blockinfo
000B86r 3               	pla
000B86r 3               .endif
000B86r 3               
000B86r 3               pattr2:
000B86r 3  85 63        	sta z80_b		; store cell in b register for now.
000B88r 3  AA           	tax
000B89r 3  BD rr rr     	lda bprop,x 		; get block property
000B8Cr 3  85 62        	sta z80_c		; save property
000B8Er 3  C9 08        	cmp #COLECT		; if not COLECT, skip
000B90r 3  D0 05        	bne :+
000B92r 3  A5 63        	lda z80_b
000B94r 3  8D rr rr     	sta colpatt		; save blocknr as COLECT for erasing
000B97r 3               :
000B97r 3  20 rr rr     	jsr pradd 		; get MAP address for storing property
000B9Ar 3  A5 62        	lda z80_c		; Get block property
000B9Cr 3  A0 00        	ldy #0
000B9Er 3  91 rr        	sta (bufaddr),y 	; store property in MAP
000BA0r 3               
000BA0r 3               ; Print attributes, no properties.
000BA0r 3               
000BA0r 3               panp:
000BA0r 3  A6 63        	ldx z80_b
000BA2r 3  BD rr rr     	lda bcol,x
000BA5r 3  48           	pha
000BA6r 3  20 rr rr     	jsr gaadd
000BA9r 3  A0 00        	ldy #0
000BABr 3  68           	pla
000BACr 3  91 rr        	sta (bufaddr),y
000BAEr 3               
000BAEr 3  20 rr rr     	jsr gprad 		; get screen address.
000BB1r 3               
000BB1r 3  A5 63        	lda z80_b		; get blocknr
000BB3r 3  18           	clc
000BB4r 3  69 60        	adc #96			; add 96 to skip font
000BB6r 3  A0 00        	ldy #0
000BB8r 3  91 rr        	sta (scraddr),y 	; copy to screen.
000BBAr 3  E6 rr        	inc dispx 		; move along one.
000BBCr 3  E6 rr        	inc charx
000BBEr 3               
000BBEr 3  60           	rts
000BBFr 3               
000BBFr 3  E0 C0 A0 80  scrtab:		.byte $e0,$c0,$a0,$80,$60,$40,$20,$00
000BC3r 3  60 40 20 00  
000BC7r 3               
000BC7r 3               ;----------------------------------------------
000BC7r 3               ; Write block
000BC7r 3               ;----------------------------------------------
000BC7r 3               
000BC7r 3               .if aflag
000BC7r 3               wbloc:
000BC7r 3               	ldy #3
000BC7r 3               	sta (pbptr),y		; store block number
000BC7r 3               	dey
000BC7r 3               	lda dispx
000BC7r 3               	sta (pbptr),y		; write x position of block.
000BC7r 3               	dey
000BC7r 3               	lda dispy
000BC7r 3               	sta (pbptr),y		; write y position of block.
000BC7r 3               	dey
000BC7r 3               	lda scno
000BC7r 3               	sta (pbptr),y		; write screen.
000BC7r 3               	clc			; point to next free location
000BC7r 3               	lda pbptr
000BC7r 3               	adc #4
000BC7r 3               	sta pbptr
000BC7r 3               	bcc :+
000BC7r 3               	inc pbptr+1
000BC7r 3               :
000BC7r 3               	rts
000BC7r 3               .endif
000BC7r 3               
000BC7r 3               ;----------------------------------------------
000BC7r 3               ; Print character pixels, no more.
000BC7r 3               ;
000BC7r 3               ; Input:
000BC7r 3               ;  A	= character to print
000BC7r 3               ;----------------------------------------------
000BC7r 3               
000BC7r 3               pchr:
000BC7r 3  20 rr rr     	jsr pchar 		; show character in accumulator.
000BCAr 3  E6 rr        	inc dispx		; move along one.
000BCCr 3  60           	rts
000BCDr 3               
000BCDr 3               ;----------------------------------------------------
000BCDr 3               ; Shifter sprite routine for objects.
000BCDr 3               ;----------------------------------------------------
000BCDr 3               
000BCDr 3               .if oflag
000BCDr 3               sprit7:
000BCDr 3               	lda z80_b
000BCDr 3               	beq sprit0
000BCDr 3               	sta z80_a
000BCDr 3               sprit3:
000BCDr 3               	lsr spr			; shift into position.
000BCDr 3               	ror spr+1
000BCDr 3               	ror spr+2
000BCDr 3               	dec z80_a		; one less iteration.
000BCDr 3               	bne sprit3
000BCDr 3               sprit0:
000BCDr 3               	rts 			; now apply to screen.
000BCDr 3               
000BCDr 3               ;----------------------------------------------------
000BCDr 3               ; Draw sprite
000BCDr 3               ;----------------------------------------------------
000BCDr 3               
000BCDr 3               sprite:
000BCDr 3               	stx xtmp		; Save X-reg
000BCDr 3               	jsr scadd 		; get screen address in scraddr.
000BCDr 3               
000BCDr 3               	lda dispx 		; x position.
000BCDr 3               	and #7 			; position straddling cells.
000BCDr 3               	sta z80_b		; store in b register.
000BCDr 3               
000BCDr 3               	lda z80_l		; store sprite graphic address.
000BCDr 3               	sta sprit1+1
000BCDr 3               	sta sprit2+1
000BCDr 3               	lda z80_h
000BCDr 3               	sta sprit1+2
000BCDr 3               	sta sprit2+2
000BCDr 3               
000BCDr 3               	ldx #0			; pixel height.
000BCDr 3               	ldy #0
000BCDr 3               sprit1:
000BCDr 3               	lda objdta,x		; fetch first byte.
000BCDr 3               	sta spr
000BCDr 3               	inx
000BCDr 3               sprit2:
000BCDr 3               	lda objdta,x
000BCDr 3               	sta spr+1
000BCDr 3               
000BCDr 3               	lda #0
000BCDr 3               	sta spr+2
000BCDr 3               	jsr sprit7		; shift sprite
000BCDr 3               
000BCDr 3               	dex
000BCDr 3               	lda spr			; fetch graphic.
000BCDr 3               	ldy spritetab,x
000BCDr 3               	eor (scraddr),y		; merge with screen image.
000BCDr 3               	sta (scraddr),y		; write to screen.
000BCDr 3               	inx			; next screen byte.
000BCDr 3               
000BCDr 3               	lda spr+1		; fetch graphic.
000BCDr 3               	ldy spritetab,x
000BCDr 3               	eor (scraddr),y		; merge with screen image.
000BCDr 3               	sta (scraddr),y		; write to screen.
000BCDr 3               	iny
000BCDr 3               
000BCDr 3               	lda spr+2		; fetch graphic.
000BCDr 3               	eor (scraddr),y		; merge with screen image.
000BCDr 3               	sta (scraddr),y		; write to screen.
000BCDr 3               
000BCDr 3               	inx			; next source byte.
000BCDr 3               	cpx #16
000BCDr 3               	bne :+
000BCDr 3               	inc scraddr+1
000BCDr 3               :
000BCDr 3               	cpx #32
000BCDr 3               	bne sprit1		; repeat
000BCDr 3               
000BCDr 3               	ldx xtmp		; retreive X-reg
000BCDr 3               	rts
000BCDr 3               
000BCDr 3               spritetab:
000BCDr 3               	.byte $00,$01,$20,$21,$40,$41,$60,$61
000BCDr 3               	.byte $80,$81,$a0,$a1,$c0,$c1,$e0,$e1
000BCDr 3               	.byte $00,$01,$20,$21,$40,$41,$60,$61
000BCDr 3               	.byte $80,$81,$a0,$a1,$c0,$c1,$e0,$e1
000BCDr 3               
000BCDr 3               spr:	.byte 0,0,0
000BCDr 3               
000BCDr 3               ;xtmp:	.byte 0
000BCDr 3               .endif
000BCDr 3               
000BCDr 3               ;-----------------------------------------------------------
000BCDr 3               ; Get room address.
000BCDr 3               ;-----------------------------------------------------------
000BCDr 3               
000BCDr 3               groom:
000BCDr 3  A6 rr        	ldx scno 		; screen number.
000BCFr 3  A0 00        	ldy #0
000BD1r 3               groomx:
000BD1r 3  A9 rr        	lda #<scdat 		; pointer to screens.
000BD3r 3  85 66        	sta z80_l
000BD5r 3  A9 rr        	lda #>scdat
000BD7r 3  85 67        	sta z80_h
000BD9r 3               groom1:
000BD9r 3  E0 00        	cpx #0			; is it the first one?
000BDBr 3  F0 15        	beq groom0 		; no more screens to skip.
000BDDr 3               
000BDDr 3  18           	clc
000BDEr 3  A5 66        	lda z80_l
000BE0r 3  79 rr rr     	adc scdat,y 		; low byte of screen size.
000BE3r 3  85 66        	sta z80_l
000BE5r 3  C8           	iny			; point to high byte.
000BE6r 3  A5 67        	lda z80_h
000BE8r 3  79 rr rr     	adc scdat,y 		; high byte of screen size.
000BEBr 3  85 67        	sta z80_h
000BEDr 3  C8           	iny			; next address.
000BEEr 3               
000BEEr 3  CA           	dex 			; one less iteration.
000BEFr 3  4C rr rr     	jmp groom1 		; loop until we reach the end.
000BF2r 3               groom0:
000BF2r 3  AD rr rr     	lda numsc 		; add displacement.
000BF5r 3  0A           	asl a
000BF6r 3  18           	clc			; add double displacement to address.
000BF7r 3  65 66        	adc z80_l
000BF9r 3  85 66        	sta z80_l
000BFBr 3  A5 67        	lda z80_h
000BFDr 3  69 00        	adc #0
000BFFr 3  85 67        	sta z80_h
000C01r 3  60           	rts
000C02r 3               
000C02r 3               ;-----------------------------------------------------------
000C02r 3               ; Draw present room.
000C02r 3               ;-----------------------------------------------------------
000C02r 3               
000C02r 3               droom:
000C02r 3  AD rr rr     	lda wintop 		; window top.
000C05r 3  85 rr        	sta dispy		; set cursor y position.
000C07r 3               droom2:
000C07r 3  20 rr rr     	jsr groom 		; get address of current room.
000C0Ar 3  A9 00        	lda #0	 		; zero in accumulator.
000C0Cr 3  85 rr        	sta comcnt 		; reset compression counter.
000C0Er 3  AD rr rr     	lda winhgt 		; height of window.
000C11r 3  85 rr        	sta rrow		; set row counter
000C13r 3               droom0:
000C13r 3  AD rr rr     	lda winlft 		; window left edge.
000C16r 3  85 rr        	sta dispx 		; set cursor x position.
000C18r 3  AD rr rr     	lda winwid 		; width of window.
000C1Br 3  85 rr        	sta rcol		; set column counter
000C1Dr 3               droom1:
000C1Dr 3  20 rr rr     	jsr flbyt 		; decompress next byte on the fly.
000C20r 3               .if xflag
000C20r 3               	jsr drwmeta
000C20r 3               .else
000C20r 3  20 rr rr     	jsr pattr2 		; set tile attribute in MAP and display tile.
000C23r 3               
000C23r 3               .endif
000C23r 3               
000C23r 3  C6 rr        	dec rcol		; one less column.
000C25r 3  D0 F6        	bne droom1 		; repeat for entire line.
000C27r 3  E6 rr        	inc dispy		; move down one line.
000C29r 3               .if xflag
000C29r 3               	inc dispy
000C29r 3               .endif
000C29r 3               
000C29r 3  C6 rr        	dec rrow 		; one less row.
000C2Br 3  D0 E6        	bne droom0 		; repeat for all rows.
000C2Dr 3               
000C2Dr 3  60           	rts
000C2Er 3               
000C2Er 3               ;rcol:	.byte 0
000C2Er 3               ;rrow:	.byte 0
000C2Er 3               
000C2Er 3               ;----------------------------------------------
000C2Er 3               ; Decompress bytes on-the-fly.
000C2Er 3               ;----------------------------------------------
000C2Er 3               
000C2Er 3               flbyt:
000C2Er 3  A5 rr        	lda comcnt 		; compression counter.
000C30r 3  D0 21        	bne flbyt1		; any more to decompress?  yes.
000C32r 3               
000C32r 3  A0 00        	ldy #0
000C34r 3  B1 66        	lda (z80_hl),y 		; fetch next byte.
000C36r 3  E6 66        	inc z80_l 		; point to next cell.
000C38r 3  D0 02        	bne :+
000C3Ar 3  E6 67        	inc z80_h
000C3Cr 3               :
000C3Cr 3  C9 FF        	cmp #255 		; is this byte a control code?
000C3Er 3  F0 01        	beq :+
000C40r 3  60           	rts 			; no, this byte is uncompressed.
000C41r 3               :
000C41r 3  B1 66        	lda (z80_hl),y 		; fetch byte type.
000C43r 3  85 rr        	sta combyt 		; set up the type.
000C45r 3  E6 66        	inc z80_l 		; point to quantity.
000C47r 3  D0 02        	bne :+
000C49r 3  E6 67        	inc z80_h
000C4Br 3               :
000C4Br 3  B1 66        	lda (z80_hl),y 		; get quantity.
000C4Dr 3  E6 66        	inc z80_l 		; point to next byte.
000C4Fr 3  D0 02        	bne :+
000C51r 3  E6 67        	inc z80_h
000C53r 3               :
000C53r 3               flbyt1:
000C53r 3  85 rr        	sta comcnt 		; store new quantity.
000C55r 3  C6 rr        	dec comcnt		; one less.
000C57r 3  A5 rr        	lda combyt 		; byte to expand.
000C59r 3  60           	rts
000C5Ar 3               
000C5Ar 3               ; ------------------------------------------------------------------------------------------------------------------------------------------
000C5Ar 3               ; Drawing a MetaBlock (4 tiles 8x8 => 16x16)
000C5Ar 3               ; param in regA tells the block number to use, if 0 use 0,0,0,0  else use N,N+2 || N+1,N+3
000C5Ar 3               ; ------------------------------------------------------------------------------------------------------------------------------------------
000C5Ar 3               .if xflag
000C5Ar 3               drwmeta:
000C5Ar 3               	sta tmpblk
000C5Ar 3               	jsr pattr2
000C5Ar 3               
000C5Ar 3               	inc dispy
000C5Ar 3               	dec dispx
000C5Ar 3               	ldx tmpblk
000C5Ar 3               	beq :+
000C5Ar 3               	inx
000C5Ar 3               :
000C5Ar 3               	txa
000C5Ar 3               	jsr pattr2
000C5Ar 3               
000C5Ar 3               	ldx tmpblk
000C5Ar 3               	beq :+
000C5Ar 3               	inx
000C5Ar 3               	inx
000C5Ar 3               	inx
000C5Ar 3               :
000C5Ar 3               	txa
000C5Ar 3               	jsr pattr2
000C5Ar 3               
000C5Ar 3               	dec dispy
000C5Ar 3               	dec dispx
000C5Ar 3               	ldx tmpblk
000C5Ar 3               	beq :+
000C5Ar 3               	inx
000C5Ar 3               	inx
000C5Ar 3               :
000C5Ar 3               	txa
000C5Ar 3               	jsr pattr2
000C5Ar 3               	rts
000C5Ar 3               
000C5Ar 3               tmpblk:	.byte 0
000C5Ar 3               
000C5Ar 3               .endif
000C5Ar 3               
000C5Ar 3               ;------------------------------------------
000C5Ar 3               ; Ladder down check.
000C5Ar 3               ;
000C5Ar 3               ; Input:
000C5Ar 3               ;  IX = sprite pointer
000C5Ar 3               ;------------------------------------------
000C5Ar 3               
000C5Ar 3               .if lflag
000C5Ar 3               laddd:
000C5Ar 3               	ldy #9
000C5Ar 3               	lda (z80_ix),y		; x coordinate.
000C5Ar 3               	sta dispx
000C5Ar 3               
000C5Ar 3               	ldy #8
000C5Ar 3               	lda (z80_ix),y		; y coordinate.
000C5Ar 3               	and #254		; make it even.
000C5Ar 3               	sta (z80_ix),y 		; reset it.
000C5Ar 3               	clc 			; look down 16 pixels.
000C5Ar 3               numsp5:
000C5Ar 3               	adc #SPR_HGT
000C5Ar 3               	sta dispy		; coords in dispx,dispy.
000C5Ar 3               	jmp laddv
000C5Ar 3               
000C5Ar 3               ;------------------------------------------
000C5Ar 3               ; Ladder up check.
000C5Ar 3               ;
000C5Ar 3               ; Input:
000C5Ar 3               ;  IX = sprite pointer
000C5Ar 3               ;
000C5Ar 3               ; Output:
000C5Ar 3               ;  A  = 0 is ok, A <>0 is not ok
000C5Ar 3               ;------------------------------------------
000C5Ar 3               
000C5Ar 3               laddu:
000C5Ar 3               	ldy #9
000C5Ar 3               	lda (z80_ix),y		; x coordinate.
000C5Ar 3               	sta dispx
000C5Ar 3               
000C5Ar 3               	ldy #8
000C5Ar 3               	lda (z80_ix),y		; y coordinate.
000C5Ar 3               	and #254 		; make it even.
000C5Ar 3               	sta (z80_ix),y		; reset it.
000C5Ar 3               	clc 			; look 2 pixels above feet.
000C5Ar 3               numsp6:
000C5Ar 3               	adc #SPR_HGT-2
000C5Ar 3               	sta dispy		; coords in dispx,dispy.
000C5Ar 3               laddv:
000C5Ar 3               	jsr tstbl 		; get map address.
000C5Ar 3               	jsr ldchk 		; standard ladder check.
000C5Ar 3               	beq :+
000C5Ar 3               	rts 			; no way through.
000C5Ar 3               :
000C5Ar 3               	inc bufaddr 		; look right one cell.
000C5Ar 3               	bne :+
000C5Ar 3               	inc bufaddr+1
000C5Ar 3               :
000C5Ar 3               	jsr ldchk 		; do the check.
000C5Ar 3               	beq :+
000C5Ar 3               	rts 			; impassable.
000C5Ar 3               :
000C5Ar 3               	lda dispx 		; y coordinate.
000C5Ar 3               	and #7 			; position straddling block cells.
000C5Ar 3               	bne :+
000C5Ar 3               	rts 			; no more checks needed.
000C5Ar 3               :
000C5Ar 3               	inc bufaddr 		; look to third cell.
000C5Ar 3               	bne :+
000C5Ar 3               	inc bufaddr+1
000C5Ar 3               :
000C5Ar 3               	jsr ldchk 		; do the check.
000C5Ar 3               	rts  			; return with zero flag set accordingly.
000C5Ar 3               .endif
000C5Ar 3               
000C5Ar 3               ;---------------------------------------------------------
000C5Ar 3               ; Can go up check.
000C5Ar 3               ;
000C5Ar 3               ; Input:
000C5Ar 3               ;  IX = sprite pointer
000C5Ar 3               ;
000C5Ar 3               ; Output:
000C5Ar 3               ;  A  = 0 is ok, A <>0 is not ok
000C5Ar 3               ;---------------------------------------------------------
000C5Ar 3               
000C5Ar 3               cangu:
000C5Ar 3  A0 09        	ldy #9
000C5Cr 3  B1 68        	lda (z80_ix),y		; x coordinate.
000C5Er 3  85 rr        	sta dispx
000C60r 3  A0 08        	ldy #8
000C62r 3  B1 68        	lda (z80_ix),y 		; y coordinate.
000C64r 3  38           	sec
000C65r 3  E9 02        	sbc #2
000C67r 3  85 rr        	sta dispy		; coords in dispx,dispy.
000C69r 3  20 rr rr     	jsr tstbl 		; get map address.
000C6Cr 3  20 rr rr     	jsr lrchk 		; standard left/right check.
000C6Fr 3  F0 01        	beq :+
000C71r 3  60           	rts			; no way through.
000C72r 3               :
000C72r 3  E6 rr        	inc bufaddr		; look right one cell.
000C74r 3  D0 02        	bne :+
000C76r 3  E6 rr        	inc bufaddr+1
000C78r 3               :
000C78r 3  20 rr rr     	jsr lrchk 		; do the check.
000C7Br 3  F0 01        	beq :+
000C7Dr 3  60           	rts			; impassable.
000C7Er 3               :
000C7Er 3  A5 rr        	lda dispx		; x coordinate.
000C80r 3  29 07        	and #7			; position straddling block cells.
000C82r 3  D0 01        	bne :+
000C84r 3  60           	rts			; no more checks needed.
000C85r 3               :
000C85r 3  E6 rr        	inc bufaddr		; look to third cell.
000C87r 3  D0 02        	bne :+
000C89r 3  E6 rr        	inc bufaddr+1
000C8Br 3               :
000C8Br 3  20 rr rr     	jsr lrchk		; do the check.
000C8Er 3  60           	rts 			; return with zero flag set accordingly.
000C8Fr 3               
000C8Fr 3               ;---------------------------------------------------------
000C8Fr 3               ; Can go down check.
000C8Fr 3               ;
000C8Fr 3               ; Input:
000C8Fr 3               ;  IX = sprite pointer
000C8Fr 3               ;
000C8Fr 3               ; Output:
000C8Fr 3               ;  A  = 0 is ok, A <>0 is not ok
000C8Fr 3               ;---------------------------------------------------------
000C8Fr 3               
000C8Fr 3               cangd:
000C8Fr 3  A0 09        	ldy #9
000C91r 3  B1 68        	lda (z80_ix),y 		; x coordinate.
000C93r 3  85 rr        	sta dispx
000C95r 3  A0 08        	ldy #8
000C97r 3  B1 68        	lda (z80_ix),y		; y coordinate.
000C99r 3  18           	clc
000C9Ar 3               numsp3:
000C9Ar 3  69 10        	adc #SPR_HGT 		; look down 16 pixels.
000C9Cr 3  85 rr        	sta dispy		; coords in dispx,dispy.
000C9Er 3  20 rr rr     	jsr tstbl 		; get map address.
000CA1r 3  20 rr rr     	jsr plchk 		; block, platform check.
000CA4r 3  F0 01        	beq :+
000CA6r 3  60           	rts			; no way through.
000CA7r 3               :
000CA7r 3  E6 rr        	inc bufaddr		; look right one cell.
000CA9r 3  D0 02        	bne :+
000CABr 3  E6 rr        	inc bufaddr+1
000CADr 3               :
000CADr 3  20 rr rr     	jsr plchk		; block, platform check.
000CB0r 3  F0 01        	beq :+
000CB2r 3  60           	rts			; impassable.
000CB3r 3               :
000CB3r 3  A5 rr        	lda dispx		; x coordinate.
000CB5r 3  29 07        	and #7			; position straddling block cells.
000CB7r 3  D0 01        	bne :+
000CB9r 3  60           	rts			; no more checks needed.
000CBAr 3               :
000CBAr 3  E6 rr        	inc bufaddr		; look to third cell.
000CBCr 3  D0 02        	bne :+
000CBEr 3  E6 rr        	inc bufaddr+1
000CC0r 3               :
000CC0r 3  20 rr rr     	jsr plchk		; block, platform check.
000CC3r 3  60           	rts			; return with zero flag set accordingly.
000CC4r 3               
000CC4r 3               ;---------------------------------------------------------
000CC4r 3               ; Can go left check.
000CC4r 3               ;
000CC4r 3               ; Input:
000CC4r 3               ;  IX = sprite pointer
000CC4r 3               ;
000CC4r 3               ; Output:
000CC4r 3               ;  A  = 0 is ok, A <>0 is not ok
000CC4r 3               ;---------------------------------------------------------
000CC4r 3               
000CC4r 3               cangl:
000CC4r 3  A0 08        	ldy #8
000CC6r 3  B1 68        	lda (z80_ix),y 		; y coordinate.
000CC8r 3  85 rr        	sta dispy
000CCAr 3  A0 09        	ldy #9
000CCCr 3  B1 68        	lda (z80_ix),y 		; x coordinate.
000CCEr 3  38           	sec
000CCFr 3  E9 02        	sbc #2			; look left 2 pixels.
000CD1r 3  85 rr        	sta dispx		; coords in dispx,dispy.
000CD3r 3  4C rr rr     	jmp cangh		; test if we can go there.
000CD6r 3               
000CD6r 3               ;---------------------------------------------------------
000CD6r 3               ; Can go right check.
000CD6r 3               ;
000CD6r 3               ; Input:
000CD6r 3               ;  IX = sprite pointer
000CD6r 3               ;
000CD6r 3               ; Output:
000CD6r 3               ;  A  = 0 is ok, A <>0 is not ok
000CD6r 3               ;---------------------------------------------------------
000CD6r 3               
000CD6r 3               cangr:
000CD6r 3  A0 08        	ldy #8
000CD8r 3  B1 68        	lda (z80_ix),y		; y coordinate.
000CDAr 3  85 rr        	sta dispy
000CDCr 3  A0 09        	ldy #9
000CDEr 3  B1 68        	lda (z80_ix),y		; x coordinate.
000CE0r 3  18           	clc
000CE1r 3  69 10        	adc #16			; look right 16 pixels.
000CE3r 3  85 rr        	sta dispx		; coords in dispx,dispy.
000CE5r 3               cangh:
000CE5r 3               cangh2:
000CE5r 3  A9 03        	lda #(SPR_HGT/8+1)	; default rows to write.
000CE7r 3  85 63        	sta z80_b
000CE9r 3  A5 rr        	lda dispy		; y position.
000CEBr 3  29 07        	and #7			; does x straddle cells?
000CEDr 3  D0 02        	bne cangh0		; yes, loop counter is good.
000CEFr 3  C6 63        	dec z80_b		; one less row to write.
000CF1r 3               cangh0:
000CF1r 3  20 rr rr     	jsr tstbl		; get map address.
000CF4r 3               cangh1:
000CF4r 3  20 rr rr     	jsr lrchk		; standard left/right check.
000CF7r 3  F0 01        	beq :+
000CF9r 3  60           	rts			; no way through.
000CFAr 3               :
000CFAr 3  48           	pha
000CFBr 3  18           	clc
000CFCr 3  A5 rr        	lda bufaddr
000CFEr 3  69 20        	adc #32			; look down.
000D00r 3  85 rr        	sta bufaddr
000D02r 3  90 02        	bcc :+
000D04r 3  E6 rr        	inc bufaddr+1
000D06r 3               :
000D06r 3  68           	pla
000D07r 3               
000D07r 3  C6 63        	dec z80_b
000D09r 3  D0 E9        	bne cangh1
000D0Br 3  60           	rts
000D0Cr 3               
000D0Cr 3               ;-------------------------------------
000D0Cr 3               ; Check left/right movement is okay.
000D0Cr 3               ;
000D0Cr 3               ; Input:
000D0Cr 3               ;  bufaddr = MAP + x/8 + y/8*32
000D0Cr 3               ;
000D0Cr 3               ; Output:
000D0Cr 3               ;  A  = 0 is ok, A <>0 is not ok
000D0Cr 3               ;-------------------------------------
000D0Cr 3               
000D0Cr 3               lrchk:
000D0Cr 3  A0 00        	ldy #0
000D0Er 3  B1 rr        	lda (bufaddr),y		; fetch map cell.
000D10r 3  C9 02        	cmp #WALL 		; is it passable?
000D12r 3  F0 0A        	beq lrchkx		; no.
000D14r 3               
000D14r 3  C9 04        	cmp #FODDER		; fodder has to be dug.
000D16r 3  F0 06        	beq lrchkx		; not passable.
000D18r 3               lrlchkx:
000D18r 3  A9 00        	lda #0
000D1Ar 3  60           	rts
000D1Br 3               
000D1Br 3               ;--------------------------------------------------------------
000D1Br 3               ; Called by mmenu
000D1Br 3               ;--------------------------------------------------------------
000D1Br 3               
000D1Br 3               always:
000D1Br 3  A9 00        	lda #0		; report it as okay.
000D1Dr 3  60           	rts
000D1Er 3               
000D1Er 3               lrchkx:
000D1Er 3  A9 01        	lda #1 			; reset all bits.
000D20r 3  60           	rts
000D21r 3               
000D21r 3               
000D21r 3               ;--------------------------------------------------------------
000D21r 3               ; Check platform or solid item is not in way.
000D21r 3               ;
000D21r 3               ; Input:
000D21r 3               ;  bufaddr = MAP + x/8 + y/8*32
000D21r 3               ;
000D21r 3               ; Output:
000D21r 3               ;  A  = 0 is ok, A <>0 is not ok
000D21r 3               ;--------------------------------------------------------------
000D21r 3               
000D21r 3               plchk:
000D21r 3  A0 00        	ldy #0
000D23r 3  B1 rr        	lda (bufaddr),y 	; fetch map cell.
000D25r 3  C9 02        	cmp #WALL 		; is it passable?
000D27r 3  F0 F5        	beq lrchkx		; no.
000D29r 3               .if pflag .or dflag
000D29r 3               	cmp #FODDER		; fodder has to be dug.
000D29r 3               	beq lrchkx		; not passable.
000D29r 3               .endif
000D29r 3  C9 01        	cmp #PLATFM		; platform is solid.
000D2Br 3  F0 03        	beq plchkx		; not passable.
000D2Dr 3               .if lflag
000D2Dr 3               	cmp #LADDER		; is it a ladder?
000D2Dr 3               	beq lrchkx		; on ladder, deny movement.
000D2Dr 3               .endif
000D2Dr 3               plchk0:
000D2Dr 3               .if crflag
000D2Dr 3               	cmp #9
000D2Dr 3               	bcc :+
000D2Dr 3               	jmp lrchkx
000D2Dr 3               :
000D2Dr 3               .endif
000D2Dr 3  A9 00        	lda #0			; report as ok
000D2Fr 3  60           	rts
000D30r 3               plchkx:
000D30r 3  A5 rr        	lda dispy		; x coordinate.
000D32r 3  29 07        	and #7			; position straddling blocks.
000D34r 3  F0 E8        	beq lrchkx		; on platform, deny movement.
000D36r 3  4C rr rr     	jmp plchk0
000D39r 3               
000D39r 3               ;--------------------------------------------------------------
000D39r 3               ; Check ladder is available.
000D39r 3               ;
000D39r 3               ; Input:
000D39r 3               ;  bufaddr = MAP + x/8 + y/8*32
000D39r 3               ;
000D39r 3               ; Output:
000D39r 3               ;  A  = 0 is ok, A <>0 is not ok
000D39r 3               ;--------------------------------------------------------------
000D39r 3               
000D39r 3               .if lflag
000D39r 3               ldchk:
000D39r 3               	ldy #0
000D39r 3               	lda (bufaddr),y 	; fetch cell.
000D39r 3               	sta $f0
000D39r 3               	cmp #LADDER 		; is it a ladder?
000D39r 3               	beq :+
000D39r 3               	lda #1
000D39r 3               	rts  			; return with zero flag set accordingly.
000D39r 3               :
000D39r 3               	lda #0
000D39r 3               	rts
000D39r 3               .endif
000D39r 3               
000D39r 3               ;--------------------------------------------------------------
000D39r 3               ; Get collectables.
000D39r 3               ;--------------------------------------------------------------
000D39r 3               
000D39r 3               .if cflag
000D39r 3               getcol:
000D39r 3                       lda #COLECT             ; collectable blocks.
000D39r 3                       sta z80_b
000D39r 3                       jsr tded                ; test for collectable blocks.
000D39r 3                       cmp z80_b               ; did we find one?
000D39r 3                       beq :+
000D39r 3                       rts                     ; none were found, job done.
000D39r 3               :
000D39r 3                       jsr gtblk               ; get block.
000D39r 3                       jsr evnt20              ; collected block event.
000D39r 3                       jmp getcol              ; repeat until none left.
000D39r 3               
000D39r 3               ; Get collectable block.
000D39r 3               
000D39r 3               gtblk:
000D39r 3               	ldy #0
000D39r 3               	lda (bufaddr),y
000D39r 3               	sta z80_a
000D39r 3                       lda #0
000D39r 3                       sta (bufaddr),y		; make it empty now.
000D39r 3               
000D39r 3               	lda bufaddr		; set dispx
000D39r 3               	and #31
000D39r 3               	sta dispx
000D39r 3               
000D39r 3               	lda bufaddr+1		; Set dispy
000D39r 3               	sec
000D39r 3               	sbc #>MAP
000D39r 3               	sta bufaddr+1
000D39r 3               	asl bufaddr
000D39r 3               	rol bufaddr+1
000D39r 3               	asl bufaddr
000D39r 3               	rol bufaddr+1
000D39r 3               	asl bufaddr
000D39r 3               	rol bufaddr+1
000D39r 3               	lda bufaddr+1
000D39r 3               	sta dispy
000D39r 3               
000D39r 3               	lda colpatt		; get blocknr
000D39r 3               	sta z80_e		; displacement in e.
000D39r 3               	lda #0
000D39r 3               	sta z80_d		; no high byte.
000D39r 3               	asl z80_e  		; multiply char by 8.
000D39r 3               	rol z80_d
000D39r 3               	asl z80_e
000D39r 3               	rol z80_d
000D39r 3               	asl z80_e
000D39r 3               	rol z80_d
000D39r 3               	clc
000D39r 3               	lda z80_e
000D39r 3               	adc #<chgfx 		; address of graphics.
000D39r 3               	sta tileaddr
000D39r 3               	lda z80_d
000D39r 3               	adc #>chgfx
000D39r 3               	sta tileaddr+1
000D39r 3               	jsr gprad 		; get screen address.
000D39r 3               	ldx #7			; number of pixel rows to write.
000D39r 3               gtblk0:
000D39r 3               	ldy #0
000D39r 3               	lda (tileaddr),y 	; get image byte.
000D39r 3               	ldy scrtab,x
000D39r 3               	eor (scraddr),y 	; XOR tile on screen
000D39r 3               	sta (scraddr),y 	; copy to screen.
000D39r 3               	inc tileaddr 		; next image byte.
000D39r 3               	bne :+
000D39r 3               	inc tileaddr+1
000D39r 3               :
000D39r 3               	dex	 		; repeat for 8 pixel rows.
000D39r 3               	bpl gtblk0
000D39r 3               	rts
000D39r 3               .endif
000D39r 3               
000D39r 3               ;--------------------------------------------------------------
000D39r 3               ; Touched deadly block check.
000D39r 3               ; returns with DEADLY (must be non-zero) in accumulator if true.
000D39r 3               ;
000D39r 3               ; Input:
000D39r 3               ;  IX = sprite address
000D39r 3               ;
000D39r 3               ; Output:
000D39r 3               ;  A  = 0 is ok, A=5 is not ok
000D39r 3               ;--------------------------------------------------------------
000D39r 3               
000D39r 3               tded:
000D39r 3  A0 08        	ldy #8
000D3Br 3  B1 68        	lda (z80_ix),y 		; y coordinate.
000D3Dr 3  85 rr        	sta dispy
000D3Fr 3  C8           	iny
000D40r 3  B1 68        	lda (z80_ix),y 		; x coordinate.
000D42r 3  85 rr        	sta dispx		; coords in dispx,dispy.
000D44r 3  20 rr rr     	jsr tstbl		; get map address.
000D47r 3  48           	pha
000D48r 3  A9 1F        	lda #31			; default distance to next line down.
000D4Ar 3  85 64        	sta z80_e
000D4Cr 3  68           	pla
000D4Dr 3  C5 63        	cmp z80_b		; is this the required block?
000D4Fr 3  D0 01        	bne :+
000D51r 3  60           	rts			; yes.
000D52r 3               :
000D52r 3  E6 rr        	inc bufaddr 		; next cell.
000D54r 3  D0 02        	bne :+
000D56r 3  E6 rr        	inc bufaddr+1
000D58r 3               :
000D58r 3  A0 00        	ldy #0
000D5Ar 3  B1 rr        	lda (bufaddr),y		; fetch type.
000D5Cr 3  C5 63        	cmp z80_b 		; is this deadly/custom?
000D5Er 3  D0 01        	bne :+
000D60r 3  60           	rts			; yes.
000D61r 3               :
000D61r 3  A5 rr        	lda dispx		; horizontal position.
000D63r 3  85 62        	sta z80_c 		; store column in c register.
000D65r 3  29 07        	and #7			; is it straddling cells?
000D67r 3  D0 03        	bne :+
000D69r 3  4C rr rr     	jmp tded0		; no.
000D6Cr 3               :
000D6Cr 3  E6 rr        	inc bufaddr 		; last cell.
000D6Er 3  D0 02        	bne :+
000D70r 3  E6 rr        	inc bufaddr+1
000D72r 3               :
000D72r 3  A0 00        	ldy #0
000D74r 3  B1 rr        	lda (bufaddr),y 	; fetch type.
000D76r 3  C5 63        	cmp z80_b		; is this the block?
000D78r 3  D0 01        	bne :+
000D7Ar 3  60           	rts			; yes.
000D7Br 3               :
000D7Br 3  C6 64        	dec z80_e		; one less cell to next row down.
000D7Dr 3               tded0:
000D7Dr 3  18           	clc 			; point to next row.
000D7Er 3  A5 rr        	lda bufaddr
000D80r 3  65 64        	adc z80_e
000D82r 3  85 rr        	sta bufaddr
000D84r 3  90 02        	bcc :+
000D86r 3  E6 rr        	inc bufaddr+1
000D88r 3               :
000D88r 3  A0 00        	ldy #0
000D8Ar 3  B1 rr        	lda (bufaddr),y		; fetch left cell block.
000D8Cr 3  C5 63        	cmp z80_b		; is this fatal?
000D8Er 3  D0 01        	bne :+
000D90r 3  60           	rts			; yes.
000D91r 3               :
000D91r 3  E6 rr        	inc bufaddr 		; next cell.
000D93r 3  D0 02        	bne :+
000D95r 3  E6 rr        	inc bufaddr+1
000D97r 3               :
000D97r 3  A0 00        	ldy #0
000D99r 3  B1 rr        	lda (bufaddr),y 	; fetch type.
000D9Br 3  C5 63        	cmp z80_b		; is this fatal?
000D9Dr 3  D0 01        	bne :+
000D9Fr 3  60           	rts			; yes.
000DA0r 3               :
000DA0r 3  A5 62        	lda z80_c		; horizontal position.
000DA2r 3  29 07        	and #7			; is it straddling cells?
000DA4r 3  D0 03        	bne :+
000DA6r 3  4C rr rr     	jmp tded1 		; no.
000DA9r 3               :
000DA9r 3  E6 rr        	inc bufaddr		; last cell.
000DABr 3  D0 02        	bne :+
000DADr 3  E6 rr        	inc bufaddr+1
000DAFr 3               :
000DAFr 3  A0 00        	ldy #0
000DB1r 3  B1 rr        	lda (bufaddr),y		; fetch type.
000DB3r 3  C5 63        	cmp z80_b		; is this fatal?
000DB5r 3  D0 01        	bne :+
000DB7r 3  60           	rts			; yes.
000DB8r 3               :
000DB8r 3               tded1:
000DB8r 3  A5 rr        	lda dispy		; vertical position.
000DBAr 3  29 07        	and #7 			; is it straddling cells?
000DBCr 3  D0 01        	bne :+
000DBEr 3  60           	rts			; no, job done.
000DBFr 3               :
000DBFr 3  18           	clc			; point to next row.
000DC0r 3  A5 rr        	lda bufaddr
000DC2r 3  65 64        	adc z80_e
000DC4r 3  85 rr        	sta bufaddr
000DC6r 3  90 02        	bcc :+
000DC8r 3  E6 rr        	inc bufaddr+1
000DCAr 3               :
000DCAr 3  A0 00        	ldy #0
000DCCr 3  B1 rr        	lda (bufaddr),y 	; fetch left cell block.
000DCEr 3  C5 63        	cmp z80_b		; is this fatal?
000DD0r 3  D0 01        	bne :+
000DD2r 3  60           	rts			; yes.
000DD3r 3               :
000DD3r 3  E6 rr        	inc bufaddr		; next cell.
000DD5r 3  D0 02        	bne :+
000DD7r 3  E6 rr        	inc bufaddr+1
000DD9r 3               :
000DD9r 3  A0 00        	ldy #0
000DDBr 3  B1 rr        	lda (bufaddr),y 	; fetch type.
000DDDr 3  C5 63        	cmp z80_b		; is this fatal?
000DDFr 3  D0 01        	bne :+
000DE1r 3  60           	rts			; yes.
000DE2r 3               :
000DE2r 3  A5 62        	lda z80_c		; horizontal position.
000DE4r 3  29 07        	and #7			; is it straddling cells?
000DE6r 3  D0 01        	bne :+
000DE8r 3  60           	rts			; no.
000DE9r 3               :
000DE9r 3  E6 rr        	inc bufaddr		; last cell.
000DEBr 3  D0 02        	bne :+
000DEDr 3  E6 rr        	inc bufaddr+1
000DEFr 3               :
000DEFr 3  A0 00        	ldy #0
000DF1r 3  B1 rr        	lda (bufaddr),y		; fetch final type.
000DF3r 3  60           	rts 			; return with final type in accumulator.
000DF4r 3               
000DF4r 3               ;---------------------------------------------------
000DF4r 3               ; Fetch block type at (dispx, dispy).
000DF4r 3               ;
000DF4r 3               ; Output:
000DF4r 3               ;  A = block type
000DF4r 3               ;---------------------------------------------------
000DF4r 3               
000DF4r 3               tstbl:
000DF4r 3  A5 rr        	lda dispy 		; fetch y coord.
000DF6r 3  4A           	lsr a			; bufaddr = y/8
000DF7r 3  4A           	lsr a
000DF8r 3  4A           	lsr a
000DF9r 3  85 rr        	sta chary
000DFBr 3               
000DFBr 3  85 rr        	sta bufaddr
000DFDr 3  A9 00        	lda #0
000DFFr 3  85 rr        	sta bufaddr+1
000E01r 3               
000E01r 3  06 rr        	asl bufaddr  		; bufaddr = y/8 * 32
000E03r 3  26 rr        	rol bufaddr+1
000E05r 3  06 rr        	asl bufaddr
000E07r 3  26 rr        	rol bufaddr+1
000E09r 3  06 rr        	asl bufaddr
000E0Br 3  26 rr        	rol bufaddr+1
000E0Dr 3  06 rr        	asl bufaddr
000E0Fr 3  26 rr        	rol bufaddr+1
000E11r 3  06 rr        	asl bufaddr
000E13r 3  26 rr        	rol bufaddr+1
000E15r 3               
000E15r 3  A5 rr        	lda dispx		; x/8
000E17r 3  4A           	lsr a
000E18r 3  4A           	lsr a
000E19r 3  4A           	lsr a
000E1Ar 3  85 rr        	sta charx
000E1Cr 3               
000E1Cr 3  18           	clc			; bufaddr = MAP + x/8 + y/8*32
000E1Dr 3  65 rr        	adc bufaddr
000E1Fr 3  69 00        	adc #<MAP
000E21r 3  85 rr        	sta bufaddr
000E23r 3  A5 rr        	lda bufaddr+1
000E25r 3  69 04        	adc #>MAP
000E27r 3  85 rr        	sta bufaddr+1
000E29r 3               
000E29r 3  A0 00        	ldy #0
000E2Br 3  B1 rr        	lda (bufaddr),y 	; fetch byte there.
000E2Dr 3  60           	rts
000E2Er 3               
000E2Er 3               
000E2Er 3               ;-------------------------------------------------------------------
000E2Er 3               ; Jump - if we can.
000E2Er 3               ; Requires initial speed to be set up in accumulator prior to call.
000E2Er 3               ;
000E2Er 3               ; Input:
000E2Er 3               ;  IX = sprite address
000E2Er 3               ;-------------------------------------------------------------------
000E2Er 3               
000E2Er 3  49 FF        jump: 	eor #$ff	; jump   neg                 ; switch sign so we jump up.
000E30r 3  18           	clc
000E31r 3  69 01        	adc #1
000E33r 3  85 62        	sta z80_c	;        ld c,a              ; store in c register.
000E35r 3  A0 0D        jump0:	ldy #13		; jump0  ld a,(ix+13)        ; jumping flag.
000E37r 3  B1 68        	lda (z80_ix),y
000E39r 3               			;        and a               ; is it set?
000E39r 3  F0 01        	beq :+
000E3Br 3  60           	rts		;        ret nz              ; already in the air.
000E3Cr 3               :
000E3Cr 3  18           	clc
000E3Dr 3  69 01        	adc #1		;        inc (ix+13)         ; set it.
000E3Fr 3  91 68        	sta (z80_ix),y
000E41r 3  A5 62        	lda z80_c	;        ld (ix+14),c        ; set jump height.
000E43r 3  C8           	iny
000E44r 3  91 68        	sta (z80_ix),y
000E46r 3  60           	rts		;        ret
000E47r 3               
000E47r 3  A0 0D        hop:	ldy #13		; hop    ld a,(ix+13)        ; jumping flag.
000E49r 3  B1 68        	lda (z80_ix),y
000E4Br 3               			;        and a               ; is it set?
000E4Br 3  F0 01        	beq :+
000E4Dr 3  60           	rts		;        ret nz              ; already in the air.
000E4Er 3  A9 FF        :	lda #255	;        ld (ix+13),255      ; set it.
000E50r 3  91 68        	sta (z80_ix),y
000E52r 3  A9 00        	lda #0
000E54r 3  C8           	iny		;        ld (ix+14),0        ; set jump table displacement.
000E55r 3  91 68        	sta (z80_ix),y
000E57r 3  60           	rts		;        ret
000E58r 3               
000E58r 3               ;------------------------------------------------
000E58r 3               ; Random numbers code.
000E58r 3               ; Pseudo-random number generator, 8-bit.
000E58r 3               ;
000E58r 3               ; Output:
000E58r 3               ;  RND = random number
000E58r 3               ;------------------------------------------------
000E58r 3               
000E58r 3               random:
000E58r 3  A5 rr        	lda seed
000E5Ar 3  F0 05        	beq doEor
000E5Cr 3  0A           	asl a
000E5Dr 3  F0 04        	beq noEor
000E5Fr 3  90 02        	bcc noEor
000E61r 3  49 1D        doEor:	eor #$1d
000E63r 3  85 rr        noEor:	sta seed
000E65r 3  60           	rts
000E66r 3               
000E66r 3  A5 rr        	lda seed		; get last random number.
000E68r 3  0A           	asl a
000E69r 3  0A           	asl a
000E6Ar 3  18           	clc
000E6Br 3  65 rr        	adc seed
000E6Dr 3  18           	clc
000E6Er 3  69 45        	adc #$45
000E70r 3  85 rr        	sta seed		; store new seed.
000E72r 3  85 rr        	sta varrnd		; return number in variable.
000E74r 3  60           	rts
000E75r 3               
000E75r 3               ;-------------------------------------------------------
000E75r 3               ; Joystick and keyboard reading routines.
000E75r 3               ;
000E75r 3               ; contrl = 0, Keyboard
000E75r 3               ;          1, JoyKeyb
000E75r 3               ;          2, JoyMMC
000E75r 3               ;
000E75r 3               ;      joyval=x65FUDLR (bit cleared if key pressed)
000E75r 3               ;             ||||||||
000E75r 3               ;             |||||||+> Right    KEY 0  - X
000E75r 3               ;             ||||||+-> Left     KEY 1  - Z
000E75r 3               ;             |||||+--> Down     KEY 2  - .
000E75r 3               ;             ||||+---> Up       KEY 3  - ;
000E75r 3               ;             |||+----> Fire1    KEY 4  - SPC
000E75r 3               ;             ||+-----> Fire2    KEY 5  - Q
000E75r 3               ;             |+------> Fire3    KEY 6  - P
000E75r 3               ;             +-------> Not used
000E75r 3               ;
000E75r 3               ;                       Option1  KEY 7  - 1
000E75r 3               ;                       Option2  KEY 8  - 2
000E75r 3               ;                       Option3  KEY 9  - 3
000E75r 3               ;                       Option4  KEY 10 - 4
000E75r 3               ;-------------------------------------------------------
000E75r 3               
000E75r 3               joykey:
000E75r 3  A5 rr        	lda contrl 		; control flag.
000E77r 3  C9 01        	cmp #1
000E79r 3  F0 1A        	beq joy1 		; scan joystick1
000E7Br 3  C9 02        	cmp #2
000E7Dr 3  F0 1C        	beq joy2 		; scan joystick2
000E7Fr 3               
000E7Fr 3               ; Scan keyboard
000E7Fr 3               
000E7Fr 3  A9 00        	lda #0		 	; zero reading.
000E81r 3  85 64        	sta z80_e
000E83r 3               
000E83r 3  A0 06        	ldy #6	 		; address of last key.
000E85r 3               joyke0:
000E85r 3  B9 rr rr     	lda keys,y 		; get key from table.
000E88r 3  20 rr rr     	jsr ktest		; being pressed?
000E8Br 3  26 64        	rol z80_e 		; rotate into reading.
000E8Dr 3               
000E8Dr 3  88           	dey		 	; next key.
000E8Er 3  10 F5        	bpl joyke0 		; repeat for all keys.
000E90r 3               joyret:
000E90r 3  A5 64        	lda z80_e
000E92r 3  85 rr        	sta joyval
000E94r 3  60           	rts
000E95r 3               
000E95r 3               ; Scan joystick 1
000E95r 3               
000E95r 3               joy1:
000E95r 3  20 rr rr     	jsr joy1scan
000E98r 3  4C rr rr     	jmp joyret 		; store the value.
000E9Br 3               
000E9Br 3               ; Scan joystick 2
000E9Br 3               
000E9Br 3               joy2:
000E9Br 3  20 rr rr     	jsr joy2scan
000E9Er 3  4C rr rr     	jmp joyret 		; store the value.
000EA1r 3               
000EA1r 3               ;---------------------------------------------------------------
000EA1r 3               ; Getkey in column,row format
000EA1r 3               ;
000EA1r 3               ; Output:
000EA1r 3               ;  A = high nibble=row and low nibble=column key in matrix
000EA1r 3               ;---------------------------------------------------------------
000EA1r 3               
000EA1r 3               kget:
000EA1r 3  A9 F0        	lda #ScrMode		; high-mono mode.
000EA3r 3  8D 00 B0     	sta ScrSelAddr		; screen select port
000EA6r 3  86 rr        	stx xtmp
000EA8r 3               kget4:
000EA8r 3  20 rr rr     	jsr READKEY		; read key until pressed
000EABr 3  C0 FF        	cpy #255
000EADr 3  F0 F9        	beq kget4
000EAFr 3  85 rr        	sta rcol		; save column
000EB1r 3  86 rr        	stx rrow		; determine row
000EB3r 3               kget3:
000EB3r 3  20 rr rr     	jsr READKEY		; wait until key released
000EB6r 3  C0 FF        	cpy #255
000EB8r 3  D0 F9        	bne kget3
000EBAr 3               
000EBAr 3  38           	sec			; calculate matrix row
000EBBr 3  A9 0A        	lda #10
000EBDr 3  E5 rr        	sbc rrow
000EBFr 3  0A           	asl a
000EC0r 3  0A           	asl a
000EC1r 3  0A           	asl a
000EC2r 3  0A           	asl a
000EC3r 3  85 rr        	sta rrow
000EC5r 3               
000EC5r 3  A0 FF        	ldy #255		; find column mask
000EC7r 3               kget1:
000EC7r 3  C8           	iny
000EC8r 3  B9 rr rr     	lda keymask,y
000ECBr 3  C5 rr        	cmp rcol
000ECDr 3  F0 03        	beq kget2
000ECFr 3  4C rr rr     	jmp kget1
000ED2r 3               kget2:
000ED2r 3  98           	tya			; determine column
000ED3r 3  18           	clc
000ED4r 3  65 rr        	adc rrow
000ED6r 3  A6 rr        	ldx xtmp
000ED8r 3  60           	rts
000ED9r 3               
000ED9r 3               ;---------------------------------------------------------------
000ED9r 3               ; Display message.
000ED9r 3               ;
000ED9r 3               ; Input:
000ED9r 3               ;  A = message number
000ED9r 3               ;---------------------------------------------------------------
000ED9r 3               
000ED9r 3               dmsg:
000ED9r 3  AA           	tax
000EDAr 3  A9 rr        	lda #<msgdat		; pointer to messages.
000EDCr 3  85 66        	sta z80_l
000EDEr 3  A9 rr        	lda #>msgdat
000EE0r 3  85 67        	sta z80_h
000EE2r 3  20 rr rr     	jsr getwrd		; get message number.
000EE5r 3               dmsg3:
000EE5r 3  20 rr rr     	jsr preprt		; pre-printing stuff.
000EE8r 3  20 rr rr     	jsr checkx		; make sure we"re in a printable range.
000EEBr 3               .if bigflag
000EEBr 3               	lda prtmod		; print mode.
000EEBr 3               	bne bmsg1		; no, double-height text.
000EEBr 3               .endif
000EEBr 3               dmsg0:
000EEBr 3  A5 67        	lda z80_h		; store string pointer.
000EEDr 3  48           	pha
000EEEr 3  A5 66        	lda z80_l
000EF0r 3  48           	pha
000EF1r 3               
000EF1r 3  A0 00        	ldy #0
000EF3r 3  B1 66        	lda (z80_hl),y		; fetch byte to display.
000EF5r 3  29 7F        	and #127		; remove any end marker.
000EF7r 3  C9 0D        	cmp #13
000EF9r 3  F0 24        	beq dmsg1
000EFBr 3  20 rr rr     	jsr pchar		; display character.
000EFEr 3  20 rr rr     	jsr nexpos 		; display position.
000F01r 3  D0 03        	bne dmsg2		; not on a new line.
000F03r 3  20 rr rr     	jsr nexlin		; next line down.
000F06r 3               dmsg2:
000F06r 3  68           	pla			; retrieve string pointer
000F07r 3  85 66        	sta z80_l
000F09r 3  68           	pla
000F0Ar 3  85 67        	sta z80_h
000F0Cr 3               
000F0Cr 3  A0 00        	ldy #0
000F0Er 3  B1 66        	lda (z80_hl),y		; fetch last character.
000F10r 3  0A           	asl a  			; was it the end?
000F11r 3  90 03        	bcc :+
000F13r 3  4C rr rr     	jmp dscor2		; yes, job done.
000F16r 3               :
000F16r 3  E6 66        	inc z80_l		; next character to display.
000F18r 3  D0 02        	bne :+
000F1Ar 3  E6 67        	inc z80_h
000F1Cr 3               :
000F1Cr 3  4C rr rr     	jmp dmsg0
000F1Fr 3               dmsg1:
000F1Fr 3  E6 rr        	inc dispy
000F21r 3  A5 rr        	lda dispy
000F23r 3  C9 18        	cmp #24
000F25r 3  90 04        	bcc dmsg4
000F27r 3  A9 00        	lda #0
000F29r 3  85 rr        	sta dispy
000F2Br 3               dmsg4:
000F2Br 3  A9 00        	lda #0
000F2Dr 3  85 rr        	sta dispx
000F2Fr 3  4C rr rr     	jmp dmsg2
000F32r 3               
000F32r 3               ;prtmod:	.byte 0            	; print mode, 0 = standard, 1 = double-height.
000F32r 3               
000F32r 3               ;----------------------------------------------------------
000F32r 3               ; Display message in big text.
000F32r 3               ;
000F32r 3               ; Input:
000F32r 3               ;  HL = string pointer
000F32r 3               ;----------------------------------------------------------
000F32r 3               
000F32r 3               .if bigflag
000F32r 3               bmsg1:
000F32r 3               	ldy #0
000F32r 3               	lda (z80_hl),y 		; get character to display.
000F32r 3               	and #127		; only want 7 bits.
000F32r 3               	cmp #13
000F32r 3               	beq bmsg2
000F32r 3               	jsr bchar 		; display big char.
000F32r 3               bmsg3:
000F32r 3               	ldy #0
000F32r 3               	lda (z80_hl),y 		; look at last character.
000F32r 3               	pha
000F32r 3               	inc z80_l 		; next character in list.
000F32r 3               	bne :+
000F32r 3               	inc z80_h
000F32r 3               :
000F32r 3               	pla
000F32r 3               	asl a  			; was terminator flag set?
000F32r 3               	bcc bmsg1		; no, keep going.
000F32r 3               	rts
000F32r 3               bmsg2:
000F32r 3               	lda #0
000F32r 3               	sta dispx
000F32r 3               	inc dispy
000F32r 3               	inc dispy
000F32r 3               	lda dispy
000F32r 3               	cmp #23
000F32r 3               	bcc bmsg3
000F32r 3               	lda #0
000F32r 3               	sta dispy
000F32r 3               	jmp bmsg3
000F32r 3               .endif
000F32r 3               
000F32r 3               ;----------------------------------------------------------
000F32r 3               ; Big character display.
000F32r 3               ;
000F32r 3               ; Input:
000F32r 3               ;  A = character
000F32r 3               ;----------------------------------------------------------
000F32r 3               
000F32r 3               .if bigflag
000F32r 3               bchar:
000F32r 3               	sta z80_e		; save char in lb
000F32r 3               	lda #0
000F32r 3               	sta z80_d		; reset hb
000F32r 3               
000F32r 3               	asl z80_e 		; multiply char by 8.
000F32r 3               	rol z80_d
000F32r 3               	asl z80_e
000F32r 3               	rol z80_d
000F32r 3               	asl z80_e
000F32r 3               	rol z80_d		; de = a*8
000F32r 3               
000F32r 3               	clc			; de = fontpointer + a*8
000F32r 3               	lda z80_e
000F32r 3               	adc #<(font-256) 		; address of font.
000F32r 3               	sta z80_e
000F32r 3               	lda z80_d
000F32r 3               	adc #>(font-256)
000F32r 3               	sta z80_d
000F32r 3               
000F32r 3               	jsr gprad 		; get screen address.
000F32r 3               
000F32r 3               	ldx #0			; height of character in font.
000F32r 3               bchar0:
000F32r 3               	ldy #0
000F32r 3               	lda (z80_de),y 		; get a bit of the font.
000F32r 3               
000F32r 3               .if gflag
000F32r 3               	and andeor
000F32r 3               	eor andeor+1
000F32r 3               .endif
000F32r 3               .if iflag
000F32r 3               	eor #$ff
000F32r 3               .endif
000F32r 3               
000F32r 3               	sta (scraddr),y
000F32r 3               	pha
000F32r 3               	jsr nline 		; next line down.
000F32r 3               	pla
000F32r 3               	sta (scraddr),y
000F32r 3               	jsr nline 		; next line down.
000F32r 3               
000F32r 3               	clc
000F32r 3               	inc z80_e 		; next line of font.
000F32r 3               	bne :+
000F32r 3               	inc z80_d
000F32r 3               :
000F32r 3               	inx
000F32r 3               	cpx #8
000F32r 3               	bne bchar0
000F32r 3               
000F32r 3               	jsr nexpos		; display position.
000F32r 3               	bne bchar2 		; not on a new line.
000F32r 3               .endif
000F32r 3               bchar3:
000F32r 3  E6 rr        	inc dispy
000F34r 3  20 rr rr     	jsr nexlin 		; next line check.
000F37r 3               bchar2:
000F37r 3  4C rr rr     	jmp dscor2		; tidy up line and column variables.
000F3Ar 3               
000F3Ar 3               ;-------------------------------------------------
000F3Ar 3               ; Display a character.
000F3Ar 3               ;
000F3Ar 3               ; Input:
000F3Ar 3               ;  A = character
000F3Ar 3               ;-------------------------------------------------
000F3Ar 3               
000F3Ar 3               achar:
000F3Ar 3  85 63        	sta z80_b 		; copy to b.
000F3Cr 3  20 rr rr     	jsr preprt 		; get ready to print.
000F3Fr 3  A5 63        	lda z80_b		; character in accumulator.
000F41r 3               .if bigflag
000F41r 3               	ldx prtmod 		; print mode.
000F41r 3               	beq :+
000F41r 3               	jmp bchar 		; no, double-height text.
000F41r 3               :
000F41r 3               .endif
000F41r 3  20 rr rr     	jsr pchar 		; display character.
000F44r 3  20 rr rr     	jsr nexpos 		; display position.
000F47r 3  F0 E9        	beq bchar3		; next line down.
000F49r 3  4C rr rr     	jmp bchar2 		; tidy up.
000F4Cr 3               
000F4Cr 3               
000F4Cr 3               ;--------------------------------------------------------
000F4Cr 3               ; Pre-print preliminaries.
000F4Cr 3               ;--------------------------------------------------------
000F4Cr 3               
000F4Cr 3               preprt:
000F4Cr 3  A9 rr        	lda #<(font-256)	; font pointer.
000F4Er 3  8D rr rr     	sta grbase		; set up graphics base.
000F51r 3  A9 rr        	lda #>(font-256)
000F53r 3  8D rr rr     	sta grbase+1
000F56r 3               prescr:
000F56r 3  A5 rr        	lda charx 		; display coordinates.
000F58r 3  85 rr        	sta dispx		; set up general coordinates.
000F5Ar 3  A5 rr        	lda chary
000F5Cr 3  85 rr        	sta dispy
000F5Er 3  60           	rts
000F5Fr 3               
000F5Fr 3               ;-----------------------------------------
000F5Fr 3               ; Calculate old sprite address
000F5Fr 3               ;
000F5Fr 3               ; Input:
000F5Fr 3               ;  IX = sprite address
000F5Fr 3               ;
000F5Fr 3               ; Output:
000F5Fr 3               ;  B  = right byte mask
000F5Fr 3               ;  C  = left byte mask
000F5Fr 3               ;  DE = spriteframe address
000F5Fr 3               ;  scraddr = screenaddress(dispx,dispy)
000F5Fr 3               ;-----------------------------------------
000F5Fr 3               
000F5Fr 3               gsprad:
000F5Fr 3  A0 03        	ldy #3
000F61r 3  B1 68        	lda (z80_ix),y		; y coordinate.
000F63r 3  85 rr        	sta dispy
000F65r 3  A0 04        	ldy #4
000F67r 3  B1 68        	lda (z80_ix),y		; x coordinate.
000F69r 3  85 rr        	sta dispx
000F6Br 3  A0 01        	ldy #1
000F6Dr 3  B1 68        	lda (z80_ix),y 		; sprite image.
000F6Fr 3  20 rr rr     	jsr gfrm 		; fetch start frame for this sprite.
000F72r 3               
000F72r 3  A0 00        	ldy #0
000F74r 3  B1 66        	lda (z80_hl),y 		; frame in accumulator.
000F76r 3  A0 02        	ldy #2
000F78r 3  18           	clc
000F79r 3  71 68        	adc (z80_ix),y 		; add frame number.
000F7Br 3               gspra0:
000F7Br 3               .if rflag
000F7Br 3               	sta z80_e		; multiply by 32.
000F7Br 3               	lda #0
000F7Br 3               	sta z80_d
000F7Br 3               
000F7Br 3               	asl z80_e
000F7Br 3               	rol z80_d
000F7Br 3               	asl z80_e
000F7Br 3               	rol z80_d
000F7Br 3               	asl z80_e
000F7Br 3               	rol z80_d
000F7Br 3               	asl z80_e
000F7Br 3               	rol z80_d
000F7Br 3               .if bflag
000F7Br 3               	lda z80_e		; multiply by 48
000F7Br 3               	sta tmp1
000F7Br 3               	lda z80_d
000F7Br 3               	sta tmp2
000F7Br 3               .endif
000F7Br 3               	asl z80_e
000F7Br 3               	rol z80_d
000F7Br 3               .if bflag
000F7Br 3               	clc
000F7Br 3               	lda z80_e
000F7Br 3               	adc tmp1
000F7Br 3               	sta z80_e
000F7Br 3               	lda z80_d
000F7Br 3               	adc tmp2
000F7Br 3               	sta z80_d
000F7Br 3               .endif
000F7Br 3               .else
000F7Br 3  4A           	lsr a	  		; multiply by 128.
000F7Cr 3  85 65        	sta z80_d 		; store in d.
000F7Er 3  8D rr rr     	sta tmp1
000F81r 3  A9 00        	lda #0
000F83r 3  6A           	ror a
000F84r 3  85 64        	sta z80_e 		; got low byte.
000F86r 3  8D rr rr     	sta tmp2
000F89r 3               .if bflag
000F89r 3               	lsr tmp1
000F89r 3               	ror tmp2
000F89r 3               	clc
000F89r 3               	lda tmp2
000F89r 3               	adc z80_e
000F89r 3               	sta z80_e
000F89r 3               	lda tmp1
000F89r 3               	adc z80_d
000F89r 3               	sta z80_d
000F89r 3               .endif
000F89r 3               .endif
000F89r 3  18           	clc 			; address of play sprites.
000F8Ar 3  A5 64        	lda z80_e
000F8Cr 3  69 rr        	adc #<sprgfx
000F8Er 3  85 64        	sta z80_e
000F90r 3  A5 65        	lda z80_d
000F92r 3  69 rr        	adc #>sprgfx
000F94r 3  85 65        	sta z80_d
000F96r 3               
000F96r 3  A5 rr        	lda dispx 		; y coordinate.
000F98r 3  29 06        	and #6 			; position within byte boundary.
000F9Ar 3  AA           	tax	 		; low byte of table displacement.
000F9Br 3               
000F9Br 3               .if rflag
000F9Br 3               	stx sprshft
000F9Br 3               .else
000F9Br 3  0A           	asl a	  		; multiply by 32.
000F9Cr 3  0A           	asl a  			; already a multiple
000F9Dr 3  0A           	asl a  			; of 2, so just 4
000F9Er 3               .if bflag
000F9Er 3               	sta tmp1
000F9Er 3               	asl a  			; shifts needed.
000F9Er 3               	clc
000F9Er 3               	adc tmp1
000F9Er 3               .else
000F9Er 3  0A           	asl a  			; shifts needed.
000F9Fr 3               .endif
000F9Fr 3  18           	clc 			; add to sprite address.
000FA0r 3  65 64        	adc z80_e
000FA2r 3  85 64        	sta z80_e
000FA4r 3  90 02        	bcc :+
000FA6r 3  E6 65        	inc z80_d
000FA8r 3               :
000FA8r 3               .endif
000FA8r 3  BD rr rr     	lda spmask,x		 ; pointer to mask table.
000FABr 3  85 62        	sta z80_c 		; left mask.
000FADr 3  BD rr rr     	lda spmask+1,x
000FB0r 3  85 63        	sta z80_b 		; right mask.
000FB2r 3               
000FB2r 3               ;------------------------------------------------------------------
000FB2r 3               ; Drop into screen address routine.
000FB2r 3               ; This routine returns a screen address for (dispx, dispy) in scraddr.
000FB2r 3               ;------------------------------------------------------------------
000FB2r 3               
000FB2r 3               scadd:
000FB2r 3  A6 rr        	ldx dispy
000FB4r 3  E0 C0        	cpx #192
000FB6r 3  90 02        	bcc :+
000FB8r 3  A2 C0        	ldx #192
000FBAr 3               :
000FBAr 3  A5 rr        	lda dispx
000FBCr 3  4A           	lsr a
000FBDr 3  4A           	lsr a
000FBEr 3  4A           	lsr a
000FBFr 3  18           	clc
000FC0r 3  7D 00 07     	adc SCROFF_lb,x
000FC3r 3  85 rr        	sta scraddr
000FC5r 3  BD 18 07     	lda SCROFF_hb,x
000FC8r 3  85 rr        	sta scraddr+1
000FCAr 3  60           	rts
000FCBr 3               
000FCBr 3  FF 00        spmask:	.byte $ff,$00
000FCDr 3  3F C0        	.byte $3f,$c0
000FCFr 3  0F F0        	.byte $0f,$f0
000FD1r 3  03 FC        	.byte $03,$fc
000FD3r 3               
000FD3r 3  00           tmp1:	.byte 0
000FD4r 3  00           tmp2:	.byte 0
000FD5r 3               
000FD5r 3               ;-----------------------------------------------------------------
000FD5r 3               ; These are the sprite routines.
000FD5r 3               ; sspria = single sprite, old (ix).
000FD5r 3               ; ssprib = single sprite, new (ix+5).
000FD5r 3               ; sspric = both sprites, old (ix) and new (ix+5).
000FD5r 3               ;-----------------------------------------------------------------
000FD5r 3               
000FD5r 3               sspria:
000FD5r 3  60           	rts
000FD6r 3               
000FD6r 3  20 rr rr     	jsr gsprad		; get old sprite address.
000FD9r 3               sspri2:
000FD9r 3               .if rflag
000FD9r 3               	lda z80_e				; 3c
000FD9r 3               	sta dline_spraddr1+1	; 4c
000FD9r 3               	sta dline_spraddr2+1	; 4c
000FD9r 3               	lda z80_d				; 3c
000FD9r 3               	sta dline_spraddr1+2	; 4c
000FD9r 3               	sta dline_spraddr2+2	; 4c
000FD9r 3               
000FD9r 3               	ldx sprshft
000FD9r 3               	lda shift_table,x
000FD9r 3               	sta dline_shift1+1
000FD9r 3               	sta dline_shift2+1
000FD9r 3               	lda shift_table+1,x
000FD9r 3               	sta dline_shift1+2
000FD9r 3               	sta dline_shift2+2
000FD9r 3               .else
000FD9r 3  A5 64        	lda z80_e
000FDBr 3  8D rr rr     	sta dline1+1		; Set spritedata address
000FDEr 3  8D rr rr     	sta dline2+1
000FE1r 3  A5 65        	lda z80_d
000FE3r 3  8D rr rr     	sta dline1+2
000FE6r 3  8D rr rr     	sta dline2+2
000FE9r 3               .endif
000FE9r 3  86 rr        	stx xtmp
000FEBr 3  A2 00        	ldx #0			; vertical lines.
000FEDr 3               sspri0:
000FEDr 3  20 rr rr     	jsr dline		; draw a line.
000FF0r 3  E0 10        	cpx #16			; detect block boundery
000FF2r 3  D0 02        	bne :+			; skip if not
000FF4r 3  E6 rr        	inc scraddr+1		; jump to next blockline
000FF6r 3               :
000FF6r 3  E0 20        	cpx #32			; check finished
000FF8r 3               .if bflag
000FF8r 3               	bne :+			; skip if not
000FF8r 3               	inc scraddr+1		; jump to next blockline
000FF8r 3               	inc z80_hlp+1		; jump to next blockline
000FF8r 3               :
000FF8r 3               	cpx #48			; check finished
000FF8r 3               .endif
000FF8r 3  D0 F3        	bne sspri0		; no, repeat
000FFAr 3  A6 rr        	ldx xtmp
000FFCr 3  60           	rts
000FFDr 3               
000FFDr 3               ;-----------------------------------------------------------------
000FFDr 3               
000FFDr 3               ssprib:
000FFDr 3  20 rr rr     	jsr gspran 		; get new sprite address.
001000r 3  4C rr rr     	jmp sspri2
001003r 3               
001003r 3               ;-----------------------------------------------------------------
001003r 3               
001003r 3               sspric:
001003r 3               .if rflag
001003r 3               	jsr gsprad 		; get old sprite address.
001003r 3               
001003r 3               	lda z80_e				; 3c
001003r 3               	sta ddline_spraddr1+1	; 4c
001003r 3               	sta ddline_spraddr2+1	; 4c
001003r 3               
001003r 3               	lda z80_d				; 3c
001003r 3               	sta ddline_spraddr1+2	; 4c
001003r 3               	sta ddline_spraddr2+2	; 4c
001003r 3               
001003r 3               	ldx sprshft
001003r 3               	lda shift_table,x
001003r 3               	sta ddline_shift1+1
001003r 3               	sta ddline_shift2+1
001003r 3               	lda shift_table+1,x
001003r 3               	sta ddline_shift1+2
001003r 3               	sta ddline_shift2+2
001003r 3               
001003r 3               	jsr exx  		; store addresses.
001003r 3               	jsr gspran 		; get new sprite addresses.
001003r 3               
001003r 3               	lda z80_e				; 3c
001003r 3               	sta dline_spraddr1+1	; 4c
001003r 3               	sta dline_spraddr2+1	; 4c
001003r 3               
001003r 3               	lda z80_d				; 3c
001003r 3               	sta dline_spraddr1+2	; 4c
001003r 3               	sta dline_spraddr2+2	; 4c
001003r 3               
001003r 3               	ldx sprshft
001003r 3               	lda shift_table,x
001003r 3               	sta dline_shift1+1
001003r 3               	sta dline_shift2+1
001003r 3               	lda shift_table+1,x
001003r 3               	sta dline_shift1+2
001003r 3               	sta dline_shift2+2
001003r 3               .else
001003r 3  20 rr rr     	jsr gsprad 		; get old sprite address.
001006r 3  A5 64        	lda z80_e
001008r 3  8D rr rr     	sta ddline1+1		; Set spritedata address
00100Br 3  8D rr rr     	sta ddline2+1
00100Er 3  A5 65        	lda z80_d
001010r 3  8D rr rr     	sta ddline1+2
001013r 3  8D rr rr     	sta ddline2+2
001016r 3  20 rr rr     	jsr exx  		; store addresses.
001019r 3               
001019r 3  20 rr rr     	jsr gspran 		; get new sprite addresses.
00101Cr 3  A5 64        	lda z80_e
00101Er 3  8D rr rr     	sta dline1+1		; Set spritedata address
001021r 3  8D rr rr     	sta dline2+1
001024r 3  A5 65        	lda z80_d
001026r 3  8D rr rr     	sta dline1+2
001029r 3  8D rr rr     	sta dline2+2
00102Cr 3               .endif
00102Cr 3  86 rr        	stx xtmp
00102Er 3  A2 00        	ldx #0			; vertical lines.
001030r 3               lloop:
001030r 3  20 rr rr     	jsr dline 		; draw a line.
001033r 3  CA           	dex
001034r 3  CA           	dex
001035r 3  20 rr rr     	jsr ddline 		; delete a line.
001038r 3  E0 10        	cpx #16			; detect block boundery
00103Ar 3  D0 04        	bne :+			; skip if not
00103Cr 3  E6 rr        	inc scraddr+1		; jump to next blockline
00103Er 3  E6 73        	inc z80_hlp+1		; jump to next blockline
001040r 3               :
001040r 3  E0 20        	cpx #32			; check finished
001042r 3               .if bflag
001042r 3               	bne :+			; skip if not
001042r 3               	inc scraddr+1		; jump to next blockline
001042r 3               	inc z80_hlp+1		; jump to next blockline
001042r 3               :
001042r 3               	cpx #48			; check finished
001042r 3               .endif
001042r 3  D0 EC        	bne lloop		; no, repeat
001044r 3  A6 rr        	ldx xtmp
001046r 3  60           	rts
001047r 3               
001047r 3               
001047r 3               ;-----------------------------------------------------------------
001047r 3               
001047r 3               
001047r 3               .if rflag
001047r 3               
001047r 3               ; Left screen byte
001047r 3               
001047r 3               dline:
001047r 3               dline_spraddr1:
001047r 3               	ldy objdta,x		; fetch spriteleft byte
001047r 3               dline_shift1:
001047r 3               	lda $ffff,y		; get pre-shifted byte
001047r 3               	sta z80_a		; save spriteleft byte
001047r 3               	and z80_c		; mask left
001047r 3               	ldy sprline,x		; point to screenbyteleft
001047r 3               	eor (scraddr),y		; merge with spriteleft
001047r 3               	sta (scraddr),y		; write screenleft
001047r 3               
001047r 3               	lda z80_a		; fetch data
001047r 3               	and z80_b		; mask unwanted
001047r 3               	sta z80_a		; store data
001047r 3               
001047r 3               ; Middle screen byte
001047r 3               
001047r 3               	inx			; next spritebyte
001047r 3               dline_spraddr2:
001047r 3               	ldy objdta,x		; fetch spriteright byte
001047r 3               dline_shift2:
001047r 3               	lda $ffff,y		; get pre-shifted byte
001047r 3               	sta z80_f		; save spriteright byte
001047r 3               	and z80_c		; mask away what's not needed.
001047r 3               	ora z80_a		; merge with mask
001047r 3               	ldy sprline,x
001047r 3               	eor (scraddr),y		; merge with screenmiddle
001047r 3               	sta (scraddr),y		; write screenmiddle
001047r 3               
001047r 3               ; Right screen byte
001047r 3               
001047r 3               	iny			; point to screenright
001047r 3               	lda z80_f		; get
001047r 3               	and z80_b		; mask right
001047r 3               	eor (scraddr),y		; merge with screenright
001047r 3               	sta (scraddr),y		; write screenright
001047r 3               	inx			; next spritebyte
001047r 3               
001047r 3               	rts
001047r 3               
001047r 3               ;-----------------------------------------------------------------
001047r 3               
001047r 3               ; Left screen byte
001047r 3               
001047r 3               ddline:
001047r 3               ddline_spraddr1:
001047r 3               	ldy objdta,x		; point to screenleft
001047r 3               ddline_shift1:
001047r 3               	lda $ffff,y		; fetch spriteleft byte
001047r 3               	sta z80_a		; save spriteright byte
001047r 3               	and z80_cp		; mask left
001047r 3               	ldy sprline,x		; point to byteleft
001047r 3               	eor (z80_hlp),y		; merge with screenleft
001047r 3               	sta (z80_hlp),y		; write screenleft
001047r 3               
001047r 3               	lda z80_a		; fetch data
001047r 3               	and z80_bp		; mask unwanted
001047r 3               	sta z80_a		; store data
001047r 3               
001047r 3               ; Middle screen byte
001047r 3               
001047r 3               	inx			; next spritebyte
001047r 3               ddline_spraddr2:
001047r 3               	ldy objdta,x
001047r 3               ddline_shift2:
001047r 3               	lda $ffff,y		; fetch spritemiddle byte
001047r 3               	sta z80_f		; save spriteright byte
001047r 3               	and z80_cp		; mask away what's not needed.
001047r 3               	ora z80_a		; merge with mask
001047r 3               	ldy sprline,x
001047r 3               	eor (z80_hlp),y		; merge with screenmiddle
001047r 3               	sta (z80_hlp),y		; write screenmiddle
001047r 3               
001047r 3               ; Right screen byte
001047r 3               
001047r 3               	iny			; point to screenright
001047r 3               	lda z80_f		; fetch spriteright byte
001047r 3               	and z80_bp		; mask right
001047r 3               	eor (z80_hlp),y		; merge with screenright
001047r 3               	sta (z80_hlp),y		; write screenright
001047r 3               	inx			; next spritebyte
001047r 3               
001047r 3               	rts
001047r 3               
001047r 3               sprline:
001047r 3               	.byte $00,$01,$20,$21,$40,$41,$60,$61
001047r 3               	.byte $80,$81,$a0,$a1,$c0,$c1,$e0,$e1
001047r 3               	.byte $00,$01,$20,$21,$40,$41,$60,$61
001047r 3               	.byte $80,$81,$a0,$a1,$c0,$c1,$e0,$e1
001047r 3               .if bflag
001047r 3               	.byte $00,$01,$20,$21,$40,$41,$60,$61
001047r 3               	.byte $80,$81,$a0,$a1,$c0,$c1,$e0,$e1
001047r 3               .endif
001047r 3               
001047r 3               .else
001047r 3  00 00        ddummy:	.byte 0,0
001049r 3               
001049r 3               dline:
001049r 3  BC rr rr     	ldy sprline,x		; point to screenleft
00104Cr 3               dline1:
00104Cr 3  BD rr rr     	lda objdta,x		; fetch spriteleft byte
00104Fr 3  85 61        	sta z80_a		; save spriteright byte
001051r 3               .if hflag
001051r 3               	sty ytmp
001051r 3               	clc
001051r 3               	tya
001051r 3               	adc scraddr
001051r 3               	sta ddummy
001051r 3               	lda scraddr+1
001051r 3               	adc #0
001051r 3               	sta ddummy+1
001051r 3               	lda ddummy
001051r 3               	and #31
001051r 3               	sta dispx
001051r 3               	sec
001051r 3               	lda ddummy+1
001051r 3               	sbc #>ScreenAddr
001051r 3               	sta dispy
001051r 3               	jsr pradd
001051r 3               	ldy #0
001051r 3               	lda (bufaddr),y
001051r 3               	cmp #HIDDEN
001051r 3               	beq sline
001051r 3               	ldy ytmp
001051r 3               .endif
001051r 3  A5 61        	lda z80_a
001053r 3  25 62        	and z80_c		; mask left
001055r 3  51 rr        	eor (scraddr),y		; merge with screenleft
001057r 3  91 rr        	sta (scraddr),y		; write screenleft
001059r 3               sline:
001059r 3               .if hflag
001059r 3               	ldy ytmp
001059r 3               .endif
001059r 3  E8           	inx			; next spritebyte
00105Ar 3  C8           	iny			; point to screenmiddle
00105Br 3               .if hflag
00105Br 3               	sty ytmp
00105Br 3               	ldy #1
00105Br 3               	lda (bufaddr),y
00105Br 3               	cmp #HIDDEN
00105Br 3               	beq sline2
00105Br 3               	ldy ytmp
00105Br 3               .endif
00105Br 3               dline2:
00105Br 3  BD rr rr     	lda objdta,x		; fetch spritemiddle byte
00105Er 3  51 rr        	eor (scraddr),y		; merge with screenmiddle
001060r 3  91 rr        	sta (scraddr),y		; write screenmiddle
001062r 3               sline2:
001062r 3               .if hflag
001062r 3               	ldy ytmp
001062r 3               .endif
001062r 3  C8           	iny			; point to screenright
001063r 3               .if hflag
001063r 3               	sty ytmp
001063r 3               	ldy #2
001063r 3               	lda (bufaddr),y
001063r 3               	cmp #HIDDEN
001063r 3               	beq sline3
001063r 3               	ldy ytmp
001063r 3               .endif
001063r 3  A5 61        	lda z80_a		; fetch spriteright byte
001065r 3  25 63        	and z80_b		; mask right
001067r 3  51 rr        	eor (scraddr),y		; merge with screenright
001069r 3  91 rr        	sta (scraddr),y		; write screenright
00106Br 3               sline3:
00106Br 3               .if hflag
00106Br 3               	ldy ytmp
00106Br 3               .endif
00106Br 3  E8           	inx			; next spritebyte
00106Cr 3               
00106Cr 3  60           	rts
00106Dr 3               
00106Dr 3               ;-----------------------------------------------------------------
00106Dr 3               
00106Dr 3               ddline:
00106Dr 3  BC rr rr     	ldy sprline,x		; point to screenleft
001070r 3               ddline1:
001070r 3  BD rr rr     	lda objdta,x		; fetch spriteleft byte
001073r 3  85 61        	sta z80_a		; save spriteright byte
001075r 3               .if hflag
001075r 3               	sty ytmp
001075r 3               	clc
001075r 3               	tya
001075r 3               	adc z80_hlp
001075r 3               	sta ddummy
001075r 3               	lda z80_hlp+1
001075r 3               	adc #0
001075r 3               	sta ddummy+1
001075r 3               	lda ddummy
001075r 3               	and #31
001075r 3               	sta dispx
001075r 3               	sec
001075r 3               	lda ddummy+1
001075r 3               	sbc #>ScreenAddr
001075r 3               	sta dispy
001075r 3               	jsr pradd
001075r 3               	ldy #0
001075r 3               	lda (bufaddr),y
001075r 3               	cmp #HIDDEN
001075r 3               	beq dsline
001075r 3               	ldy ytmp
001075r 3               .endif
001075r 3  A5 61        	lda z80_a
001077r 3  25 6E        	and z80_cp		; mask left
001079r 3  51 72        	eor (z80_hlp),y		; merge with screenleft
00107Br 3  91 72        	sta (z80_hlp),y		; write screenleft
00107Dr 3               dsline:
00107Dr 3               .if hflag
00107Dr 3               	ldy ytmp
00107Dr 3               .endif
00107Dr 3  E8           	inx			; next spritebyte
00107Er 3  C8           	iny			; point to screenmiddle
00107Fr 3               .if hflag
00107Fr 3               	sty ytmp
00107Fr 3               	ldy #1
00107Fr 3               	lda (bufaddr),y
00107Fr 3               	cmp #HIDDEN
00107Fr 3               	beq dsline2
00107Fr 3               	ldy ytmp
00107Fr 3               .endif
00107Fr 3               ddline2:
00107Fr 3  BD rr rr     	lda objdta,x		; fetch spritemiddle byte
001082r 3  51 72        	eor (z80_hlp),y		; merge with screenmiddle
001084r 3  91 72        	sta (z80_hlp),y		; write screenmiddle
001086r 3               dsline2:
001086r 3               .if hflag
001086r 3               	ldy ytmp
001086r 3               .endif
001086r 3  C8           	iny			; point to screenright
001087r 3               .if hflag
001087r 3               	sty ytmp
001087r 3               	ldy #2
001087r 3               	lda (bufaddr),y
001087r 3               	cmp #HIDDEN
001087r 3               	beq dsline3
001087r 3               	ldy ytmp
001087r 3               .endif
001087r 3  A5 61        	lda z80_a		; fetch spriteright byte
001089r 3  25 6F        	and z80_bp		; mask right
00108Br 3  51 72        	eor (z80_hlp),y		; merge with screenright
00108Dr 3  91 72        	sta (z80_hlp),y		; write screenright
00108Fr 3               dsline3:
00108Fr 3               .if hflag
00108Fr 3               	ldy ytmp
00108Fr 3               .endif
00108Fr 3  E8           	inx			; next spritebyte
001090r 3               
001090r 3  60           	rts
001091r 3               
001091r 3               sprline:
001091r 3  00 01 20 21  	.byte $00,$01,$20,$21,$40,$41,$60,$61
001095r 3  40 41 60 61  
001099r 3  80 81 A0 A1  	.byte $80,$81,$a0,$a1,$c0,$c1,$e0,$e1
00109Dr 3  C0 C1 E0 E1  
0010A1r 3  00 01 20 21  	.byte $00,$01,$20,$21,$40,$41,$60,$61
0010A5r 3  40 41 60 61  
0010A9r 3  80 81 A0 A1  	.byte $80,$81,$a0,$a1,$c0,$c1,$e0,$e1
0010ADr 3  C0 C1 E0 E1  
0010B1r 3               .if bflag
0010B1r 3               	.byte $00,$01,$20,$21,$40,$41,$60,$61
0010B1r 3               	.byte $80,$81,$a0,$a1,$c0,$c1,$e0,$e1
0010B1r 3               .endif
0010B1r 3               .endif
0010B1r 3               
0010B1r 3               ;-------------------------------------
0010B1r 3               ; Clear the play area window.
0010B1r 3               ;-------------------------------------
0010B1r 3               
0010B1r 3               .if clwflag
0010B1r 3               clw:
0010B1r 3               	lda wintop			; get coordinates of window.
0010B1r 3               	sta dispy			; put into dispx for calculation.
0010B1r 3               	lda winlft
0010B1r 3               	sta dispx
0010B1r 3               
0010B1r 3               	lda winhgt			; height of window.
0010B1r 3               	sta rrow			; copy to b register.
0010B1r 3               clw3:
0010B1r 3               	lda winwid 			; width of window.
0010B1r 3               	sta rcol
0010B1r 3               clw2:
0010B1r 3               	jsr gprad 			; get print address.
0010B1r 3               	lda #0				; zero byte to write.
0010B1r 3               	ldx #7				; pixel height of each cell.
0010B1r 3               clw1:
0010B1r 3               	ldy scrtab,x
0010B1r 3               	sta (scraddr),y 			; copy to screen.
0010B1r 3               	dex				; next screen row down.
0010B1r 3               	bpl clw1
0010B1r 3               
0010B1r 3               	inc dispx			; next column.
0010B1r 3               	dec rcol			; one less to do.
0010B1r 3               	bne clw2			; repeat for remaining columns.
0010B1r 3               
0010B1r 3               	lda winlft			; get left edge.
0010B1r 3               	sta dispx 			; reset x.
0010B1r 3               	inc dispy 			; next line down.
0010B1r 3               
0010B1r 3               	dec rrow
0010B1r 3               	bne clw3			; repeat down the screen.
0010B1r 3               
0010B1r 3               	lda wintop			; get coordinates of window.
0010B1r 3               	sta chary			; put into display position.
0010B1r 3               	lda winlft
0010B1r 3               	sta charx
0010B1r 3               	rts
0010B1r 3               .endif
0010B1r 3               
0010B1r 3               ;----------------------------------------------------------
0010B1r 3               ; Effects code.
0010B1r 3               ; Ticker routine is called 25 times per second.
0010B1r 3               ;
0010B1r 3               ; HL = txtscr = left text screen address
0010B1r 3               ; DE = txtscr+txtwid-1 = right text screen address
0010B1r 3               ; BC = txtpos = text scroller position
0010B1r 3               ;
0010B1r 3               ;----------------------------------------------------------
0010B1r 3               
0010B1r 3               .if sflag
0010B1r 3               scrly:
0010B1r 3               	rts
0010B1r 3               	.word txtscr         	; get left screen address.
0010B1r 3               	sta scr_l
0010B1r 3               	lda txtscr+1
0010B1r 3               	sta scr_l+1
0010B1r 3               	sta scr_r+1
0010B1r 3               
0010B1r 3               	stx xtmp
0010B1r 3               
0010B1r 3               	clc         		; get right screen address.
0010B1r 3               	lda scr_l
0010B1r 3               	adc txtwid
0010B1r 3               	sta scr_r
0010B1r 3               	dec scr_r
0010B1r 3               .if gflag
0010B1r 3               scrly7:
0010B1r 3               	ldx #2
0010B1r 3               .endif
0010B1r 3               scrly1:
0010B1r 3               	ldy txtwid		; set txtwide
0010B1r 3               	dey
0010B1r 3               	clc
0010B1r 3               scrly0:
0010B1r 3               	lda (scr_l),y		; scroll 1 line
0010B1r 3               	rol a
0010B1r 3               	sta (scr_l),y
0010B1r 3               	dey
0010B1r 3               	bpl scrly0
0010B1r 3               .if gflag
0010B1r 3               	dex
0010B1r 3               	bne scrly1
0010B1r 3               .endif
0010B1r 3               	clc			; point to next line
0010B1r 3               	lda scr_l
0010B1r 3               	adc #32
0010B1r 3               	sta scr_l
0010B1r 3               .if gflag
0010B1r 3               	bcc scrly7		; repeat 8 times
0010B1r 3               .else
0010B1r 3               	bcc scrly1		; repeat 8 times
0010B1r 3               .endif
0010B1r 3               	lda txtpos 		; get text pointer.
0010B1r 3               	sta scr_txt
0010B1r 3               	lda txtpos+1
0010B1r 3               	sta scr_txt+1
0010B1r 3               
0010B1r 3               	ldy #0
0010B1r 3               	lda (scr_txt),y 	; find character we're displaying.
0010B1r 3               	and #127 		; remove end marker bit if applicable.
0010B1r 3               	cmp #13			; is it newline?
0010B1r 3               	bne scrly5 		; no, it's okay.
0010B1r 3               	lda #32			; convert to a space instead.
0010B1r 3               scrly5:
0010B1r 3               	sta fntaddr		; calculate char address
0010B1r 3               	lda #0
0010B1r 3               	sta fntaddr+1
0010B1r 3               	asl fntaddr  		; multiply char by 8.
0010B1r 3               	rol fntaddr+1
0010B1r 3               	asl fntaddr
0010B1r 3               	rol fntaddr+1
0010B1r 3               	asl fntaddr
0010B1r 3               	rol fntaddr+1
0010B1r 3               	lda fntaddr
0010B1r 3               	clc
0010B1r 3               	adc #<(font-256)
0010B1r 3               	sta scrly3+1		; that's the low byte.
0010B1r 3               	lda fntaddr+1
0010B1r 3               	adc #>(font-256)
0010B1r 3               	sta scrly3+2		; add displacement.
0010B1r 3               	lda fntaddr+2
0010B1r 3               
0010B1r 3               	ldx #0
0010B1r 3               scrly3:
0010B1r 3               	lda $3333,x		; get image of char line.
0010B1r 3               	and txtbit
0010B1r 3               	beq scrly2		; don't plot pixel
0010B1r 3               	ldy scrline,x
0010B1r 3               	lda (scr_r),y
0010B1r 3               	clc
0010B1r 3               .if gflag
0010B1r 3               	ora #3
0010B1r 3               .else
0010B1r 3               	ora #1
0010B1r 3               .endif
0010B1r 3               	sta (scr_r),y		; plot pixel
0010B1r 3               scrly2:
0010B1r 3               	inx			; next line of char.
0010B1r 3               	cpx #8
0010B1r 3               	bne scrly3
0010B1r 3               
0010B1r 3               	lsr txtbit		; bit of text to display.
0010B1r 3               .if gflag
0010B1r 3               	lsr txtbit		; bit of text to display.
0010B1r 3               .endif
0010B1r 3               	bcs :+
0010B1r 3               	rts
0010B1r 3               :
0010B1r 3               	ldy #0
0010B1r 3               	lda (scr_txt),y 	; what was the character?
0010B1r 3               	asl a	  		; end of message?
0010B1r 3               	bcs scrly4
0010B1r 3               	inc txtpos
0010B1r 3               	bne :+
0010B1r 3               	inc txtpos+1
0010B1r 3               :
0010B1r 3               	jmp scrly6 		; not yet - continue.
0010B1r 3               scrly4:
0010B1r 3               	lda txtini 		; start of scrolling message.
0010B1r 3               	sta txtpos
0010B1r 3               	lda txtini+1
0010B1r 3               	sta txtpos+1
0010B1r 3               scrly6:
0010B1r 3               	lda #128
0010B1r 3               	sta txtbit
0010B1r 3               	ldx xtmp
0010B1r 3               	rts
0010B1r 3               
0010B1r 3               scrline:	.byte $00,$20,$40,$60,$80,$a0,$c0,$e0
0010B1r 3               
0010B1r 3               ;-------------------------------------------------------
0010B1r 3               ; Entry TICKER command
0010B1r 3               ;
0010B1r 3               ; Entry:
0010B1r 3               ;  z80_b = message nr
0010B1r 3               ;  z80_c = width
0010B1r 3               ;-------------------------------------------------------
0010B1r 3               
0010B1r 3               iscrly:
0010B1r 3               	jsr prescr 		; set up display position.
0010B1r 3               
0010B1r 3               	lda #<msgdat 		; text messages.
0010B1r 3               	sta z80_l
0010B1r 3               	lda #>msgdat
0010B1r 3               	sta z80_h
0010B1r 3               
0010B1r 3               	lda z80_c 		; width.
0010B1r 3               	sec
0010B1r 3               	sbc #1			; subtract one.
0010B1r 3               	cmp #32 		; is it between 1 and 32?
0010B1r 3               	bcc :+
0010B1r 3               	lda #$60
0010B1r 3               	jmp iscrl0		; no, disable messages.
0010B1r 3               :
0010B1r 3               	ldx z80_b		; message number.
0010B1r 3               	jsr getwrd 		; find message start.
0010B1r 3               
0010B1r 3               	lda z80_l		; set initial text position.
0010B1r 3               	sta txtini
0010B1r 3               	lda z80_h
0010B1r 3               	sta txtini+1
0010B1r 3               
0010B1r 3               	lda #$ad		; code for lda adrr
0010B1r 3               iscrl0:
0010B1r 3               	sta scrly		; enable/disable scrolling routine.
0010B1r 3               
0010B1r 3               	jsr prescr 		; set up display position.
0010B1r 3               	jsr gprad 		; get print address.
0010B1r 3               
0010B1r 3               	lda scraddr 		; set text screen address.
0010B1r 3               	sta txtscr
0010B1r 3               	lda scraddr+1
0010B1r 3               	sta txtscr+1
0010B1r 3               
0010B1r 3               	lda z80_c		; width.
0010B1r 3               	sta txtwid		; set width in working storage.
0010B1r 3               
0010B1r 3               	lda #128 		; start with leftmost bit.
0010B1r 3               	sta txtbit
0010B1r 3               
0010B1r 3               	jmp scrly4
0010B1r 3               .endif
0010B1r 3               
0010B1r 3               ;------------------------------------------------------------------
0010B1r 3               ; Dig routine, conditional assembly depending on dflag
0010B1r 3               ;------------------------------------------------------------------
0010B1r 3               .if dflag
0010B1r 3               dig:
0010B1r 3               	and #3
0010B1r 3               	beq digr		; dig right
0010B1r 3               	cmp #1
0010B1r 3               	beq digl		; dig left
0010B1r 3               	cmp #2
0010B1r 3               	beq digd		; dig down
0010B1r 3               
0010B1r 3               ; Dig up.
0010B1r 3               
0010B1r 3               digu:				; dig up
0010B1r 3               	ldy #8
0010B1r 3               	lda (z80_ix),y
0010B1r 3               	sec
0010B1r 3               	sbc #2
0010B1r 3               	sta dispy		; set y
0010B1r 3               
0010B1r 3               	iny
0010B1r 3               	lda (z80_ix),y
0010B1r 3               	sta dispx		; set x
0010B1r 3               	jmp digv
0010B1r 3               
0010B1r 3               ; Dig down.
0010B1r 3               
0010B1r 3               digd:
0010B1r 3               	ldy #9
0010B1r 3               	lda (z80_ix),y
0010B1r 3               	sta dispx		; set y
0010B1r 3               
0010B1r 3               	dey
0010B1r 3               	clc
0010B1r 3               	lda (z80_ix),y
0010B1r 3               	adc #16
0010B1r 3               	sta dispy		; set y
0010B1r 3               	jmp digv
0010B1r 3               
0010B1r 3               ; Dig left.
0010B1r 3               
0010B1r 3               digl:
0010B1r 3               	ldy #8
0010B1r 3               	lda (z80_ix),y
0010B1r 3               	sta dispy		; set y
0010B1r 3               
0010B1r 3               	iny
0010B1r 3               	lda (z80_ix),y
0010B1r 3               	sec
0010B1r 3               	sbc #2			; x=x-2
0010B1r 3               	sta dispx		; set x
0010B1r 3               	jmp digh
0010B1r 3               
0010B1r 3               ; Dig right.
0010B1r 3               
0010B1r 3               digr:
0010B1r 3               	ldy #8
0010B1r 3               	lda (z80_ix),y
0010B1r 3               	sta dispy		; set y
0010B1r 3               
0010B1r 3               	iny
0010B1r 3               	lda (z80_ix),y
0010B1r 3               	clc
0010B1r 3               	adc #16
0010B1r 3               	sta dispx		; set x+16
0010B1r 3               	jmp digh
0010B1r 3               
0010B1r 3               ; Vertical digging
0010B1r 3               
0010B1r 3               digv:
0010B1r 3               	jsr tstbl		; check blocktype in MAP
0010B1r 3               	jsr fdchk		; test if FODDER
0010B1r 3               
0010B1r 3               	clc
0010B1r 3               	lda dispx		; look 1 cell down
0010B1r 3               	adc #8
0010B1r 3               	sta dispx
0010B1r 3               	jsr tstbl		; check blocktype in MAP
0010B1r 3               	jsr fdchk
0010B1r 3               	lda dispx
0010B1r 3               	and #7
0010B1r 3               	bne :+
0010B1r 3               	rts
0010B1r 3               :
0010B1r 3               	clc
0010B1r 3               	lda dispx		; look 1 cell down
0010B1r 3               	adc #8
0010B1r 3               	sta dispx
0010B1r 3               	jsr tstbl		; check blocktype in MAP
0010B1r 3               	jmp fdchk
0010B1r 3               
0010B1r 3               ; Horizontal digging
0010B1r 3               
0010B1r 3               digh:
0010B1r 3               	jsr tstbl		; check blocktype in MAP
0010B1r 3               	jsr fdchk		; test if FODDER
0010B1r 3               
0010B1r 3               	clc
0010B1r 3               	lda dispy		; look 1 cell down
0010B1r 3               	adc #8
0010B1r 3               	sta dispy
0010B1r 3               	jsr tstbl		; check blocktype in MAP
0010B1r 3               	jsr fdchk
0010B1r 3               	lda dispy
0010B1r 3               	and #7
0010B1r 3               	bne :+
0010B1r 3               	rts
0010B1r 3               :
0010B1r 3               	clc
0010B1r 3               	lda dispy		; look 1 cell down
0010B1r 3               	adc #8
0010B1r 3               	sta dispy
0010B1r 3               	jsr tstbl		; check blocktype in MAP
0010B1r 3               	jmp fdchk
0010B1r 3               
0010B1r 3               digcnt:	.byte 0
0010B1r 3               .endif
0010B1r 3               
0010B1r 3               ;------------------------------------------------------------------
0010B1r 3               ; Code added to process Crumbling Blocks
0010B1r 3               ;------------------------------------------------------------------
0010B1r 3               
0010B1r 3               .if crflag
0010B1r 3               crumble:
0010B1r 3               	lda vard
0010B1r 3               	and #3
0010B1r 3               	bne crumble3
0010B1r 3               
0010B1r 3               	ldy #9
0010B1r 3               	lda (z80_ix),y
0010B1r 3               	sta dispx
0010B1r 3               
0010B1r 3               	dey
0010B1r 3               	clc
0010B1r 3               	lda (z80_ix),y
0010B1r 3               	adc #16
0010B1r 3               	sta dispy
0010B1r 3               
0010B1r 3               	and #6
0010B1r 3               	bne crumble3
0010B1r 3               
0010B1r 3               	jsr tstbl		; test block left
0010B1r 3               	cmp #9
0010B1r 3               	bcc crumble1
0010B1r 3               	jsr crumble5
0010B1r 3               crumble1:
0010B1r 3               	clc
0010B1r 3               	lda dispx		; look 1 cell down
0010B1r 3               	adc #8
0010B1r 3               	sta dispx
0010B1r 3               	jsr tstbl		; test block left
0010B1r 3               	cmp #9
0010B1r 3               	bcc crumble2
0010B1r 3               	jsr crumble5
0010B1r 3               crumble2:
0010B1r 3               	lda dispx
0010B1r 3               	and #7
0010B1r 3               	beq crumble3
0010B1r 3               	clc
0010B1r 3               	lda dispx		; look 1 cell down
0010B1r 3               	adc #8
0010B1r 3               	sta dispx
0010B1r 3               	jsr tstbl		; test block left
0010B1r 3               	cmp #9
0010B1r 3               	bcc crumble3
0010B1r 3               	jsr crumble5
0010B1r 3               crumble3:
0010B1r 3               	rts
0010B1r 3               
0010B1r 3               crumble5:
0010B1r 3               	clc
0010B1r 3               	adc #1
0010B1r 3               	cmp #$11
0010B1r 3               	bcc crumble4
0010B1r 3               	lda #0
0010B1r 3               crumble4:
0010B1r 3               	ldy #0
0010B1r 3               	sta (bufaddr),y
0010B1r 3               	sta tmp
0010B1r 3               
0010B1r 3               	lda dispx		; x=x/8
0010B1r 3               	pha
0010B1r 3               	lsr a
0010B1r 3               	lsr a
0010B1r 3               	lsr a
0010B1r 3               	sta dispx
0010B1r 3               
0010B1r 3               	lda dispy		; y=y/8
0010B1r 3               	pha
0010B1r 3               	lsr a
0010B1r 3               	lsr a
0010B1r 3               	lsr a
0010B1r 3               	sta dispy
0010B1r 3               
0010B1r 3               	lda tmp
0010B1r 3               	jsr pattr 		; write block.
0010B1r 3               
0010B1r 3               	pla
0010B1r 3               	sta dispy
0010B1r 3               	pla
0010B1r 3               	sta dispx
0010B1r 3               	rts
0010B1r 3               .endif
0010B1r 3               
0010B1r 3               ; User routine.  Put your own code in here to be called with USER instruction.
0010B1r 3               ; if USER has an argument it will be passed in the accumulator.
0010B1r 3               
0010B1r 3               user:
0010B1r 3               	.include "user.inc"
0010B1r 4  60           	rts
0010B2r 4               
0010B2r 3               
0010B2r 3               ;fontpointer:	.byte 0,0
0010B2r 3               ;TmpAddr:	.byte 0,0
0010B2r 3               
0010B2r 3               ;loopa:		.byte 0
0010B2r 3               ;loopb:		.byte 0
0010B2r 3               ;loopc:		.byte 0
0010B2r 3               
0010B2r 3               .if gflag
0010B2r 3               setfgcol:
0010B2r 3               	and #3
0010B2r 3               	tay
0010B2r 3               	lda codcol,y
0010B2r 3               	jmp calfgc
0010B2r 3               
0010B2r 3               setbgcol:
0010B2r 3               	and #3
0010B2r 3               calbgc:
0010B2r 3               	tay
0010B2r 3               	lda codcol,y
0010B2r 3               	pha
0010B2r 3               	lda andeor
0010B2r 3               	eor andeor+1
0010B2r 3               	tax
0010B2r 3               	pla
0010B2r 3               	sta andeor+1
0010B2r 3               	txa
0010B2r 3               calfgc:
0010B2r 3               	eor andeor+1
0010B2r 3               	sta andeor
0010B2r 3               calex1:
0010B2r 3               	rts
0010B2r 3               
0010B2r 3               codcol:	.byte $00,$55,$aa,$ff
0010B2r 3               .else
0010B2r 3               setfgcol:
0010B2r 3               setbgcol:
0010B2r 3  60           	rts
0010B3r 3               .endif
0010B3r 3  00 00        andeor:	.byte 0,0
0010B5r 3               
0010B5r 3               .if rflag
0010B5r 3               ;----------------------------------------------------
0010B5r 3               ; Shift tables
0010B5r 3               ;----------------------------------------------------
0010B5r 3               
0010B5r 3               shift_table:
0010B5r 3               .word shift0
0010B5r 3               .word shift2
0010B5r 3               .word shift4
0010B5r 3               .word shift6
0010B5r 3               
0010B5r 3               ;.align 256
0010B5r 3               shift0:
0010B5r 3               .repeat 256, i
0010B5r 3               	.byte i
0010B5r 3               .endrep
0010B5r 3               
0010B5r 3               shift2:
0010B5r 3               .repeat 256, i
0010B5r 3               	.byte (i >> 2) | (i << 6) & $c0
0010B5r 3               .endrep
0010B5r 3               
0010B5r 3               shift4:
0010B5r 3               .repeat 256, i
0010B5r 3               	.byte (i >> 4) | ((i << 4) & $f0)
0010B5r 3               .endrep
0010B5r 3               
0010B5r 3               shift6:
0010B5r 3               .repeat 256, i
0010B5r 3               	.byte (i >> 6) | ((i << 2) & $fc)
0010B5r 3               .endrep
0010B5r 3               .endif
0010B5r 3               
0010B5r 3  04           numblk:	.byte (sprgfx-bprop)
0010B6r 3               
0010B6r 3               ; Everything below here will be generated by the editors.
0010B6r 3               
0010B6r 3               
0010B6r 3  60                   rts
0010B7r 3               WINDOWTOP = 1
0010B7r 3               WINDOWLFT = 1
0010B7r 3               WINDOWHGT = 22
0010B7r 3               WINDOWWID = 22 ;@
0010B7r 3               MAPWID = 3
0010B7r 3  FF FF FF             .byte 255,255,255
0010BAr 3               mapdat:
0010BAr 3  FF 00 FF             .byte 255,0,255
0010BDr 3  FF FF FF             .byte 255,255,255
0010C0r 3  01           stmap:  .byte 1
0010C1r 3               
0010C1r 3               evnt00:
0010C1r 3  60                   rts
0010C2r 3               evnt01:
0010C2r 3  60                   rts
0010C3r 3               evnt02:
0010C3r 3  60                   rts
0010C4r 3               evnt03:
0010C4r 3  60                   rts
0010C5r 3               evnt04:
0010C5r 3  60                   rts
0010C6r 3               evnt05:
0010C6r 3  60                   rts
0010C7r 3               evnt06:
0010C7r 3  60                   rts
0010C8r 3               evnt07:
0010C8r 3  60                   rts
0010C9r 3               evnt08:
0010C9r 3  60                   rts
0010CAr 3               evnt09:
0010CAr 3  60                   rts
0010CBr 3               evnt10:
0010CBr 3  60                   rts
0010CCr 3               evnt11:
0010CCr 3  A9 17                lda #23		; AT
0010CEr 3  85 rr                sta chary
0010D0r 3  A9 14                lda #20
0010D2r 3  85 rr                sta charx
0010D4r 3  A9 rr                lda #<displ0	; DISPLAYTRIPLE
0010D6r 3  85 62                sta z80_c
0010D8r 3  A9 rr                lda #>displ0
0010DAr 3  85 63                sta z80_b
0010DCr 3  A5 rr                lda clock
0010DEr 3  20 rr rr             jsr num2td
0010E1r 3  20 rr rr             jsr displ1
0010E4r 3  60                   rts
0010E5r 3               evnt12:
0010E5r 3  60                   rts
0010E6r 3               evnt13:
0010E6r 3  60                   rts
0010E7r 3               evnt14:
0010E7r 3  A9 03                lda #3
0010E9r 3                       ; BORDER command
0010E9r 3  29 07                and #7
0010EBr 3  85 rr                sta tmp
0010EDr 3  AD 0F 90             lda RegF
0010F0r 3  29 F8                and #%11111000
0010F2r 3  05 rr                ora tmp
0010F4r 3  8D 0F 90             sta RegF
0010F7r 3  A9 01                lda #1 	; PAPER
0010F9r 3  0A                   asl a
0010FAr 3  0A                   asl a
0010FBr 3  0A                   asl a
0010FCr 3  0A                   asl a
0010FDr 3  85 rr                sta tmp
0010FFr 3  AD 0F 90             lda RegF
001102r 3  29 8F                and #%10001111
001104r 3  05 rr                ora tmp
001106r 3  8D 0F 90             sta RegF
001109r 3  A9 00                lda #0		; AT
00110Br 3  85 rr                sta chary
00110Dr 3  A9 04                lda #4
00110Fr 3  85 rr                sta charx
001111r 3  A9 00                lda #0 	; INK
001113r 3  8D rr rr             sta fontcol
001116r 3  A9 00                lda #0		; PRINT
001118r 3  20 rr rr             jsr dmsg
00111Br 3  A9 02                lda #2 	; INK
00111Dr 3  8D rr rr             sta fontcol
001120r 3  A9 01                lda #1		; PRINT
001122r 3  20 rr rr             jsr dmsg
001125r 3  A9 05                lda #5 	; INK
001127r 3  8D rr rr             sta fontcol
00112Ar 3  A9 02                lda #2		; PRINT
00112Cr 3  20 rr rr             jsr dmsg
00112Fr 3  A9 06                lda #6 	; INK
001131r 3  8D rr rr             sta fontcol
001134r 3  60                   rts
001135r 3               evnt15:
001135r 3  60                   rts
001136r 3               evnt16:
001136r 3  60                   rts
001137r 3               evnt17:
001137r 3  60                   rts
001138r 3               evnt18:
001138r 3  60                   rts
001139r 3               evnt19:
001139r 3  60                   rts
00113Ar 3               evnt20:
00113Ar 3  60                   rts
00113Br 3  60           ptcusr: rts
00113Cr 3               msgdat:
00113Cr 3  44 45 4D 4F          .byte "DEMO",160
001140r 3  A0           
001141r 3  56 49 43 32          .byte "VIC20",160
001145r 3  30 A0        
001147r 3  4D 50 41 47          .byte "MPAG",196
00114Br 3  C4           
00114Cr 3               nummsg:
00114Cr 3  03                   .byte 3
00114Dr 3               chgfx:
00114Dr 3  FF FF FF FF          .byte 255,255,255,255,255,255,255,255
001151r 3  FF FF FF FF  
001155r 3  01 01 01 FF          .byte 1,1,1,255,16,16,16,255
001159r 3  10 10 10 FF  
00115Dr 3  AA 55 AA 55          .byte 170,85,170,85,170,85,170,85
001161r 3  AA 55 AA 55  
001165r 3  00 11 00 44          .byte 0,17,0,68,0,34,0,136
001169r 3  00 22 00 88  
00116Dr 3               bcol:
00116Dr 3  00                   .byte 0
00116Er 3  02                   .byte 2
00116Fr 3  04                   .byte 4
001170r 3  05                   .byte 5
001171r 3               bprop:
001171r 3  00                   .byte 0
001172r 3  02                   .byte 2
001173r 3  04                   .byte 4
001174r 3  00                   .byte 0
001175r 3               sprgfx:
001175r 3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
001179r 3  00 00 00 00  
00117Dr 3  00 00 00 00  
001195r 3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
001199r 3  00 00 00 00  
00119Dr 3  00 00 00 00  
0011B5r 3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0011B9r 3  00 00 00 00  
0011BDr 3  00 00 00 00  
0011D5r 3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0011D9r 3  00 00 00 00  
0011DDr 3  00 00 00 00  
0011F5r 3               frmlst:
0011F5r 3  00 01 01 00          .byte 0,1,1,0
0011F9r 3               scdat:
0011F9r 3  22 01                .word 290
0011FBr 3  FF 01 17 FF          .byte 255,1,23,255,0,20,1,1,255,0,20,1,1,2,2,255,1,9,3,3,255,1,9,2,2,1,255,2,7,1,3,3,1
0011FFr 3  00 14 01 01  
001203r 3  FF 00 14 01  
00121Cr 3  FF 02 06 01          .byte 255,2,6,1,1,2,2,1,255,2,7,1,3,3,1,255,2,6,1,1,2,2,1,255,2,8,3,3,1,255,2,4,255,1,4
001220r 3  01 02 02 01  
001224r 3  FF 02 07 01  
00123Fr 3  02 02 01 FF          .byte 2,2,1,255,2,8,3,3,1,255,2,4,1,3,1,1,2,2,1,1,1,2,2,255,1,4,3,3,1,255,2,4,1
001243r 3  02 08 03 03  
001247r 3  01 FF 02 04  
001260r 3  03 01 01 FF          .byte 3,1,1,255,2,10,1,3,3,1,255,2,4,255,1,4,255,2,10,1,3,3,255,2,7,1,1,2,2,1,2,2,1,1,1
001264r 3  02 0A 01 03  
001268r 3  03 01 FF 02  
001283r 3  02 02 02 03          .byte 2,2,2,3,3,255,2,7,1,1,2,2,1,2,2,1,3,1,2,2,2,3,3,255,1,9,2,2,1,2,2,1,3
001287r 3  03 FF 02 07  
00128Br 3  01 01 02 02  
0012A4r 3  01 02 02 01          .byte 1,2,2,1,255,3,9,1,1,2,2,1,2,2,1,3,1,2,2,1,255,3,9,1,1,2,2,1,2,2,1,3,1
0012A8r 3  FF 03 09 01  
0012ACr 3  01 02 02 01  
0012C5r 3  02 02 01 03          .byte 2,2,1,3,3,255,1,9,2,2,1,2,2,1,3,1,2,2,1,3,3,1,255,2,6,1,1,2,2,1,2,2,1
0012C9r 3  03 FF 01 09  
0012CDr 3  02 02 01 02  
0012E6r 3  03 01 02 02          .byte 3,1,2,2,1,3,3,1,255,2,6,1,1,2,2,1,2,2,1,1,1,2,2,1,3,3,1,255,2,6,1,1,255,2,10
0012EAr 3  01 03 03 01  
0012EEr 3  FF 02 06 01  
001309r 3  01 03 03 FF          .byte 1,3,3,255,2,7,1,1,255,2,10,1,3,3,255,2,7,255,1,23
00130Dr 3  02 07 01 01  
001311r 3  FF 02 0A 01  
00131Dr 3               numsc:
00131Dr 3  01                   .byte 1
00131Er 3               nmedat:
00131Er 3  42 00 58 80          .byte 66,0,88,128,255
001322r 3  FF           
001323r 3               NUMOBJ = 1
001323r 3               objdta:
001323r 3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,160,32,0,160,32
001327r 3  00 00 00 00  
00132Br 3  00 00 00 00  
001349r 3               font:
001349r 3  00 00 00 00          .byte 0,0,0,0,0,0,0,0
00134Dr 3  00 00 00 00  
001351r 3  00 30 30 30          .byte 0,48,48,48,48,0,48,0
001355r 3  30 00 30 00  
001359r 3  00 6C 6C 00          .byte 0,108,108,0,0,0,0,0
00135Dr 3  00 00 00 00  
001361r 3  00 6C FE 6C          .byte 0,108,254,108,108,254,108,0
001365r 3  6C FE 6C 00  
001369r 3  00 18 7E 78          .byte 0,24,126,120,126,30,126,24
00136Dr 3  7E 1E 7E 18  
001371r 3  00 E6 EC 18          .byte 0,230,236,24,48,110,206,0
001375r 3  30 6E CE 00  
001379r 3  00 30 78 30          .byte 0,48,120,48,126,204,126,0
00137Dr 3  7E CC 7E 00  
001381r 3  00 18 30 00          .byte 0,24,48,0,0,0,0,0
001385r 3  00 00 00 00  
001389r 3  00 0C 18 18          .byte 0,12,24,24,24,24,12,0
00138Dr 3  18 18 0C 00  
001391r 3  00 60 30 30          .byte 0,96,48,48,48,48,96,0
001395r 3  30 30 60 00  
001399r 3  00 00 3C 18          .byte 0,0,60,24,126,24,60,0
00139Dr 3  7E 18 3C 00  
0013A1r 3  00 00 18 18          .byte 0,0,24,24,126,24,24,0
0013A5r 3  7E 18 18 00  
0013A9r 3  00 00 00 00          .byte 0,0,0,0,0,24,24,48
0013ADr 3  00 18 18 30  
0013B1r 3  00 00 00 18          .byte 0,0,0,24,36,24,0,0
0013B5r 3  24 18 00 00  
0013B9r 3  00 00 00 00          .byte 0,0,0,0,0,56,56,0
0013BDr 3  00 38 38 00  
0013C1r 3  00 00 06 0C          .byte 0,0,6,12,24,48,96,0
0013C5r 3  18 30 60 00  
0013C9r 3  00 7C EE EE          .byte 0,124,238,238,238,238,124,0
0013CDr 3  EE EE 7C 00  
0013D1r 3  00 38 3C 1C          .byte 0,56,60,28,28,126,126,0
0013D5r 3  1C 7E 7E 00  
0013D9r 3  00 7C FE 1E          .byte 0,124,254,30,248,246,254,0
0013DDr 3  F8 F6 FE 00  
0013E1r 3  00 7C DE 3C          .byte 0,124,222,60,30,254,124,0
0013E5r 3  1E FE 7C 00  
0013E9r 3  00 1C 3C 7C          .byte 0,28,60,124,220,254,60,0
0013EDr 3  DC FE 3C 00  
0013F1r 3  00 FE F6 F8          .byte 0,254,246,248,62,222,124,0
0013F5r 3  3E DE 7C 00  
0013F9r 3  00 7C EC F2          .byte 0,124,236,242,254,238,124,0
0013FDr 3  FE EE 7C 00  
001401r 3  00 FE FE 0E          .byte 0,254,254,14,60,120,120,0
001405r 3  3C 78 78 00  
001409r 3  00 7C EE 7C          .byte 0,124,238,124,238,238,124,0
00140Dr 3  EE EE 7C 00  
001411r 3  00 7C FE F6          .byte 0,124,254,246,222,62,124,0
001415r 3  DE 3E 7C 00  
001419r 3  00 00 30 30          .byte 0,0,48,48,0,48,48,0
00141Dr 3  00 30 30 00  
001421r 3  00 7C 82 BA          .byte 0,124,130,186,162,186,130,124
001425r 3  A2 BA 82 7C  
001429r 3  00 00 0C 18          .byte 0,0,12,24,48,24,12,0
00142Dr 3  30 18 0C 00  
001431r 3  00 00 00 7E          .byte 0,0,0,126,0,126,0,0
001435r 3  00 7E 00 00  
001439r 3  00 00 30 18          .byte 0,0,48,24,12,24,48,0
00143Dr 3  0C 18 30 00  
001441r 3  00 7C C6 0C          .byte 0,124,198,12,24,0,24,0
001445r 3  18 00 18 00  
001449r 3  00 7C DE FE          .byte 0,124,222,254,254,192,124,0
00144Dr 3  FE C0 7C 00  
001451r 3  00 7C EE FE          .byte 0,124,238,254,238,238,108,0
001455r 3  EE EE 6C 00  
001459r 3  00 7C EE FC          .byte 0,124,238,252,238,254,124,0
00145Dr 3  EE FE 7C 00  
001461r 3  00 7C FE E0          .byte 0,124,254,224,254,254,124,0
001465r 3  FE FE 7C 00  
001469r 3  00 FC EE EE          .byte 0,252,238,238,254,254,252,0
00146Dr 3  FE FE FC 00  
001471r 3  00 7E F0 FC          .byte 0,126,240,252,240,254,126,0
001475r 3  F0 FE 7E 00  
001479r 3  00 7E F0 FC          .byte 0,126,240,252,240,240,240,0
00147Dr 3  F0 F0 F0 00  
001481r 3  00 7C FE F0          .byte 0,124,254,240,238,246,124,0
001485r 3  EE F6 7C 00  
001489r 3  00 EE EE FE          .byte 0,238,238,254,254,238,238,0
00148Dr 3  FE EE EE 00  
001491r 3  00 7E 7E 3C          .byte 0,126,126,60,60,126,126,0
001495r 3  3C 7E 7E 00  
001499r 3  00 1E 1E 1E          .byte 0,30,30,30,222,254,124,0
00149Dr 3  DE FE 7C 00  
0014A1r 3  00 EE FC F8          .byte 0,238,252,248,248,252,238,0
0014A5r 3  F8 FC EE 00  
0014A9r 3  00 70 F0 F0          .byte 0,112,240,240,252,254,126,0
0014ADr 3  FC FE 7E 00  
0014B1r 3  00 D6 FE FE          .byte 0,214,254,254,238,238,238,0
0014B5r 3  EE EE EE 00  
0014B9r 3  00 CE EE FE          .byte 0,206,238,254,254,238,230,0
0014BDr 3  FE EE E6 00  
0014C1r 3  00 7C FE EE          .byte 0,124,254,238,238,254,124,0
0014C5r 3  EE FE 7C 00  
0014C9r 3  00 FC EE EE          .byte 0,252,238,238,252,240,240,0
0014CDr 3  FC F0 F0 00  
0014D1r 3  00 7C FE FE          .byte 0,124,254,254,238,242,124,0
0014D5r 3  EE F2 7C 00  
0014D9r 3  00 FC FE EE          .byte 0,252,254,238,252,238,238,0
0014DDr 3  FC EE EE 00  
0014E1r 3  00 7C F0 FC          .byte 0,124,240,252,30,254,124,0
0014E5r 3  1E FE 7C 00  
0014E9r 3  00 FE FE 38          .byte 0,254,254,56,124,124,124,0
0014EDr 3  7C 7C 7C 00  
0014F1r 3  00 EE EE EE          .byte 0,238,238,238,238,254,124,0
0014F5r 3  EE FE 7C 00  
0014F9r 3  00 EE EE EE          .byte 0,238,238,238,238,124,56,0
0014FDr 3  EE 7C 38 00  
001501r 3  00 EE EE EE          .byte 0,238,238,238,254,254,108,0
001505r 3  FE FE 6C 00  
001509r 3  00 EE FE 7C          .byte 0,238,254,124,254,254,238,0
00150Dr 3  FE FE EE 00  
001511r 3  00 EE EE FE          .byte 0,238,238,254,62,254,252,0
001515r 3  3E FE FC 00  
001519r 3  00 FE FE B8          .byte 0,254,254,184,118,254,254,0
00151Dr 3  76 FE FE 00  
001521r 3  00 1E 18 18          .byte 0,30,24,24,24,24,30,0
001525r 3  18 18 1E 00  
001529r 3  00 00 C0 60          .byte 0,0,192,96,48,24,12,0
00152Dr 3  30 18 0C 00  
001531r 3  00 F0 30 30          .byte 0,240,48,48,48,48,240,0
001535r 3  30 30 F0 00  
001539r 3  00 30 78 FC          .byte 0,48,120,252,48,48,48,0
00153Dr 3  30 30 30 00  
001541r 3  00 00 00 00          .byte 0,0,0,0,0,0,0,255
001545r 3  00 00 00 FF  
001549r 3  00 3C 66 F8          .byte 0,60,102,248,96,96,254,0
00154Dr 3  60 60 FE 00  
001551r 3  00 00 78 0C          .byte 0,0,120,12,124,204,124,0
001555r 3  7C CC 7C 00  
001559r 3  00 60 60 7C          .byte 0,96,96,124,102,102,124,0
00155Dr 3  66 66 7C 00  
001561r 3  00 00 3C 60          .byte 0,0,60,96,96,96,60,0
001565r 3  60 60 3C 00  
001569r 3  00 0C 0C 7C          .byte 0,12,12,124,204,204,124,0
00156Dr 3  CC CC 7C 00  
001571r 3  00 00 78 CC          .byte 0,0,120,204,248,192,124,0
001575r 3  F8 C0 7C 00  
001579r 3  00 1C 30 38          .byte 0,28,48,56,48,48,48,0
00157Dr 3  30 30 30 00  
001581r 3  00 00 7C CC          .byte 0,0,124,204,204,124,12,120
001585r 3  CC 7C 0C 78  
001589r 3  00 C0 C0 F8          .byte 0,192,192,248,204,204,204,0
00158Dr 3  CC CC CC 00  
001591r 3  00 30 00 70          .byte 0,48,0,112,48,48,120,0
001595r 3  30 30 78 00  
001599r 3  00 0C 00 0C          .byte 0,12,0,12,12,12,108,56
00159Dr 3  0C 0C 6C 38  
0015A1r 3  00 60 78 70          .byte 0,96,120,112,112,120,108,0
0015A5r 3  70 78 6C 00  
0015A9r 3  00 30 30 30          .byte 0,48,48,48,48,48,28,0
0015ADr 3  30 30 1C 00  
0015B1r 3  00 00 F8 FC          .byte 0,0,248,252,252,252,252,0
0015B5r 3  FC FC FC 00  
0015B9r 3  00 00 F8 CC          .byte 0,0,248,204,204,204,204,0
0015BDr 3  CC CC CC 00  
0015C1r 3  00 00 78 CC          .byte 0,0,120,204,204,204,120,0
0015C5r 3  CC CC 78 00  
0015C9r 3  00 00 F8 CC          .byte 0,0,248,204,204,248,192,192
0015CDr 3  CC F8 C0 C0  
0015D1r 3  00 00 7C CC          .byte 0,0,124,204,204,124,12,14
0015D5r 3  CC 7C 0C 0E  
0015D9r 3  00 00 3C 60          .byte 0,0,60,96,96,96,96,0
0015DDr 3  60 60 60 00  
0015E1r 3  00 00 78 C0          .byte 0,0,120,192,120,12,248,0
0015E5r 3  78 0C F8 00  
0015E9r 3  00 30 78 30          .byte 0,48,120,48,48,48,28,0
0015EDr 3  30 30 1C 00  
0015F1r 3  00 00 CC CC          .byte 0,0,204,204,204,204,120,0
0015F5r 3  CC CC 78 00  
0015F9r 3  00 00 CC CC          .byte 0,0,204,204,120,120,48,0
0015FDr 3  78 78 30 00  
001601r 3  00 00 CC FC          .byte 0,0,204,252,252,252,120,0
001605r 3  FC FC 78 00  
001609r 3  00 00 CC 78          .byte 0,0,204,120,48,120,204,0
00160Dr 3  30 78 CC 00  
001611r 3  00 00 CC CC          .byte 0,0,204,204,204,124,12,120
001615r 3  CC 7C 0C 78  
001619r 3  00 00 FC 18          .byte 0,0,252,24,48,96,252,0
00161Dr 3  30 60 FC 00  
001621r 3  00 1E 18 70          .byte 0,30,24,112,24,24,30,0
001625r 3  18 18 1E 00  
001629r 3  00 18 18 18          .byte 0,24,24,24,24,24,24,0
00162Dr 3  18 18 18 00  
001631r 3  00 F0 30 1C          .byte 0,240,48,28,48,48,240,0
001635r 3  30 30 F0 00  
001639r 3  00 3C 78 00          .byte 0,60,120,0,0,0,0,0
00163Dr 3  00 00 00 00  
001641r 3  7C C6 BB E3          .byte 124,198,187,227,227,187,198,124
001645r 3  E3 BB C6 7C  
001649r 3               jtab:
001649r 3  63                   .byte 99
00164Ar 3  35 15 93 22  keys:   .byte 53,21,147,34,144,4,20,33,17,1,146
00164Er 3  90 04 14 21  
001652r 3  11 01 92     
001655r 3               
001655r 2               
001655r 1               	.include "lib.inc"
001655r 2               ;============================================================
001655r 2               ; PLATFORM VARIABLES
001655r 2               ;============================================================
001655r 2               ;
001655r 2               ; Memory map:
001655r 2               ;
001655r 2               ;	$0000-$03ff	 1.0kB	CPU WS
001655r 2               ;	$0400-$0fff	 3,0kB	RAM
001655r 2               ;	$1000-$17ff	 2,0kB	VIDEO RAM
001655r 2               ;	$1800-$1fff	 2,0kB	CHAR RAM
001655r 2               ;	$2000-$7fff	24,0kB	RAM
001655r 2               ;	$8000-$8fff	 4,0kB	CHAR ROM
001655r 2               ;	$9000-$93ff	 1,0kB	VIC VIA's
001655r 2               ;	$9400-$97ff	 1,0kB	COLOUR RAM
001655r 2               ;	$9800-$9fff	 2,0kB	I/O
001655r 2               ;	$a000-$bfff	 8,0kB	RAM
001655r 2               ;	$c000-$dfff	 8,0kB	BASIC ROM
001655r 2               ;	$e000-$ffff	 8,0kB	KERNAL ROM
001655r 2               ;
001655r 2               ; Keyboard matrix:
001655r 2               ;                          	  $9121
001655r 2               ;          $9120	b7  b6  b5  b4  b3  b2  b1  b0
001655r 2               ; 	127-0111 1111 	F7  Hom  -   0   8   6   4   2
001655r 2               ; 	191-1011 1111 	F5       @   O   U   T   E   Q
001655r 2               ; 	223-1101 1111 	F3   =   :   K   H   F   S  Com
001655r 2               ; 	239-1110 1111 	F1  RSh  .   M   B   C   Z  Spc
001655r 2               ; 	247-1111 0111	Cur  /   ,   N   V   X  LSh Run
001655r 2               ; 	251-1111 1011	Cur  ;   L   J   G   D   A  Ctr
001655r 2               ; 	253-1111 1101	Ret  *   P   I   Y   R   W
001655r 2               ; 	254-1111 1110	Del Pnd  +   9   7   5   3   1
001655r 2               ;
001655r 2               ;	 P =$65,O=$14,A=$51,Q=$10
001655r 2               ;	SPC=$30,N=$44,M=$34
001655r 2               ;	 1 =$70,2=$00,3=$71,4=$01
001655r 2               ;
001655r 2               ; Joysticks:
001655r 2               ;
001655r 2               ;               b7    b6    b5    b4    b3    b2    b1    b0
001655r 2               ;	$9111	-     -     Fire  Left  Down  Up    -     -
001655r 2               ;	$9120	Right -     -     -     -     -     -     -
001655r 2               ;
001655r 2               ;	$9122	DDRB = Data Direction Register port $9120
001655r 2               ;               0 = input, 1 = output
001655r 2               ;		Bit7 should be 0 to read joystick $9120
001655r 2               ;
001655r 2               ; Video registers:
001655r 2               ;
001655r 2               ;	$9000	horizontal centering
001655r 2               ;		bits 0-6 horizontal centering
001655r 2               ;		bit  7 sets interlace scan
001655r 2               ;	$9001	vertical centering
001655r 2               ;	$9002	set # of columns
001655r 2               ;		bits 0-6 set # of columns
001655r 2               ;		bit 7 is part of video matrix address
001655r 2               ;	$9003	set # of rows
001655r 2               ;		bit 0 sets 8x8 or 16x8 chars
001655r 2               ;		bits 1-6 set # of rows
001655r 2               ;	$9005	start of character memory
001655r 2               ;		bits 0-3 start of character memory (default = 0)
001655r 2               ;		bits 4-7 is rest of video address (default= F)
001655r 2               ;		BITS 3,2,1,0 CM startinq address
001655r 2               ;			     HEX   DEC
001655r 2               ;		0000   ROM   8000  32768
001655r 2               ;		0001	     8400  33792
001655r 2               ;		0010	     8800  34816
001655r 2               ;		0011	     8C00  35840
001655r 2               ;		1000   RAM   0000  0000
001655r 2               ;		1001  xxxx
001655r 2               ;		1010  xxxx   unavail.
001655r 2               ;		1011  xxxx
001655r 2               ;		1100	     1000  4096
001655r 2               ;		1101	     1400  5120
001655r 2               ;		1110	     1800  6144
001655r 2               ;		1111	     1C00  7168
001655r 2               ;	$900f	Screen and border color register
001655r 2               ;		bits 4-7 select background color
001655r 2               ;		bits 0-2 select border color
001655r 2               ;		bit 3 selects inverted or normal mode
001655r 2               ;
001655r 2               ;------------------------------------------------------------
001655r 2               ; VIC variables:
001655r 2               ;
001655r 2  00           	fontcol:		.byte 0
001656r 2               
001656r 2               ; Settings
001656r 2               
001656r 2               	SrcWidth	= 24
001656r 2               	ScrHeight	= 24
001656r 2               	CentreX		= 2
001656r 2               	CentreY		= 24
001656r 2               
001656r 2               ; Addresses
001656r 2               
001656r 2               	MapAddr		= $400		; RAM
001656r 2               	ScreenAddr	= $1000		; VIDEO RAM
001656r 2               	CharAddress	= $1800		; CHAR RAM
001656r 2               	Reg0		= $9000		; Horizontal centering
001656r 2               	Reg1		= $9001		; Vertical centering
001656r 2               	Reg2		= $9002		; Set # of columns
001656r 2               	Reg3		= $9003		; Set # of rows
001656r 2               	Reg5		= $9005		; Start of character memory
001656r 2               	RegF		= $900f		; Screen and border color register
001656r 2               	JoyAddr1	= $9111		; Joystick address 1
001656r 2               	KeyColAddr	= $9120		; Keyboard column (write)
001656r 2               	JoyAddr2	= $9120		; Joystick address 2
001656r 2               	KeyRowAddr	= $9121		; Keyboard row (read)
001656r 2               	DDRB		= $9122		; Bit7 must be 0 for joystick read
001656r 2               	ColorAttr	= $9400		; Color attributes
001656r 2               
001656r 2               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
001656r 2               ; System constants Atom, needs to be updated for VIC usage
001656r 2               
001656r 2               ;	ScreenAddr  	= $8000		; Startaddress video RAM
001656r 2               	ScrSelAddr  	= $b000		; Screen selection address
001656r 2               	SpeakerBit  	= $b002		; Speaker bit
001656r 2               	CmdReg      	= $b400		; Command register AtoMMC
001656r 2               	DatReg      	= $b401		; Data register AtoMMC
001656r 2               	Timer2_Low  	= $b808		; Timer 2 low byte
001656r 2               	Timer2_High 	= $b809		; Timer 2 high byte
001656r 2               	Timer1_Low  	= $b804		; Timer 1 low byte
001656r 2               	Timer1_High 	= $b805		; Timer 1 high byte
001656r 2               
001656r 2               	green		= $00		; Colour definition filters
001656r 2               	yellow		= $55
001656r 2               	blue		= $aa
001656r 2               	red		= $ff
001656r 2               
001656r 2               ; System calls Atom
001656r 2               
001656r 2               	SCRSYNC	 	= $fe66		; wait for next CRT field flyback 60 Hz
001656r 2               	SCRSYNC1 	= $fe6b		; wait for CRT field flyback 60 Hz
001656r 2               	OSRDCH   	= $fe94		; get key subroutine
001656r 2               	OSWRCH	 	= $fff4		; write character
001656r 2               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
001656r 2               
001656r 2               ;============================================================
001656r 2               ; PLATFORM ROUTINES
001656r 2               ;============================================================
001656r 2               
001656r 2               ;------------------------------------------------------------
001656r 2               ; INIT, Initialise system
001656r 2               ;
001656r 2               ; - Disable interrupts
001656r 2               ; - Init NTSC screen
001656r 2               ; - Copy MPAGD font (96 chars = 768 bytes) to CHAR RAM (CHARcode 0-95)
001656r 2               ; - Copy MPAGD tiles to CHAR RAM starting at $1b00 (CHARcode 96-)
001656r 2               ; - Set up screen line offset address table.
001656r 2               ;------------------------------------------------------------
001656r 2               
001656r 2               Init:
001656r 2               
001656r 2               ; Disable interrupts
001656r 2               
001656r 2  A9 7F        	lda #$7f
001658r 2  8D 1E 91     	sta $911e
00165Br 2  8D 2E 91     	sta $912e
00165Er 2               
00165Er 2               ; Init screen for NTSC
00165Er 2               ; this sets the background and border color of the screen
00165Er 2               
00165Er 2               ; in this case border black and background black
00165Er 2  A9 18        	lda #%00011000
001660r 2  8D 0F 90     	sta RegF
001663r 2               
001663r 2               ; max num of columns (24)
001663r 2  AD 02 90     	lda Reg2
001666r 2  29 80        	and #%10000000
001668r 2  09 18        	ora #SrcWidth
00166Ar 2  8D 02 90     	sta Reg2
00166Dr 2               
00166Dr 2               ; max num of lines (mult by 2 - 24) for 8x8 chars
00166Dr 2  AD 03 90     	lda Reg3
001670r 2  29 41        	and #%01000001
001672r 2  09 30        	ora #SrcWidth*2		; number of rows multipled by two
001674r 2  8D 03 90     	sta Reg3
001677r 2               
001677r 2               ; horizontal and vertical position must be set for
001677r 2               ; non standard screen resolution (standard 22x23)
001677r 2               ; same games even allow the user to change them
001677r 2               ; these values are for PAL for NTSC should be different
001677r 2               
001677r 2               ; move horizontal position in the screen
001677r 2  AD 00 90     	lda Reg0
00167Ar 2  29 80        	and #%10000000
00167Cr 2  09 02        	ora #CentreX
00167Er 2  8D 00 90     	sta Reg0
001681r 2               
001681r 2               ; move vertical position in the screen
001681r 2  A9 18        	lda #CentreY
001683r 2  8D 01 90     	sta Reg1
001686r 2               
001686r 2               ; Set character data pointer to CHAR RAM at $1400
001686r 2  AD 05 90     	lda Reg5
001689r 2  29 F0        	and #%11110000
00168Br 2  09 0E        	ora #%1110
00168Dr 2  8D 05 90     	sta Reg5
001690r 2               
001690r 2               ; Reset fontcolor
001690r 2  A9 00        	lda #0		; Black
001692r 2  8D rr rr     	sta fontcol
001695r 2               
001695r 2               ; Copy MPAGD font (96 chars = 768 bytes) to CHAR RAM (CHARcode 0-95)
001695r 2               
001695r 2  A2 00        	ldx #0
001697r 2               @loop:
001697r 2  BD rr rr     	lda font,x
00169Ar 2  9D 00 18     	sta CharAddress,x
00169Dr 2  BD rr rr     	lda font + $100,x
0016A0r 2  9D 00 19     	sta CharAddress +$100,x
0016A3r 2  BD rr rr     	lda font + $200,x
0016A6r 2  9D 00 1A     	sta CharAddress + $200,x
0016A9r 2  E8           	inx
0016AAr 2  D0 EB        	bne @loop
0016ACr 2               
0016ACr 2               ; Copy MPAGD tiles to CHAR RAM starting at $1b00 (CHARcode 96-)
0016ACr 2               
0016ACr 2               ; Set source = MPAGD tileaddress
0016ACr 2               
0016ACr 2  A9 rr        	lda #<chgfx
0016AEr 2  85 rr        	sta tileaddr
0016B0r 2  A9 rr        	lda #>chgfx
0016B2r 2  85 rr        	sta tileaddr+1
0016B4r 2               
0016B4r 2               ; Set destination = CHAR RAM address
0016B4r 2               
0016B4r 2  A9 00        	lda #<(CharAddress + $300)
0016B6r 2  85 rr        	sta bufaddr
0016B8r 2  A9 1B        	lda #>(CharAddress + $300)
0016BAr 2  85 rr        	sta bufaddr+1
0016BCr 2               
0016BCr 2               ; Copy all MPAGD tiles into CHAR RAM
0016BCr 2               
0016BCr 2  A0 00        	ldy #0
0016BEr 2               @bloop:
0016BEr 2  B1 rr        	lda (tileaddr),y
0016C0r 2  91 rr        	sta (bufaddr),y
0016C2r 2  E6 rr        	inc tileaddr
0016C4r 2  D0 02        	bne :+
0016C6r 2  E6 rr        	inc tileaddr+1
0016C8r 2  E6 rr        :	inc bufaddr
0016CAr 2  D0 02        	bne :+
0016CCr 2  E6 rr        	inc bufaddr+1
0016CEr 2  A5 rr        :	lda tileaddr
0016D0r 2  C9 rr        	cmp #<bprop		; Check for last tileaddress
0016D2r 2  D0 EA        	bne @bloop
0016D4r 2  A5 rr        	lda tileaddr+1
0016D6r 2  C9 rr        	cmp #>bprop
0016D8r 2  D0 E4        	bne @bloop
0016DAr 2               
0016DAr 2               ; Set up screen line offset address table.
0016DAr 2               ; Save lb and hb of 24 lines in a table for reference
0016DAr 2               
0016DAr 2               setsat:
0016DAr 2  A9 00        	lda #0			; start
0016DCr 2  85 rr        	sta scraddr
0016DEr 2  85 rr        	sta scraddr+1
0016E0r 2               
0016E0r 2  A0 00        	ldy #0			; vertical lines on screen.
0016E2r 2               setsa0:
0016E2r 2  A5 rr        	lda scraddr
0016E4r 2  99 00 07     	sta SCROFF_lb,y		; write low byte.
0016E7r 2  A5 rr        	lda scraddr+1
0016E9r 2  99 18 07     	sta SCROFF_hb,y		; write high byte.
0016ECr 2  20 rr rr     	jsr nline		; next line down.
0016EFr 2  C8           	iny			; next position in table.
0016F0r 2  C0 18        	cpy #ScrHeight
0016F2r 2  D0 EE        	bne setsa0
0016F4r 2  60           	rts
0016F5r 2               
0016F5r 2               ;----------------------------------------------------------------------
0016F5r 2               ; CLS, Clear screen routine.
0016F5r 2               ;
0016F5r 2               ; Fill screenmem and colourmem  with space
0016F5r 2               ;----------------------------------------------------------------------
0016F5r 2               
0016F5r 2               cls:
0016F5r 2  A2 00        	ldx #0
0016F7r 2               clsloop:
0016F7r 2  A9 00        	lda #0
0016F9r 2  9D 00 10     	sta ScreenAddr,x	; Screen RAM
0016FCr 2  9D 00 11     	sta ScreenAddr+$100,x
0016FFr 2  9D 00 12     	sta ScreenAddr+$200,x
001702r 2  9D 00 94     	sta ColorAttr,x		; Colour RAM
001705r 2  9D 00 95     	sta ColorAttr+$100,x
001708r 2  9D 00 96     	sta ColorAttr+$200,x
00170Br 2  E8           	inx
00170Cr 2  D0 E9        	bne clsloop
00170Er 2  60           	rts
00170Fr 2               
00170Fr 2               ;----------------------------------------------------------------------
00170Fr 2               ; SETPAL, Set colour palette
00170Fr 2               ;
00170Fr 2               ; Not used at the moment
00170Fr 2               ;----------------------------------------------------------------------
00170Fr 2               
00170Fr 2               setpal:
00170Fr 2  60           	rts
001710r 2               
001710r 2               ;----------------------------------------------------------------------
001710r 2               ; PCHAR, Display character on screen
001710r 2               ;----------------------------------------------------------------------
001710r 2               
001710r 2               pchar:
001710r 2  38           	sec
001711r 2  E9 20        	sbc #32
001713r 2  85 rr        	sta fntaddr
001715r 2               
001715r 2               ; Set color attribute
001715r 2               
001715r 2  20 rr rr     	jsr gaadd
001718r 2  AD rr rr     	lda fontcol
00171Br 2  A0 00        	ldy #0
00171Dr 2  91 rr        	sta (bufaddr),y
00171Fr 2               
00171Fr 2               ; Display character
00171Fr 2               
00171Fr 2  20 rr rr     	jsr gprad		; get screen address.
001722r 2               pchar0:
001722r 2  A5 rr        	lda fntaddr
001724r 2  A0 00        	ldy #0
001726r 2  91 rr        	sta (scraddr),y 	; copy to screen.
001728r 2  60           	rts
001729r 2               
001729r 2               ;----------------------------------------------------------------------
001729r 2               ; GETOFFSET, Calculate bufaddr = Y*screen width + X
001729r 2               ;----------------------------------------------------------------------
001729r 2               
001729r 2               getoffset:
001729r 2  A4 rr        	ldy dispy
00172Br 2  B9 18 07     	lda SCROFF_hb,y
00172Er 2  85 rr        	sta bufaddr+1
001730r 2  B9 00 07     	lda SCROFF_lb,y
001733r 2  18           	clc
001734r 2  65 rr        	adc dispx
001736r 2  85 rr        	sta bufaddr
001738r 2  90 02        	bcc :+
00173Ar 2  E6 rr        	inc bufaddr+1
00173Cr 2  60           :	rts
00173Dr 2               
00173Dr 2               ;-------------------------------------------------------------
00173Dr 2               ; VSYNC, synchronize to 25 frames/sec
00173Dr 2               ;
00173Dr 2               ;  - read joystick/keyboard
00173Dr 2               ;  - handle sound
00173Dr 2               ;  - sync framerate with timer 25Hz
00173Dr 2               ;  - handle shrapnel every even frame
00173Dr 2               ;-------------------------------------------------------------
00173Dr 2               
00173Dr 2               vsync:
00173Dr 2  48           	pha
00173Er 2  98           	tya
00173Fr 2  48           	pha
001740r 2  8A           	txa
001741r 2  48           	pha
001742r 2  20 rr rr     	jsr joykey		; read joystick/keyboard.
001745r 2               
001745r 2  A6 A2        	ldx $a2			; Set Timer1 expired bit
001747r 2               vsync1:
001747r 2  E4 A2        	cpx $a2			; Check Interrupt Flag Register
001749r 2               ;	beq vsync1
001749r 2               
001749r 2  A5 rr        	lda clock
00174Br 2  29 01        	and #1
00174Dr 2  D0 03        	bne:+
00174Fr 2  20 rr rr     	jsr proshr		; handle shrapnel every even frame
001752r 2               :
001752r 2  AD rr rr     	lda sndtyp
001755r 2  F0 10        	beq sndskip
001757r 2               sndloop:
001757r 2  AD 02 B0     	lda SpeakerBit		; handle sound
00175Ar 2  AC rr rr     	ldy sndtyp
00175Dr 2               sndwait:
00175Dr 2  88           	dey
00175Er 2  D0 FD        	bne sndwait
001760r 2  49 04        	eor #4
001762r 2               ;	sta SpeakerBit
001762r 2  CE rr rr     	dec sndtyp
001765r 2  D0 F0        	bne sndloop
001767r 2               sndskip:
001767r 2  68           	pla
001768r 2  AA           	tax
001769r 2  68           	pla
00176Ar 2  A8           	tay
00176Br 2  68           	pla
00176Cr 2  60           	rts
00176Dr 2               
00176Dr 2               ;-------------------------------------------------------------
00176Dr 2               ; KTEST, scan key and return in carry if key pressed
00176Dr 2               ;
00176Dr 2               ; Keyboard test routine.
00176Dr 2               ;
00176Dr 2               ; Input:
00176Dr 2               ;  A = key to read, high nibble=col and low nibble=row
00176Dr 2               ;
00176Dr 2               ; Output:
00176Dr 2               ;  carry clr = key pressed
00176Dr 2               ;  carry set = key not pressed
00176Dr 2               ;--------------------------------------------------------
00176Dr 2               
00176Dr 2               ktest:
00176Dr 2  85 61        	sta z80_a		; save key
00176Fr 2               
00176Fr 2  4A           	lsr a			; set row
001770r 2  4A           	lsr a
001771r 2  4A           	lsr a
001772r 2  4A           	lsr a
001773r 2  AA           	tax
001774r 2  BD rr rr     	lda colmask,x
001777r 2  8D 20 91     	sta KeyColAddr
00177Ar 2               
00177Ar 2  A5 61        	lda z80_a
00177Cr 2  29 0F        	and #$0f
00177Er 2  AA           	tax
00177Fr 2               
00177Fr 2  AD 21 91     	lda KeyRowAddr		; read column
001782r 2  3D rr rr     	and keymask,x		; check key pressed
001785r 2  F0 02        	beq pressed
001787r 2  38           	sec			; key not pressed
001788r 2  60           	rts
001789r 2               pressed:
001789r 2  18           	clc			; key pressed
00178Ar 2  60           	rts
00178Br 2               
00178Br 2  7F BF DF EF  colmask:	.byte 127,191,223,239,247,251,253,254
00178Fr 2  F7 FB FD FE  
001793r 2  01 02 04 08  keymask:	.byte $01,$02,$04,$08,$10,$20,$40,$80
001797r 2  10 20 40 80  
00179Br 2               
00179Br 2               ;-------------------------------------------------------------
00179Br 2               ; JOY1SCAN, scan joystick1 and return key in z80_e
00179Br 2               ;-------------------------------------------------------------
00179Br 2               
00179Br 2               joy1scan:
00179Br 2  A9 FF        	lda #$ff
00179Dr 2  85 64        	sta z80_e
00179Fr 2               
00179Fr 2  AD 11 91     	lda JoyAddr1
0017A2r 2  4A           	lsr a
0017A3r 2  4A           	lsr a
0017A4r 2               
0017A4r 2  4A           	lsr a
0017A5r 2  26 64        	rol z80_e	; Up
0017A7r 2  4A           	lsr a
0017A8r 2  26 64        	rol z80_e	; Down
0017AAr 2  4A           	lsr a
0017ABr 2  26 64        	rol z80_e	; Left
0017ADr 2               
0017ADr 2  A9 7F        	lda #%01111111
0017AFr 2  8D 22 91     	sta DDRB	; Bit7 = input joystick b7
0017B2r 2  AD 20 91     	lda JoyAddr2
0017B5r 2  0A           	asl a
0017B6r 2  26 64        	rol z80_e	; Right
0017B8r 2  A9 FF        	lda #%11111111
0017BAr 2  8D 22 91     	sta DDRB	; Reset
0017BDr 2               
0017BDr 2  AD 11 91     	lda JoyAddr1
0017C0r 2  29 20        	and #%00100000
0017C2r 2  D0 14        	bne :+
0017C4r 2  A5 64        	lda z80_e
0017C6r 2  29 EF        	and #%11101111	; Fire
0017C8r 2  85 64        	sta z80_e
0017CAr 2               
0017CAr 2  AD rr rr     	lda keys+5	; Fire2
0017CDr 2  20 rr rr     	jsr ktest
0017D0r 2  B0 06        	bcs :+
0017D2r 2  A5 64        	lda z80_e
0017D4r 2  29 DF        	and #%11011111
0017D6r 2  85 64        	sta z80_e
0017D8r 2               :
0017D8r 2  AD rr rr     	lda keys+6	; Fire3
0017DBr 2  20 rr rr     	jsr ktest
0017DEr 2  B0 06        	bcs :+
0017E0r 2  A5 64        	lda z80_e
0017E2r 2  29 BF        	and #%10111111
0017E4r 2  85 64        	sta z80_e
0017E6r 2               :
0017E6r 2  60           	rts
0017E7r 2               
0017E7r 2               ;-------------------------------------------------------------
0017E7r 2               ; JOY2SCAN, scan joystick2 and return key in z80_e
0017E7r 2               ;-------------------------------------------------------------
0017E7r 2               
0017E7r 2               joy2scan:
0017E7r 2  60           	rts
0017E8r 2               
0017E8r 2               ;-------------------------------------------------------------
0017E8r 2               ; READKEY, Wait for keypress
0017E8r 2               ;-------------------------------------------------------------
0017E8r 2               
0017E8r 2               READKEY:
0017E8r 2  A9 00        	lda #0
0017EAr 2  8D 20 91     	sta KeyColAddr
0017EDr 2  AD 21 91     	lda KeyRowAddr
0017F0r 2  C9 FF        	cmp #$ff
0017F2r 2  F0 F4        	beq READKEY
0017F4r 2  60           	rts
0017F5r 2               
0017F5r 2               
0017F5r 1               	.include "z80.asm"
0017F5r 2               ;------------------------------------------------------
0017F5r 2               ; z80.asm
0017F5r 2               ; spectrum stuff
0017F5r 2               ; adresses
0017F5r 2               
0017F5r 2               
0017F5r 2               ; Contains seperatly 1 bit set
0017F5r 2               
0017F5r 2               _bitmem0	= $f8
0017F5r 2               _bitmem1	= $f9
0017F5r 2               _bitmem2	= $fa
0017F5r 2               _bitmem3	= $fb
0017F5r 2               _bitmem4	= $fc
0017F5r 2               _bitmem5	= $fd
0017F5r 2               _bitmem6	= $fe
0017F5r 2               _bitmem7	= $ff
0017F5r 2               
0017F5r 2               ; constants
0017F5r 2               _bitvalue0	= $01
0017F5r 2               _bitvalue1	= $02
0017F5r 2               _bitvalue2	= $04
0017F5r 2               _bitvalue3	= $08
0017F5r 2               _bitvalue4	= $10
0017F5r 2               _bitvalue5	= $20
0017F5r 2               _bitvalue6	= $40
0017F5r 2               _bitvalue7	= $80
0017F5r 2               
0017F5r 2               _notbitvalue0	= $fe
0017F5r 2               _notbitvalue1	= $fd
0017F5r 2               _notbitvalue2	= $fb
0017F5r 2               _notbitvalue3	= $f7
0017F5r 2               _notbitvalue4	= $ef
0017F5r 2               _notbitvalue5	= $df
0017F5r 2               _notbitvalue6	= $bf
0017F5r 2               _notbitvalue7	= $7f
0017F5r 2               
0017F5r 2               
0017F5r 2               exx:
0017F5r 2  A5 62        		lda z80_c
0017F7r 2  A4 6E        		ldy z80_cp
0017F9r 2  84 62        		sty z80_c
0017FBr 2  85 6E        		sta z80_cp
0017FDr 2  A5 63        		lda z80_b
0017FFr 2  A4 6F        		ldy z80_bp
001801r 2  84 63        		sty z80_b
001803r 2  85 6F        		sta z80_bp
001805r 2  A5 64        		lda z80_e
001807r 2  A4 70        		ldy z80_ep
001809r 2  84 64        		sty z80_e
00180Br 2  85 70        		sta z80_ep
00180Dr 2  A5 65        		lda z80_d
00180Fr 2  A4 71        		ldy z80_dp
001811r 2  84 65        		sty z80_d
001813r 2  85 71        		sta z80_dp
001815r 2  A5 rr        		lda scraddr
001817r 2  A4 72        		ldy z80_lp
001819r 2  84 rr        		sty scraddr
00181Br 2  85 72        		sta z80_lp
00181Dr 2  A5 rr        		lda scraddr+1
00181Fr 2  A4 73        		ldy z80_hp
001821r 2  84 rr        		sty scraddr+1
001823r 2  85 73        		sta z80_hp
001825r 2  60           		rts
001826r 2               
001826r 2               
001826r 1               eind_asm:
001826r 1               eop:					; End Of Program
001826r 1               
001826r 1               .out .sprintf("Gamecode size = %d bytes, free space = %d bytes", (eind_asm - main),(35840-eind_asm + main))
001826r 1               
